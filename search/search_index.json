{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Inttrest - AI-Powered Event Discovery Platform","text":"<p>Welcome to the comprehensive documentation for Inttrest, an innovative AI-powered event discovery platform that combines advanced artificial intelligence, interactive mapping, and Model Context Protocol (MCP) integration to revolutionize how users find and explore events.</p>"},{"location":"#platform-overview","title":"\ud83c\udf1f Platform Overview","text":"<p>Inttrest is a cutting-edge web application that leverages the power of AI to help users discover, explore, and interact with events in an intuitive and intelligent way. Built with modern technologies including the Vercel AI SDK, Next.js, and Mapbox, the platform provides a seamless experience for event discovery.</p> <pre><code>graph TB\n    subgraph \"User Interface\"\n        A[Next.js Frontend] --&gt; B[AI Chat Interface]\n        A --&gt; C[Interactive Map]\n        A --&gt; D[Event Discovery]\n    end\n\n    subgraph \"AI Layer\"\n        E[Vercel AI SDK] --&gt; F[OpenAI Integration]\n        E --&gt; G[Natural Language Processing]\n        E --&gt; H[Intelligent Search]\n    end\n\n    subgraph \"Data Sources\"\n        I[MCP Servers] --&gt; J[Eventbrite MCP]\n        I --&gt; K[Instagram MCP]\n        I --&gt; L[LinkedIn MCP]\n        I --&gt; M[Meetup MCP]\n    end\n\n    subgraph \"Infrastructure\"\n        N[MongoDB Database] --&gt; O[Event Storage]\n        P[Mapbox API] --&gt; Q[Location Services]\n        R[Geocoding] --&gt; S[Address Resolution]\n    end\n\n    A --&gt; E\n    E --&gt; I\n    A --&gt; N\n    A --&gt; P\n    I --&gt; N\n\n    style A fill:#e3f2fd\n    style E fill:#e8f5e8\n    style I fill:#fff3e0\n    style N fill:#f3e5f5</code></pre>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":""},{"location":"#ai-powered-discovery","title":"\ud83e\udd16 AI-Powered Discovery","text":"<ul> <li>Natural Language Chat: Interact with an intelligent AI assistant to find events using conversational queries</li> <li>Smart Recommendations: Get personalized event suggestions based on your interests and preferences</li> <li>Contextual Understanding: AI understands complex queries like \"tech events near me this weekend\"</li> </ul>"},{"location":"#interactive-mapping","title":"\ud83d\uddfa\ufe0f Interactive Mapping","text":"<ul> <li>Real-time Visualization: View events on an interactive Mapbox-powered map</li> <li>Geolocation Features: Find events based on your current location or any specified area</li> <li>Clustering &amp; Filtering: Organize events by category, date, and location with smart clustering</li> </ul>"},{"location":"#mcp-integration","title":"\ud83d\udd17 MCP Integration","text":"<ul> <li>Multi-Source Data: Aggregate events from multiple platforms through MCP servers</li> <li>Real-time Synchronization: Keep event data fresh with automated updates</li> <li>Extensible Architecture: Easily add new event sources through the MCP framework</li> </ul>"},{"location":"#modern-tech-stack","title":"\ud83d\udcbb Modern Tech Stack","text":"<ul> <li>Frontend: Next.js 15+ with React 19, TypeScript, and Tailwind CSS</li> <li>AI/ML: Vercel AI SDK with OpenAI integration</li> <li>Mapping: Mapbox GL JS for interactive maps</li> <li>Database: MongoDB for scalable event storage</li> <li>Architecture: Model Context Protocol (MCP) for data integration</li> </ul>"},{"location":"#repository-structure","title":"\ud83d\udcc1 Repository Structure","text":"<pre><code>inttrest/\n\u251c\u2500\u2500 frontend/                   # Next.js React application\n\u2502   \u251c\u2500\u2500 app/                   # Next.js App Router\n\u2502   \u2502   \u251c\u2500\u2500 api/              # API routes\n\u2502   \u2502   \u251c\u2500\u2500 layout.tsx        # Root layout\n\u2502   \u2502   \u251c\u2500\u2500 page.tsx          # Main page\n\u2502   \u2502   \u2514\u2500\u2500 globals.css       # Global styles\n\u2502   \u251c\u2500\u2500 components/           # React components\n\u2502   \u2502   \u251c\u2500\u2500 Chat.tsx         # AI chat interface\n\u2502   \u2502   \u2514\u2500\u2500 Map.tsx          # Interactive map\n\u2502   \u251c\u2500\u2500 public/              # Static assets\n\u2502   \u251c\u2500\u2500 package.json         # Dependencies\n\u2502   \u2514\u2500\u2500 next.config.ts       # Next.js configuration\n\u251c\u2500\u2500 mcp_servers/             # MCP server implementations\n\u2502   \u251c\u2500\u2500 eventbrite-mcp/      # Eventbrite integration\n\u2502   \u251c\u2500\u2500 instagram-server-next-mcp/  # Instagram integration\n\u2502   \u251c\u2500\u2500 linkedin-mcp-server/ # LinkedIn integration\n\u2502   \u251c\u2500\u2500 mcp-meetup/         # Meetup integration\n\u2502   \u2514\u2500\u2500 unified_server.py   # Unified MCP server\n\u251c\u2500\u2500 .qwen/                   # AI model configuration\n\u251c\u2500\u2500 requirements.txt         # Python dependencies\n\u251c\u2500\u2500 prompt.xml              # AI prompt configuration\n\u2514\u2500\u2500 repomix-output.xml      # Project documentation\n</code></pre>"},{"location":"#technology-stack","title":"\ud83d\udee0\ufe0f Technology Stack","text":""},{"location":"#frontend-technologies","title":"Frontend Technologies","text":"Technology Version Purpose Next.js 15.5.2 React framework with App Router React 19.1.0 UI component library TypeScript ^5 Type-safe JavaScript Tailwind CSS ^4 Utility-first CSS framework Mapbox GL ^3.14.0 Interactive mapping React Map GL ^7.1.1 React wrapper for Mapbox"},{"location":"#ai-ml-stack","title":"AI &amp; ML Stack","text":"Technology Version Purpose Vercel AI SDK ^5.0.28 AI framework and utilities @ai-sdk/openai ^2.0.23 OpenAI integration @ai-sdk/react ^2.0.28 React hooks for AI Zod ^4.1.5 Schema validation"},{"location":"#mcp-integration_1","title":"MCP &amp; Integration","text":"Technology Version Purpose @modelcontextprotocol/sdk ^1.17.4 MCP protocol implementation @vercel/mcp-adapter ^1.0.0 Vercel MCP integration MongoDB ^6.19.0 NoSQL database"},{"location":"#getting-started","title":"\ud83c\udfaf Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Node.js 18+ with npm/yarn/pnpm</li> <li>MongoDB (local or Atlas)</li> <li>API Keys:</li> <li>OpenAI API key</li> <li>Mapbox access token</li> <li>Event platform API keys (Eventbrite, etc.)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/FilippTrigub/inttrest.git\ncd inttrest\n</code></pre></p> </li> <li> <p>Install dependencies:    <pre><code>cd frontend\nnpm install\n# or\npnpm install\n</code></pre></p> </li> <li> <p>Configure environment variables:    <pre><code>cp .env.example .env.local\n# Edit .env.local with your API keys\n</code></pre></p> </li> <li> <p>Start the development server:    <pre><code>npm run dev\n# or\npnpm dev\n</code></pre></p> </li> <li> <p>Open your browser:    Visit http://localhost:3000 to see the application.</p> </li> </ol>"},{"location":"#environment-configuration","title":"Environment Configuration","text":"<p>Create a <code>.env.local</code> file in the frontend directory:</p> <pre><code># OpenAI Configuration\nOPENAI_API_KEY=your_openai_api_key_here\n\n# Mapbox Configuration\nNEXT_PUBLIC_MAPBOX_ACCESS_TOKEN=your_mapbox_token_here\n\n# MongoDB Configuration\nMONGODB_URI=mongodb://localhost:27017/inttrest\n# or for MongoDB Atlas:\n# MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/inttrest\n\n# MCP Server URLs\nMCP_EVENTBRITE_URL=http://localhost:3001\nMCP_INSTAGRAM_URL=http://localhost:3002\nMCP_LINKEDIN_URL=http://localhost:3003\nMCP_MEETUP_URL=http://localhost:3004\n\n# Application Configuration\nNEXT_PUBLIC_APP_URL=http://localhost:3000\n</code></pre>"},{"location":"#architecture-overview","title":"\ud83c\udfd7\ufe0f Architecture Overview","text":""},{"location":"#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph \"Client Layer\"\n        A[Web Browser] --&gt; B[Next.js Application]\n    end\n\n    subgraph \"Application Layer\"\n        B --&gt; C[AI Chat Component]\n        B --&gt; D[Map Component]\n        B --&gt; E[Event Discovery]\n\n        C --&gt; F[Vercel AI SDK]\n        D --&gt; G[Mapbox GL]\n        E --&gt; H[Event Management]\n    end\n\n    subgraph \"AI &amp; Processing Layer\"\n        F --&gt; I[OpenAI API]\n        F --&gt; J[Natural Language Processing]\n        H --&gt; K[Event Aggregation]\n        K --&gt; L[Data Processing]\n    end\n\n    subgraph \"Data Sources Layer\"\n        M[MCP Servers] --&gt; N[Eventbrite MCP]\n        M --&gt; O[Instagram MCP]\n        M --&gt; P[LinkedIn MCP]\n        M --&gt; Q[Meetup MCP]\n\n        L --&gt; M\n    end\n\n    subgraph \"Storage Layer\"\n        R[MongoDB] --&gt; S[Events Collection]\n        R --&gt; T[Users Collection]\n        R --&gt; U[Sessions Collection]\n\n        L --&gt; R\n        H --&gt; R\n    end\n\n    subgraph \"External APIs\"\n        V[Eventbrite API]\n        W[Instagram API]\n        X[LinkedIn API]\n        Y[Meetup API]\n        Z[Mapbox API]\n\n        N --&gt; V\n        O --&gt; W\n        P --&gt; X\n        Q --&gt; Y\n        G --&gt; Z\n    end\n\n    style B fill:#e3f2fd\n    style F fill:#e8f5e8\n    style M fill:#fff3e0\n    style R fill:#f3e5f5</code></pre>"},{"location":"#ai-powered-interaction-flow","title":"AI-Powered Interaction Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Chat as AI Chat Interface\n    participant AI as Vercel AI SDK\n    participant OpenAI as OpenAI API\n    participant MCP as MCP Servers\n    participant DB as MongoDB\n    participant Map as Map Component\n\n    User-&gt;&gt;Chat: \"Find tech events in San Francisco\"\n    Chat-&gt;&gt;AI: Process natural language query\n    AI-&gt;&gt;OpenAI: Generate structured search parameters\n    OpenAI--&gt;&gt;AI: Return search criteria\n    AI-&gt;&gt;MCP: Request events with criteria\n\n    par Eventbrite Search\n        MCP-&gt;&gt;Eventbrite: Search tech events in SF\n        Eventbrite--&gt;&gt;MCP: Return event data\n    and Instagram Search\n        MCP-&gt;&gt;Instagram: Search tech events in SF\n        Instagram--&gt;&gt;MCP: Return event data\n    and LinkedIn Search\n        MCP-&gt;&gt;LinkedIn: Search tech events in SF\n        LinkedIn--&gt;&gt;MCP: Return event data\n    end\n\n    MCP-&gt;&gt;DB: Store/update events\n    MCP--&gt;&gt;AI: Return aggregated results\n    AI-&gt;&gt;Chat: Format response\n    Chat--&gt;&gt;User: Display events &amp; update map\n    Chat-&gt;&gt;Map: Update markers with new events\n    Map--&gt;&gt;User: Show events on interactive map</code></pre>"},{"location":"#development-workflow","title":"\ufffd Development Workflow","text":""},{"location":"#component-development","title":"Component Development","text":"<ol> <li>Create React Components in <code>frontend/components/</code></li> <li>Implement AI Features using Vercel AI SDK</li> <li>Add Map Functionality with Mapbox integration</li> <li>Connect MCP Services for data sources</li> </ol>"},{"location":"#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit Tests: Component testing with Jest/React Testing Library</li> <li>Integration Tests: AI SDK and MCP integration testing</li> <li>E2E Tests: Full user journey testing</li> <li>Performance Tests: Map rendering and AI response optimization</li> </ul>"},{"location":"#deployment-process","title":"Deployment Process","text":"<ol> <li>Build Optimization: Next.js production build with Turbopack</li> <li>Environment Configuration: Production environment variables</li> <li>Database Migration: MongoDB schema updates</li> <li>MCP Server Deployment: Deploy and configure MCP servers</li> <li>CDN Deployment: Static asset optimization</li> </ol>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":"<p>This documentation is organized into several key sections:</p>"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>Detailed system architecture, AI integration patterns, and MCP framework implementation.</p>"},{"location":"#components","title":"\ud83e\udde9 Components","text":"<p>In-depth documentation of React components, AI chat interface, and interactive mapping.</p>"},{"location":"#ai-ml","title":"\ud83e\udd16 AI &amp; ML","text":"<p>AI SDK integration, OpenAI configuration, and natural language processing implementation.</p>"},{"location":"#mcp-servers","title":"\ud83d\udd17 MCP Servers","text":"<p>Model Context Protocol server implementations for various event platforms.</p>"},{"location":"#frontend","title":"\ud83d\udcbb Frontend","text":"<p>Next.js setup, React components, styling, and frontend architecture.</p>"},{"location":"#setup-deployment","title":"\ud83d\udee0\ufe0f Setup &amp; Deployment","text":"<p>Installation guides, configuration, and deployment instructions.</p>"},{"location":"#api-reference","title":"\ud83d\udcd6 API Reference","text":"<p>Complete API documentation for all endpoints and data models.</p>"},{"location":"#development","title":"\ud83d\udc68\u200d\ud83d\udcbb Development","text":"<p>Developer guides, contributing guidelines, and testing strategies.</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions to Inttrest! Please read our Contributing Guide to get started.</p>"},{"location":"#quick-contribution-steps","title":"Quick Contribution Steps","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/amazing-feature</code></li> <li>Make your changes and add tests</li> <li>Commit your changes: <code>git commit -m 'Add amazing feature'</code></li> <li>Push to the branch: <code>git push origin feature/amazing-feature</code></li> <li>Open a Pull Request</li> </ol>"},{"location":"#license","title":"\ufffd License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Repository: github.com/FilippTrigub/inttrest</li> <li>Issues: Report bugs and request features</li> <li>Discussions: Community discussions</li> <li>Wiki: Additional documentation</li> </ul>"},{"location":"#support","title":"\ud83c\udd98 Support","text":"<p>Need help? Here are the best ways to get support:</p> <ol> <li>Documentation: Start with this comprehensive documentation</li> <li>Issues: Create an issue for bugs or feature requests</li> <li>Discussions: Join the discussion for questions and ideas</li> <li>Email: Contact the maintainers directly</li> </ol> <p>Ready to discover events with AI? Start with our Getting Started Guide or dive into the Architecture Overview! \ud83d\ude80</p>"},{"location":"ai/vercel_ai_sdk/","title":"Vercel AI SDK Integration","text":"<p>This document provides comprehensive documentation for the Vercel AI SDK integration in the Inttrest platform, covering implementation details, configuration, and best practices.</p>"},{"location":"ai/vercel_ai_sdk/#overview","title":"\ud83e\udd16 Overview","text":"<p>The Vercel AI SDK is the core AI framework powering Inttrest's intelligent event discovery capabilities. It provides a seamless way to integrate AI-powered features including natural language processing, intelligent search, and conversational interfaces.</p> <pre><code>graph TB\n    subgraph \"AI SDK Architecture\"\n        A[Vercel AI SDK Core] --&gt; B[React Hooks]\n        A --&gt; C[OpenAI Provider]\n        A --&gt; D[Stream Processing]\n\n        B --&gt; E[useChat Hook]\n        B --&gt; F[useCompletion Hook]\n        B --&gt; G[useAssistant Hook]\n\n        C --&gt; H[GPT Models]\n        C --&gt; I[Function Calling]\n        C --&gt; J[Structured Output]\n\n        D --&gt; K[Real-time Streaming]\n        D --&gt; L[Message Processing]\n        D --&gt; M[State Management]\n    end\n\n    subgraph \"Application Integration\"\n        N[Chat Interface] --&gt; E\n        O[Event Search] --&gt; F\n        P[AI Assistant] --&gt; G\n\n        Q[Event Discovery] --&gt; I\n        R[Location Processing] --&gt; J\n        S[User Interaction] --&gt; K\n    end\n\n    style A fill:#e3f2fd\n    style N fill:#e8f5e8\n    style Q fill:#fff3e0</code></pre>"},{"location":"ai/vercel_ai_sdk/#dependencies","title":"\ud83d\udce6 Dependencies","text":"<p>The AI SDK integration uses the following key packages:</p> <pre><code>{\n  \"dependencies\": {\n    \"ai\": \"^5.0.28\",\n    \"@ai-sdk/openai\": \"^2.0.23\",\n    \"@ai-sdk/react\": \"^2.0.28\",\n    \"zod\": \"^4.1.5\"\n  }\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#package-details","title":"Package Details","text":"Package Version Purpose <code>ai</code> ^5.0.28 Core AI SDK with utilities and providers <code>@ai-sdk/openai</code> ^2.0.23 OpenAI provider for the AI SDK <code>@ai-sdk/react</code> ^2.0.28 React hooks and components <code>zod</code> ^4.1.5 Schema validation for structured outputs"},{"location":"ai/vercel_ai_sdk/#core-implementation","title":"\ud83d\udee0\ufe0f Core Implementation","text":""},{"location":"ai/vercel_ai_sdk/#ai-provider-configuration","title":"AI Provider Configuration","text":"<pre><code>// lib/ai-config.ts\nimport { openai } from '@ai-sdk/openai'\nimport { experimental_wrapLanguageModel as wrapLanguageModel } from 'ai'\n\n// Configure OpenAI provider\nexport const aiModel = wrapLanguageModel({\n  model: openai('gpt-4-turbo-preview'),\n  middleware: {\n    transformParams: async ({ params }) =&gt; {\n      return {\n        ...params,\n        temperature: 0.7,\n        max_tokens: 1000,\n        top_p: 0.9,\n      }\n    }\n  }\n})\n\n// Event discovery specific model\nexport const eventDiscoveryModel = openai('gpt-4-turbo-preview', {\n  structuredOutputs: true,\n})\n\n// Configuration constants\nexport const AI_CONFIG = {\n  models: {\n    chat: 'gpt-4-turbo-preview',\n    completion: 'gpt-3.5-turbo',\n    embedding: 'text-embedding-3-small'\n  },\n  limits: {\n    maxTokens: 1000,\n    temperature: 0.7,\n    topP: 0.9\n  },\n  features: {\n    streaming: true,\n    functionCalling: true,\n    structuredOutput: true\n  }\n} as const\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#chat-api-implementation","title":"Chat API Implementation","text":"<pre><code>// app/api/chat/route.ts\nimport { streamText, convertToCoreMessages } from 'ai'\nimport { aiModel } from '@/lib/ai-config'\nimport { z } from 'zod'\n\n// Define schemas for structured outputs\nconst EventSearchSchema = z.object({\n  location: z.string().optional(),\n  category: z.string().optional(),\n  dateRange: z.object({\n    start: z.string().optional(),\n    end: z.string().optional()\n  }).optional(),\n  keywords: z.array(z.string()).optional()\n})\n\nconst EventActionSchema = z.object({\n  action: z.enum(['search', 'filter', 'recommend', 'details']),\n  parameters: EventSearchSchema\n})\n\nexport async function POST(req: Request) {\n  try {\n    const { messages } = await req.json()\n\n    const result = await streamText({\n      model: aiModel,\n      messages: convertToCoreMessages(messages),\n      system: `You are an intelligent event discovery assistant for Inttrest. \n\nYour role is to help users find and discover events based on their preferences. You can:\n1. Search for events by location, category, date, or keywords\n2. Provide personalized recommendations\n3. Filter and sort events based on user criteria\n4. Explain event details and help with planning\n\nWhen users ask about events, try to understand their intent and provide helpful, actionable responses. \nIf you need to perform an action like searching or filtering events, use the available tools.\n\nCurrent capabilities:\n- Search events across multiple platforms (Eventbrite, Meetup, LinkedIn, Instagram)\n- Filter by location, category, date range, and other criteria\n- Provide intelligent recommendations based on user preferences\n- Help with event planning and discovery\n\nBe conversational, helpful, and proactive in suggesting relevant events.`,\n\n      tools: {\n        searchEvents: {\n          description: 'Search for events based on user criteria',\n          parameters: EventSearchSchema,\n          execute: async (params) =&gt; {\n            // Implementation for event search\n            return await searchEventsWithCriteria(params)\n          }\n        },\n\n        filterEvents: {\n          description: 'Filter existing events based on criteria',\n          parameters: EventSearchSchema,\n          execute: async (params) =&gt; {\n            // Implementation for event filtering\n            return await filterEventsWithCriteria(params)\n          }\n        },\n\n        getEventRecommendations: {\n          description: 'Get personalized event recommendations',\n          parameters: z.object({\n            userPreferences: z.array(z.string()),\n            location: z.string().optional()\n          }),\n          execute: async (params) =&gt; {\n            // Implementation for recommendations\n            return await getPersonalizedRecommendations(params)\n          }\n        }\n      },\n\n      maxTokens: 1000,\n      temperature: 0.7,\n    })\n\n    return result.toAIStreamResponse()\n  } catch (error) {\n    console.error('Chat API error:', error)\n    return new Response('Internal Server Error', { status: 500 })\n  }\n}\n\n// Helper functions for tool execution\nasync function searchEventsWithCriteria(params: z.infer&lt;typeof EventSearchSchema&gt;) {\n  // Connect to MCP servers and search for events\n  const searchResults = await fetch('/api/events/search', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(params)\n  })\n\n  return await searchResults.json()\n}\n\nasync function filterEventsWithCriteria(params: z.infer&lt;typeof EventSearchSchema&gt;) {\n  // Filter events from current dataset\n  const filterResults = await fetch('/api/events/filter', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(params)\n  })\n\n  return await filterResults.json()\n}\n\nasync function getPersonalizedRecommendations(params: any) {\n  // Get AI-powered recommendations\n  const recommendations = await fetch('/api/events/recommendations', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(params)\n  })\n\n  return await recommendations.json()\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#react-integration-with-usechat-hook","title":"React Integration with useChat Hook","text":"<pre><code>// components/Chat.tsx\n'use client'\n\nimport { useChat } from 'ai/react'\nimport { useState, useRef, useEffect } from 'react'\nimport { Send, Bot, User, Loader2 } from 'lucide-react'\n\ninterface ChatProps {\n  onEventAction?: (action: string, params: any) =&gt; void\n}\n\nexport default function Chat({ onEventAction }: ChatProps) {\n  const {\n    messages,\n    input,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    error,\n    append,\n    reload,\n    stop\n  } = useChat({\n    api: '/api/chat',\n    onFinish: (message) =&gt; {\n      // Handle completion of AI response\n      handleAIResponse(message)\n    },\n    onError: (error) =&gt; {\n      console.error('Chat error:', error)\n    }\n  })\n\n  const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null)\n  const [suggestions] = useState([\n    \"Find tech events in San Francisco this week\",\n    \"Show me networking events near me\",\n    \"What business conferences are happening in New York?\",\n    \"Find free events this weekend\",\n    \"Recommend events based on my interests\"\n  ])\n\n  const scrollToBottom = () =&gt; {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n  }\n\n  useEffect(() =&gt; {\n    scrollToBottom()\n  }, [messages])\n\n  const handleAIResponse = (message: any) =&gt; {\n    // Parse AI response for actions\n    if (message.toolInvocations) {\n      message.toolInvocations.forEach((invocation: any) =&gt; {\n        switch (invocation.toolName) {\n          case 'searchEvents':\n            onEventAction?.('search', invocation.args)\n            break\n          case 'filterEvents':\n            onEventAction?.('filter', invocation.args)\n            break\n          case 'getEventRecommendations':\n            onEventAction?.('recommend', invocation.args)\n            break\n        }\n      })\n    }\n  }\n\n  const handleSuggestionClick = (suggestion: string) =&gt; {\n    append({ role: 'user', content: suggestion })\n  }\n\n  return (\n    &lt;div className=\"flex flex-col h-full bg-white rounded-lg shadow-sm border\"&gt;\n      {/* Chat Header */}\n      &lt;div className=\"flex items-center justify-between p-4 border-b bg-blue-50\"&gt;\n        &lt;div className=\"flex items-center space-x-2\"&gt;\n          &lt;Bot className=\"w-6 h-6 text-blue-600\" /&gt;\n          &lt;div&gt;\n            &lt;h3 className=\"font-semibold text-gray-900\"&gt;AI Event Assistant&lt;/h3&gt;\n            &lt;p className=\"text-sm text-gray-600\"&gt;Discover events with AI&lt;/p&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        {isLoading &amp;&amp; (\n          &lt;button\n            onClick={stop}\n            className=\"p-2 text-gray-500 hover:text-red-500 transition-colors\"\n            title=\"Stop generation\"\n          &gt;\n            &lt;Loader2 className=\"w-4 h-4 animate-spin\" /&gt;\n          &lt;/button&gt;\n        )}\n      &lt;/div&gt;\n\n      {/* Messages Container */}\n      &lt;div className=\"flex-1 overflow-y-auto p-4 space-y-4\"&gt;\n        {messages.length === 0 &amp;&amp; (\n          &lt;div className=\"text-center py-8\"&gt;\n            &lt;Bot className=\"w-12 h-12 text-blue-400 mx-auto mb-4\" /&gt;\n            &lt;h4 className=\"text-lg font-medium text-gray-900 mb-2\"&gt;\n              Welcome to AI Event Discovery\n            &lt;/h4&gt;\n            &lt;p className=\"text-gray-600 mb-6\"&gt;\n              Ask me anything about events! I can help you find, filter, and discover events based on your preferences.\n            &lt;/p&gt;\n\n            {/* Suggestion Pills */}\n            &lt;div className=\"flex flex-wrap gap-2 justify-center\"&gt;\n              {suggestions.map((suggestion, index) =&gt; (\n                &lt;button\n                  key={index}\n                  onClick={() =&gt; handleSuggestionClick(suggestion)}\n                  className=\"px-3 py-1 text-sm bg-blue-100 text-blue-700 rounded-full hover:bg-blue-200 transition-colors\"\n                &gt;\n                  {suggestion}\n                &lt;/button&gt;\n              ))}\n            &lt;/div&gt;\n          &lt;/div&gt;\n        )}\n\n        {messages.map((message) =&gt; (\n          &lt;div\n            key={message.id}\n            className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}\n          &gt;\n            &lt;div\n              className={`max-w-xs lg:max-w-md px-4 py-3 rounded-lg ${\n                message.role === 'user'\n                  ? 'bg-blue-600 text-white'\n                  : 'bg-gray-100 text-gray-900'\n              }`}\n            &gt;\n              &lt;div className=\"flex items-center space-x-2 mb-1\"&gt;\n                {message.role === 'user' ? (\n                  &lt;User className=\"w-4 h-4\" /&gt;\n                ) : (\n                  &lt;Bot className=\"w-4 h-4\" /&gt;\n                )}\n                &lt;span className=\"text-sm font-medium\"&gt;\n                  {message.role === 'user' ? 'You' : 'AI Assistant'}\n                &lt;/span&gt;\n              &lt;/div&gt;\n\n              &lt;div className=\"text-sm whitespace-pre-wrap\"&gt;\n                {message.content}\n              &lt;/div&gt;\n\n              {/* Display tool invocations */}\n              {message.toolInvocations &amp;&amp; (\n                &lt;div className=\"mt-2 space-y-1\"&gt;\n                  {message.toolInvocations.map((invocation: any, index: number) =&gt; (\n                    &lt;div key={index} className=\"text-xs opacity-75\"&gt;\n                      \ud83d\udd27 {invocation.toolName}: {JSON.stringify(invocation.args)}\n                    &lt;/div&gt;\n                  ))}\n                &lt;/div&gt;\n              )}\n            &lt;/div&gt;\n          &lt;/div&gt;\n        ))}\n\n        {error &amp;&amp; (\n          &lt;div className=\"flex justify-center\"&gt;\n            &lt;div className=\"bg-red-100 border border-red-300 text-red-700 px-4 py-2 rounded-lg\"&gt;\n              &lt;p className=\"text-sm\"&gt;Error: {error.message}&lt;/p&gt;\n              &lt;button\n                onClick={reload}\n                className=\"text-red-600 hover:text-red-800 text-sm underline mt-1\"\n              &gt;\n                Try again\n              &lt;/button&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        )}\n\n        &lt;div ref={messagesEndRef} /&gt;\n      &lt;/div&gt;\n\n      {/* Input Form */}\n      &lt;div className=\"border-t p-4\"&gt;\n        &lt;form onSubmit={handleSubmit} className=\"flex space-x-3\"&gt;\n          &lt;input\n            value={input}\n            onChange={handleInputChange}\n            placeholder=\"Ask about events...\"\n            disabled={isLoading}\n            className=\"flex-1 border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:bg-gray-100\"\n          /&gt;\n          &lt;button\n            type=\"submit\"\n            disabled={!input.trim() || isLoading}\n            className=\"bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors\"\n          &gt;\n            {isLoading ? (\n              &lt;Loader2 className=\"w-5 h-5 animate-spin\" /&gt;\n            ) : (\n              &lt;Send className=\"w-5 h-5\" /&gt;\n            )}\n          &lt;/button&gt;\n        &lt;/form&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#ai-powered-features","title":"\ud83e\udde0 AI-Powered Features","text":""},{"location":"ai/vercel_ai_sdk/#intelligent-event-search","title":"Intelligent Event Search","text":"<p>The AI SDK enables natural language event search with intelligent parameter extraction:</p> <pre><code>// lib/ai-search.ts\nimport { generateObject } from 'ai'\nimport { eventDiscoveryModel } from './ai-config'\nimport { z } from 'zod'\n\nconst SearchParametersSchema = z.object({\n  location: z.string().optional().describe('Geographic location for events'),\n  category: z.string().optional().describe('Event category (tech, business, networking, etc.)'),\n  dateRange: z.object({\n    start: z.string().optional().describe('Start date in ISO format'),\n    end: z.string().optional().describe('End date in ISO format')\n  }).optional(),\n  keywords: z.array(z.string()).optional().describe('Keywords to search for'),\n  priceRange: z.object({\n    min: z.number().optional(),\n    max: z.number().optional()\n  }).optional(),\n  eventType: z.enum(['online', 'in-person', 'hybrid']).optional(),\n  interests: z.array(z.string()).optional().describe('User interests and preferences')\n})\n\nexport async function parseSearchQuery(query: string): Promise&lt;z.infer&lt;typeof SearchParametersSchema&gt;&gt; {\n  const { object } = await generateObject({\n    model: eventDiscoveryModel,\n    schema: SearchParametersSchema,\n    prompt: `Parse this natural language event search query and extract relevant parameters: \"${query}\"\n\n    Examples:\n    - \"tech events in San Francisco this week\" \u2192 location: \"San Francisco\", category: \"tech\", dateRange with this week\n    - \"free networking events near me\" \u2192 category: \"networking\", priceRange: {max: 0}, location: user location\n    - \"business conferences in New York next month\" \u2192 category: \"business\", location: \"New York\", dateRange: next month\n\n    Be smart about interpreting relative dates, informal location names, and implied preferences.`\n  })\n\n  return object\n}\n\nexport async function generateEventRecommendations(userProfile: any, events: any[]) {\n  const RecommendationSchema = z.object({\n    recommendations: z.array(z.object({\n      eventId: z.string(),\n      score: z.number().min(0).max(1),\n      reasons: z.array(z.string()),\n      category: z.string()\n    })),\n    insights: z.array(z.string()).describe('Insights about user preferences')\n  })\n\n  const { object } = await generateObject({\n    model: eventDiscoveryModel,\n    schema: RecommendationSchema,\n    prompt: `Based on this user profile and available events, generate personalized recommendations:\n\n    User Profile: ${JSON.stringify(userProfile)}\n    Available Events: ${JSON.stringify(events.slice(0, 20))} // Limit for context\n\n    Provide a score (0-1) for each recommended event and explain why it matches the user's interests.\n    Consider factors like location preferences, past event attendance, interests, and career goals.`\n  })\n\n  return object\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#structured-event-data-processing","title":"Structured Event Data Processing","text":"<pre><code>// lib/ai-processing.ts\nimport { generateObject } from 'ai'\nimport { eventDiscoveryModel } from './ai-config'\nimport { z } from 'zod'\n\nconst EventEnrichmentSchema = z.object({\n  enhancedDescription: z.string().describe('AI-enhanced event description'),\n  tags: z.array(z.string()).describe('Relevant tags for the event'),\n  targetAudience: z.array(z.string()).describe('Target audience segments'),\n  skillLevel: z.enum(['beginner', 'intermediate', 'advanced', 'all']).describe('Required skill level'),\n  networking: z.boolean().describe('Whether this is primarily a networking event'),\n  learningOutcomes: z.array(z.string()).describe('What attendees will learn'),\n  industry: z.array(z.string()).describe('Relevant industries'),\n  format: z.enum(['workshop', 'conference', 'meetup', 'webinar', 'hackathon', 'panel', 'other']),\n  sentiment: z.object({\n    excitement: z.number().min(0).max(1),\n    professionalism: z.number().min(0).max(1),\n    accessibility: z.number().min(0).max(1)\n  })\n})\n\nexport async function enrichEventData(eventData: any) {\n  const { object } = await generateObject({\n    model: eventDiscoveryModel,\n    schema: EventEnrichmentSchema,\n    prompt: `Analyze this event and provide enriched metadata:\n\n    Event Data: ${JSON.stringify(eventData)}\n\n    Provide structured insights that will help users understand what this event offers,\n    who should attend, and what they can expect to gain from it.`\n  })\n\n  return object\n}\n\nexport async function categorizeEvent(eventData: any) {\n  const CategorySchema = z.object({\n    primaryCategory: z.enum([\n      'technology', 'business', 'networking', 'education', 'entertainment',\n      'sports', 'health', 'arts', 'food', 'travel', 'other'\n    ]),\n    secondaryCategories: z.array(z.string()),\n    confidence: z.number().min(0).max(1),\n    reasoning: z.string()\n  })\n\n  const { object } = await generateObject({\n    model: eventDiscoveryModel,\n    schema: CategorySchema,\n    prompt: `Categorize this event based on its content and context:\n\n    Event: ${JSON.stringify(eventData)}\n\n    Determine the most appropriate primary category and any relevant secondary categories.\n    Provide a confidence score and explain your reasoning.`\n  })\n\n  return object\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#performance-optimization","title":"\u26a1 Performance Optimization","text":""},{"location":"ai/vercel_ai_sdk/#streaming-responses","title":"Streaming Responses","text":"<p>The AI SDK provides built-in streaming capabilities for better user experience:</p> <pre><code>// components/StreamingChat.tsx\nimport { useChat } from 'ai/react'\nimport { useEffect, useState } from 'react'\n\nexport function StreamingChat() {\n  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({\n    api: '/api/chat',\n    streamMode: 'stream-data', // Enable streaming\n    onFinish: (message, { usage, finishReason }) =&gt; {\n      console.log('Completion finished:', { usage, finishReason })\n    }\n  })\n\n  return (\n    &lt;div className=\"chat-container\"&gt;\n      {messages.map((message) =&gt; (\n        &lt;div key={message.id} className={`message ${message.role}`}&gt;\n          {/* Render streaming content as it arrives */}\n          &lt;div className=\"content\"&gt;\n            {message.content}\n          &lt;/div&gt;\n\n          {/* Show typing indicator for assistant messages being streamed */}\n          {message.role === 'assistant' &amp;&amp; isLoading &amp;&amp; (\n            &lt;div className=\"typing-indicator\"&gt;\n              &lt;span className=\"dot\"&gt;&lt;/span&gt;\n              &lt;span className=\"dot\"&gt;&lt;/span&gt;\n              &lt;span className=\"dot\"&gt;&lt;/span&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n      ))}\n\n      &lt;form onSubmit={handleSubmit}&gt;\n        &lt;input\n          value={input}\n          onChange={handleInputChange}\n          placeholder=\"Type your message...\"\n          disabled={isLoading}\n        /&gt;\n        &lt;button type=\"submit\" disabled={isLoading}&gt;\n          Send\n        &lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#caching-and-rate-limiting","title":"Caching and Rate Limiting","text":"<pre><code>// lib/ai-cache.ts\nimport { LRUCache } from 'lru-cache'\n\ninterface CacheEntry {\n  result: any\n  timestamp: number\n  ttl: number\n}\n\nclass AICache {\n  private cache: LRUCache&lt;string, CacheEntry&gt;\n\n  constructor(maxSize = 1000, defaultTTL = 1000 * 60 * 15) { // 15 minutes\n    this.cache = new LRUCache({\n      max: maxSize,\n      ttl: defaultTTL\n    })\n  }\n\n  generateKey(input: any): string {\n    return JSON.stringify(input)\n  }\n\n  get(key: string): any | null {\n    const entry = this.cache.get(key)\n    if (!entry) return null\n\n    const now = Date.now()\n    if (now - entry.timestamp &gt; entry.ttl) {\n      this.cache.delete(key)\n      return null\n    }\n\n    return entry.result\n  }\n\n  set(key: string, result: any, ttl?: number): void {\n    this.cache.set(key, {\n      result,\n      timestamp: Date.now(),\n      ttl: ttl || 1000 * 60 * 15\n    })\n  }\n\n  async getOrCompute&lt;T&gt;(\n    key: string,\n    computeFn: () =&gt; Promise&lt;T&gt;,\n    ttl?: number\n  ): Promise&lt;T&gt; {\n    const cached = this.get(key)\n    if (cached) return cached\n\n    const result = await computeFn()\n    this.set(key, result, ttl)\n    return result\n  }\n}\n\nexport const aiCache = new AICache()\n\n// Usage in API routes\nexport async function cachedGenerateObject(params: any) {\n  const cacheKey = aiCache.generateKey(params)\n\n  return await aiCache.getOrCompute(\n    cacheKey,\n    () =&gt; generateObject(params),\n    1000 * 60 * 30 // 30 minutes for AI generation\n  )\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#configuration-environment","title":"\ud83d\udd27 Configuration &amp; Environment","text":""},{"location":"ai/vercel_ai_sdk/#environment-variables","title":"Environment Variables","text":"<pre><code># .env.local\nOPENAI_API_KEY=sk-your-openai-api-key-here\nAI_SDK_LOG_LEVEL=info\nAI_CACHE_TTL=900000\nAI_MAX_TOKENS=1000\nAI_TEMPERATURE=0.7\nAI_MODEL_CHAT=gpt-4-turbo-preview\nAI_MODEL_COMPLETION=gpt-3.5-turbo\nAI_MODEL_EMBEDDING=text-embedding-3-small\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#runtime-configuration","title":"Runtime Configuration","text":"<pre><code>// lib/config.ts\nexport const aiConfig = {\n  openai: {\n    apiKey: process.env.OPENAI_API_KEY!,\n    baseURL: process.env.OPENAI_BASE_URL,\n    organization: process.env.OPENAI_ORG_ID,\n  },\n\n  models: {\n    chat: process.env.AI_MODEL_CHAT || 'gpt-4-turbo-preview',\n    completion: process.env.AI_MODEL_COMPLETION || 'gpt-3.5-turbo',\n    embedding: process.env.AI_MODEL_EMBEDDING || 'text-embedding-3-small',\n  },\n\n  limits: {\n    maxTokens: parseInt(process.env.AI_MAX_TOKENS || '1000'),\n    temperature: parseFloat(process.env.AI_TEMPERATURE || '0.7'),\n    topP: parseFloat(process.env.AI_TOP_P || '0.9'),\n  },\n\n  cache: {\n    ttl: parseInt(process.env.AI_CACHE_TTL || '900000'), // 15 minutes\n    maxSize: parseInt(process.env.AI_CACHE_MAX_SIZE || '1000'),\n  },\n\n  features: {\n    streaming: process.env.AI_STREAMING !== 'false',\n    functionCalling: process.env.AI_FUNCTION_CALLING !== 'false',\n    structuredOutput: process.env.AI_STRUCTURED_OUTPUT !== 'false',\n  }\n} as const\n\n// Validation\nif (!aiConfig.openai.apiKey) {\n  throw new Error('OPENAI_API_KEY environment variable is required')\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#testing-ai-features","title":"\ud83e\uddea Testing AI Features","text":""},{"location":"ai/vercel_ai_sdk/#unit-testing","title":"Unit Testing","text":"<pre><code>// __tests__/ai/search.test.ts\nimport { parseSearchQuery, generateEventRecommendations } from '@/lib/ai-search'\nimport { describe, it, expect, vi } from 'vitest'\n\ndescribe('AI Search Functions', () =&gt; {\n  it('should parse natural language search queries', async () =&gt; {\n    const query = \"tech events in San Francisco this week\"\n    const result = await parseSearchQuery(query)\n\n    expect(result.location).toBe(\"San Francisco\")\n    expect(result.category).toBe(\"tech\")\n    expect(result.dateRange).toBeDefined()\n  })\n\n  it('should generate relevant event recommendations', async () =&gt; {\n    const userProfile = {\n      interests: ['technology', 'AI', 'startups'],\n      location: 'San Francisco',\n      experience: 'senior'\n    }\n\n    const events = [\n      { id: '1', title: 'AI Conference 2024', category: 'tech' },\n      { id: '2', title: 'Cooking Class', category: 'food' }\n    ]\n\n    const recommendations = await generateEventRecommendations(userProfile, events)\n\n    expect(recommendations.recommendations).toHaveLength(2)\n    expect(recommendations.recommendations[0].score).toBeGreaterThan(\n      recommendations.recommendations[1].score\n    )\n  })\n})\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#integration-testing","title":"Integration Testing","text":"<pre><code>// __tests__/api/chat.test.ts\nimport { POST } from '@/app/api/chat/route'\nimport { NextRequest } from 'next/server'\n\ndescribe('/api/chat', () =&gt; {\n  it('should handle event search requests', async () =&gt; {\n    const request = new NextRequest('http://localhost:3000/api/chat', {\n      method: 'POST',\n      body: JSON.stringify({\n        messages: [\n          { role: 'user', content: 'Find tech events in San Francisco' }\n        ]\n      })\n    })\n\n    const response = await POST(request)\n\n    expect(response.status).toBe(200)\n    expect(response.headers.get('content-type')).toContain('text/plain')\n  })\n})\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#monitoring-analytics","title":"\ud83d\udcca Monitoring &amp; Analytics","text":""},{"location":"ai/vercel_ai_sdk/#usage-tracking","title":"Usage Tracking","text":"<pre><code>// lib/ai-analytics.ts\ninterface AIUsageMetrics {\n  requestCount: number\n  tokenUsage: {\n    prompt: number\n    completion: number\n    total: number\n  }\n  responseTime: number\n  cacheHitRate: number\n}\n\nclass AIAnalytics {\n  private metrics: Map&lt;string, AIUsageMetrics&gt; = new Map()\n\n  trackRequest(\n    endpoint: string,\n    tokenUsage: any,\n    responseTime: number,\n    cacheHit: boolean\n  ) {\n    const current = this.metrics.get(endpoint) || {\n      requestCount: 0,\n      tokenUsage: { prompt: 0, completion: 0, total: 0 },\n      responseTime: 0,\n      cacheHitRate: 0\n    }\n\n    current.requestCount++\n    current.tokenUsage.prompt += tokenUsage.promptTokens || 0\n    current.tokenUsage.completion += tokenUsage.completionTokens || 0\n    current.tokenUsage.total += tokenUsage.totalTokens || 0\n    current.responseTime = (current.responseTime + responseTime) / 2\n\n    if (cacheHit) {\n      current.cacheHitRate = (current.cacheHitRate + 1) / current.requestCount\n    }\n\n    this.metrics.set(endpoint, current)\n  }\n\n  getMetrics(endpoint?: string) {\n    if (endpoint) {\n      return this.metrics.get(endpoint)\n    }\n    return Object.fromEntries(this.metrics)\n  }\n\n  exportMetrics() {\n    return {\n      timestamp: new Date().toISOString(),\n      metrics: this.getMetrics()\n    }\n  }\n}\n\nexport const aiAnalytics = new AIAnalytics()\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#best-practices","title":"\ud83d\ude80 Best Practices","text":""},{"location":"ai/vercel_ai_sdk/#1-prompt-engineering","title":"1. Prompt Engineering","text":"<pre><code>// lib/prompts.ts\nexport const SYSTEM_PROMPTS = {\n  eventDiscovery: `You are an expert event discovery assistant with deep knowledge of:\n- Event platforms (Eventbrite, Meetup, LinkedIn Events, etc.)\n- Geographic locations and venues\n- Event categories and industry trends\n- User preferences and behavior patterns\n\nYour goal is to help users find the most relevant events based on their needs.\nAlways be helpful, accurate, and proactive in suggesting alternatives.`,\n\n  eventCategorization: `Analyze event content and categorize accurately.\nConsider the event title, description, venue, organizer, and other metadata.\nUse consistent categorization that helps users filter and discover events effectively.`,\n\n  eventRecommendation: `Provide personalized event recommendations based on:\n- User's expressed interests and preferences\n- Past event attendance (if available)\n- Geographic proximity and convenience\n- Event quality and relevance\n- Networking opportunities and career growth potential`\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// lib/ai-error-handling.ts\nexport class AIError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public originalError?: Error\n  ) {\n    super(message)\n    this.name = 'AIError'\n  }\n}\n\nexport async function withErrorHandling&lt;T&gt;(\n  operation: () =&gt; Promise&lt;T&gt;,\n  context: string\n): Promise&lt;T&gt; {\n  try {\n    return await operation()\n  } catch (error) {\n    if (error instanceof Error) {\n      // Log error for monitoring\n      console.error(`AI operation failed in ${context}:`, error)\n\n      // Categorize error type\n      if (error.message.includes('rate limit')) {\n        throw new AIError(\n          'AI service is temporarily unavailable due to rate limiting',\n          'RATE_LIMITED',\n          error\n        )\n      }\n\n      if (error.message.includes('timeout')) {\n        throw new AIError(\n          'AI service request timed out',\n          'TIMEOUT',\n          error\n        )\n      }\n\n      // Generic error\n      throw new AIError(\n        'AI service encountered an error',\n        'GENERAL_ERROR',\n        error\n      )\n    }\n\n    throw error\n  }\n}\n</code></pre>"},{"location":"ai/vercel_ai_sdk/#3-performance-optimization","title":"3. Performance Optimization","text":"<pre><code>// lib/ai-optimization.ts\nexport function optimizePrompt(prompt: string): string {\n  // Remove excessive whitespace\n  let optimized = prompt.replace(/\\s+/g, ' ').trim()\n\n  // Truncate if too long (keep under token limits)\n  const maxLength = 4000 // Approximately 1000 tokens\n  if (optimized.length &gt; maxLength) {\n    optimized = optimized.substring(0, maxLength) + '...'\n  }\n\n  return optimized\n}\n\nexport function batchRequests&lt;T&gt;(\n  items: T[],\n  batchSize: number = 5\n): T[][] {\n  const batches: T[][] = []\n  for (let i = 0; i &lt; items.length; i += batchSize) {\n    batches.push(items.slice(i, i + batchSize))\n  }\n  return batches\n}\n</code></pre> <p>This comprehensive documentation covers the Vercel AI SDK integration in Inttrest, providing developers with everything they need to understand, implement, and maintain the AI-powered features! \ud83e\udd16</p>"},{"location":"api/endpoints/","title":"API Reference","text":"<p>This document provides comprehensive API documentation for the Event Discovery application.</p>"},{"location":"api/endpoints/#overview","title":"\ud83d\udccb Overview","text":"<p>The Event Discovery API provides endpoints for managing events, geocoding locations, and integrating with external data sources through MCP (Model Context Protocol) servers.</p> <pre><code>graph TB\n    subgraph \"API Structure\"\n        A[FastAPI Application] --&gt; B[Event Routes]\n        A --&gt; C[Map Routes]\n        A --&gt; D[MCP Routes]\n\n        B --&gt; E[MongoDB Operations]\n        C --&gt; F[Geocoding Service]\n        D --&gt; G[External Scrapers]\n    end\n\n    subgraph \"Data Flow\"\n        H[Client Request] --&gt; A\n        A --&gt; I[Database]\n        A --&gt; J[External APIs]\n        A --&gt; K[Response]\n    end\n\n    style A fill:#e3f2fd\n    style I fill:#e8f5e8\n    style J fill:#fff3e0</code></pre>"},{"location":"api/endpoints/#base-configuration","title":"\ud83d\ude80 Base Configuration","text":""},{"location":"api/endpoints/#server-information","title":"Server Information","text":"<pre><code>Base URL: http://localhost:8000\nAPI Version: v1\nDocumentation: http://localhost:8000/docs\nAlternative Docs: http://localhost:8000/redoc\nHealth Check: http://localhost:8000/health\n</code></pre>"},{"location":"api/endpoints/#authentication","title":"Authentication","text":"<p>Currently, the API operates without authentication for development. For production deployment:</p> <pre><code># Future authentication header\nheaders = {\n    \"Authorization\": \"Bearer &lt;your-api-token&gt;\",\n    \"Content-Type\": \"application/json\"\n}\n</code></pre>"},{"location":"api/endpoints/#event-endpoints","title":"\ud83d\udccd Event Endpoints","text":""},{"location":"api/endpoints/#get-apiv1events","title":"GET /api/v1/events","text":"<p>Retrieve events from the database with optional filtering.</p> <p>Request Parameters:</p> Parameter Type Required Description <code>limit</code> integer No Maximum number of events to return (default: 100) <code>offset</code> integer No Number of events to skip (default: 0) <code>category</code> string No Filter by event category <code>location</code> string No Filter by location name <code>date_from</code> string No Filter events from date (ISO format) <code>date_to</code> string No Filter events until date (ISO format) <code>source</code> string No Filter by data source (eventbrite, meetup, etc.) <code>has_coordinates</code> boolean No Filter events with/without coordinates <p>Example Request: <pre><code>curl -X GET \"http://localhost:8000/api/v1/events?limit=50&amp;category=technology&amp;has_coordinates=true\" \\\n  -H \"Content-Type: application/json\"\n</code></pre></p> <p>Response: <pre><code>{\n  \"events\": [\n    {\n      \"id\": \"evt_001\",\n      \"title\": \"Tech Meetup Paris\",\n      \"description\": \"Monthly technology meetup in Paris\",\n      \"location\": \"15 rue de Milan, Paris\",\n      \"coordinates\": {\n        \"latitude\": 48.8786,\n        \"longitude\": 2.3273\n      },\n      \"date\": \"2024-02-15T18:00:00Z\",\n      \"category\": \"technology\",\n      \"source\": \"eventbrite\",\n      \"image_url\": \"https://example.com/event-image.jpg\",\n      \"url\": \"https://eventbrite.com/event/123\",\n      \"created_at\": \"2024-01-15T10:30:00Z\",\n      \"updated_at\": \"2024-01-15T10:30:00Z\"\n    }\n  ],\n  \"total\": 1,\n  \"limit\": 50,\n  \"offset\": 0,\n  \"has_more\": false\n}\n</code></pre></p> <p>Status Codes: - <code>200</code>: Success - <code>400</code>: Invalid parameters - <code>500</code>: Server error</p>"},{"location":"api/endpoints/#post-apiv1events","title":"POST /api/v1/events","text":"<p>Create a new event or bulk insert events.</p> <p>Request Body: <pre><code>{\n  \"events\": [\n    {\n      \"id\": \"custom_001\",\n      \"title\": \"New Event\",\n      \"description\": \"Event description\",\n      \"location\": \"Event location\",\n      \"date\": \"2024-02-20T19:00:00Z\",\n      \"category\": \"networking\",\n      \"source\": \"manual\",\n      \"url\": \"https://example.com/event\"\n    }\n  ],\n  \"auto_geocode\": true\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"message\": \"Events created successfully\",\n  \"inserted_count\": 1,\n  \"geocoded_count\": 1,\n  \"events\": [\n    {\n      \"id\": \"custom_001\",\n      \"coordinates\": {\n        \"latitude\": 48.8566,\n        \"longitude\": 2.3522\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apiv1eventsevent_id","title":"GET /api/v1/events/{event_id}","text":"<p>Retrieve a specific event by ID.</p> <p>Example Request: <pre><code>curl -X GET \"http://localhost:8000/api/v1/events/evt_001\" \\\n  -H \"Content-Type: application/json\"\n</code></pre></p> <p>Response: <pre><code>{\n  \"id\": \"evt_001\",\n  \"title\": \"Tech Meetup Paris\",\n  \"description\": \"Monthly technology meetup in Paris\",\n  \"location\": \"15 rue de Milan, Paris\",\n  \"coordinates\": {\n    \"latitude\": 48.8786,\n    \"longitude\": 2.3273\n  },\n  \"date\": \"2024-02-15T18:00:00Z\",\n  \"category\": \"technology\",\n  \"source\": \"eventbrite\"\n}\n</code></pre></p>"},{"location":"api/endpoints/#put-apiv1eventsevent_id","title":"PUT /api/v1/events/{event_id}","text":"<p>Update an existing event.</p> <p>Request Body: <pre><code>{\n  \"title\": \"Updated Event Title\",\n  \"description\": \"Updated description\",\n  \"location\": \"New location\",\n  \"auto_geocode\": true\n}\n</code></pre></p>"},{"location":"api/endpoints/#delete-apiv1eventsevent_id","title":"DELETE /api/v1/events/{event_id}","text":"<p>Delete an event by ID.</p> <p>Response: <pre><code>{\n  \"message\": \"Event deleted successfully\",\n  \"deleted_id\": \"evt_001\"\n}\n</code></pre></p>"},{"location":"api/endpoints/#map-geocoding-endpoints","title":"\ud83d\uddfa\ufe0f Map &amp; Geocoding Endpoints","text":""},{"location":"api/endpoints/#post-apiv1geocode","title":"POST /api/v1/geocode","text":"<p>Convert addresses to coordinates.</p> <p>Request Body: <pre><code>{\n  \"addresses\": [\n    \"15 rue de Milan, Paris\",\n    \"Times Square, New York\",\n    \"Tower Bridge, London\"\n  ]\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"results\": [\n    {\n      \"address\": \"15 rue de Milan, Paris\",\n      \"coordinates\": {\n        \"latitude\": 48.8786,\n        \"longitude\": 2.3273\n      },\n      \"status\": \"success\"\n    },\n    {\n      \"address\": \"Times Square, New York\",\n      \"coordinates\": {\n        \"latitude\": 40.7580,\n        \"longitude\": -73.9855\n      },\n      \"status\": \"success\"\n    },\n    {\n      \"address\": \"Tower Bridge, London\",\n      \"coordinates\": null,\n      \"status\": \"failed\",\n      \"error\": \"Location not found\"\n    }\n  ],\n  \"success_count\": 2,\n  \"failed_count\": 1\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apiv1mapbounds","title":"GET /api/v1/map/bounds","text":"<p>Get bounding box coordinates for all events or filtered events.</p> <p>Request Parameters:</p> Parameter Type Required Description <code>category</code> string No Filter by category <code>source</code> string No Filter by source <code>padding</code> float No Add padding to bounds (default: 0.01) <p>Response: <pre><code>{\n  \"bounds\": {\n    \"north\": 48.9,\n    \"south\": 48.8,\n    \"east\": 2.4,\n    \"west\": 2.3\n  },\n  \"center\": {\n    \"latitude\": 48.85,\n    \"longitude\": 2.35\n  },\n  \"event_count\": 25\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apiv1mapclusters","title":"GET /api/v1/map/clusters","text":"<p>Get clustered event data for map visualization.</p> <p>Request Parameters:</p> Parameter Type Required Description <code>zoom_level</code> integer No Map zoom level (1-18, default: 10) <code>bounds</code> string No Bounding box (north,south,east,west) <p>Response: <pre><code>{\n  \"clusters\": [\n    {\n      \"coordinates\": {\n        \"latitude\": 48.8566,\n        \"longitude\": 2.3522\n      },\n      \"event_count\": 15,\n      \"events\": [\"evt_001\", \"evt_002\"],\n      \"category_breakdown\": {\n        \"technology\": 8,\n        \"business\": 4,\n        \"networking\": 3\n      }\n    }\n  ],\n  \"total_events\": 50\n}\n</code></pre></p>"},{"location":"api/endpoints/#mcp-model-context-protocol-endpoints","title":"\ud83d\udd17 MCP (Model Context Protocol) Endpoints","text":""},{"location":"api/endpoints/#get-apiv1mcpsources","title":"GET /api/v1/mcp/sources","text":"<p>List available MCP servers and their status.</p> <p>Response: <pre><code>{\n  \"sources\": [\n    {\n      \"name\": \"eventbrite\",\n      \"url\": \"http://localhost:3001\",\n      \"status\": \"active\",\n      \"last_sync\": \"2024-01-15T10:30:00Z\",\n      \"event_count\": 150\n    },\n    {\n      \"name\": \"meetup\",\n      \"url\": \"http://localhost:3002\",\n      \"status\": \"inactive\",\n      \"last_sync\": null,\n      \"event_count\": 0\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/endpoints/#post-apiv1mcpsync","title":"POST /api/v1/mcp/sync","text":"<p>Trigger synchronization with MCP servers.</p> <p>Request Body: <pre><code>{\n  \"sources\": [\"eventbrite\", \"meetup\"],\n  \"location\": \"Paris, France\",\n  \"category\": \"technology\",\n  \"date_range\": {\n    \"start\": \"2024-02-01\",\n    \"end\": \"2024-02-29\"\n  },\n  \"auto_geocode\": true\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"sync_id\": \"sync_001\",\n  \"status\": \"started\",\n  \"sources\": [\"eventbrite\", \"meetup\"],\n  \"estimated_completion\": \"2024-01-15T10:35:00Z\"\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apiv1mcpsyncsync_id","title":"GET /api/v1/mcp/sync/{sync_id}","text":"<p>Check the status of a synchronization job.</p> <p>Response: <pre><code>{\n  \"sync_id\": \"sync_001\",\n  \"status\": \"completed\",\n  \"started_at\": \"2024-01-15T10:30:00Z\",\n  \"completed_at\": \"2024-01-15T10:34:00Z\",\n  \"results\": {\n    \"eventbrite\": {\n      \"events_found\": 25,\n      \"events_saved\": 23,\n      \"events_updated\": 2,\n      \"errors\": 0\n    },\n    \"meetup\": {\n      \"events_found\": 18,\n      \"events_saved\": 18,\n      \"events_updated\": 0,\n      \"errors\": 0\n    }\n  },\n  \"total_events_processed\": 41,\n  \"geocoding_results\": {\n    \"successful\": 38,\n    \"failed\": 3\n  }\n}\n</code></pre></p>"},{"location":"api/endpoints/#analytics-endpoints","title":"\ud83d\udcca Analytics Endpoints","text":""},{"location":"api/endpoints/#get-apiv1analyticssummary","title":"GET /api/v1/analytics/summary","text":"<p>Get summary statistics for events.</p> <p>Response: <pre><code>{\n  \"total_events\": 500,\n  \"events_by_source\": {\n    \"eventbrite\": 200,\n    \"meetup\": 180,\n    \"manual\": 120\n  },\n  \"events_by_category\": {\n    \"technology\": 150,\n    \"business\": 120,\n    \"networking\": 100,\n    \"other\": 130\n  },\n  \"geographic_coverage\": {\n    \"cities\": 25,\n    \"countries\": 8,\n    \"geocoded_percentage\": 92.5\n  },\n  \"date_range\": {\n    \"earliest\": \"2024-01-01T00:00:00Z\",\n    \"latest\": \"2024-12-31T23:59:59Z\"\n  }\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apiv1analyticstrends","title":"GET /api/v1/analytics/trends","text":"<p>Get trending data for events.</p> <p>Request Parameters:</p> Parameter Type Required Description <code>period</code> string No Time period (daily, weekly, monthly) <code>metric</code> string No Metric to analyze (count, category, location) <p>Response: <pre><code>{\n  \"period\": \"weekly\",\n  \"metric\": \"count\",\n  \"data\": [\n    {\n      \"date\": \"2024-01-01\",\n      \"value\": 25\n    },\n    {\n      \"date\": \"2024-01-08\",\n      \"value\": 32\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/endpoints/#utility-endpoints","title":"\ud83d\udee0\ufe0f Utility Endpoints","text":""},{"location":"api/endpoints/#get-health","title":"GET /health","text":"<p>Health check endpoint.</p> <p>Response: <pre><code>{\n  \"status\": \"healthy\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"version\": \"1.0.0\",\n  \"services\": {\n    \"database\": \"connected\",\n    \"geocoding\": \"available\",\n    \"mcp_servers\": {\n      \"eventbrite\": \"active\",\n      \"meetup\": \"inactive\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"api/endpoints/#get-apiv1config","title":"GET /api/v1/config","text":"<p>Get current API configuration.</p> <p>Response: <pre><code>{\n  \"api_version\": \"1.0.0\",\n  \"database\": {\n    \"name\": \"events_db\",\n    \"collection\": \"events\"\n  },\n  \"geocoding\": {\n    \"provider\": \"nominatim\",\n    \"rate_limit\": \"1/second\",\n    \"cache_enabled\": true\n  },\n  \"mcp_servers\": [\n    {\n      \"name\": \"eventbrite\",\n      \"url\": \"http://localhost:3001\"\n    }\n  ]\n}\n</code></pre></p>"},{"location":"api/endpoints/#python-client-examples","title":"\ud83d\udc0d Python Client Examples","text":""},{"location":"api/endpoints/#basic-usage","title":"Basic Usage","text":"<pre><code>import requests\nimport json\n\nclass EventDiscoveryClient:\n    def __init__(self, base_url=\"http://localhost:8000\"):\n        self.base_url = base_url\n        self.session = requests.Session()\n\n    def get_events(self, **filters):\n        \"\"\"Get events with optional filters\"\"\"\n        response = self.session.get(\n            f\"{self.base_url}/api/v1/events\",\n            params=filters\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def create_event(self, event_data, auto_geocode=True):\n        \"\"\"Create a new event\"\"\"\n        payload = {\n            \"events\": [event_data],\n            \"auto_geocode\": auto_geocode\n        }\n\n        response = self.session.post(\n            f\"{self.base_url}/api/v1/events\",\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def geocode_addresses(self, addresses):\n        \"\"\"Geocode multiple addresses\"\"\"\n        payload = {\"addresses\": addresses}\n\n        response = self.session.post(\n            f\"{self.base_url}/api/v1/geocode\",\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n\n    def sync_with_mcp(self, sources, location=None, category=None):\n        \"\"\"Trigger MCP synchronization\"\"\"\n        payload = {\n            \"sources\": sources,\n            \"auto_geocode\": True\n        }\n\n        if location:\n            payload[\"location\"] = location\n        if category:\n            payload[\"category\"] = category\n\n        response = self.session.post(\n            f\"{self.base_url}/api/v1/mcp/sync\",\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n\n# Example usage\nclient = EventDiscoveryClient()\n\n# Get technology events in Paris\nevents = client.get_events(\n    category=\"technology\",\n    location=\"Paris\",\n    limit=20\n)\n\n# Create a new event\nnew_event = {\n    \"id\": \"custom_001\",\n    \"title\": \"Python Workshop\",\n    \"location\": \"Station F, Paris\",\n    \"date\": \"2024-02-20T14:00:00Z\",\n    \"category\": \"technology\"\n}\n\nresult = client.create_event(new_event)\nprint(f\"Created event: {result}\")\n\n# Geocode addresses\naddresses = [\"15 rue de Milan, Paris\", \"Times Square, NYC\"]\ncoords = client.geocode_addresses(addresses)\nprint(f\"Geocoding results: {coords}\")\n\n# Sync with Eventbrite\nsync_result = client.sync_with_mcp(\n    sources=[\"eventbrite\"],\n    location=\"Paris, France\",\n    category=\"technology\"\n)\nprint(f\"Sync started: {sync_result}\")\n</code></pre>"},{"location":"api/endpoints/#advanced-examples","title":"Advanced Examples","text":"<pre><code># Bulk event processing\nclass BulkEventProcessor:\n    def __init__(self, client):\n        self.client = client\n\n    def process_csv_events(self, csv_file_path):\n        \"\"\"Process events from CSV file\"\"\"\n        import csv\n\n        events = []\n        with open(csv_file_path, 'r') as file:\n            reader = csv.DictReader(file)\n            for row in reader:\n                event = {\n                    \"id\": row[\"id\"],\n                    \"title\": row[\"title\"],\n                    \"location\": row[\"location\"],\n                    \"date\": row[\"date\"],\n                    \"category\": row.get(\"category\", \"other\")\n                }\n                events.append(event)\n\n        # Process in batches of 50\n        batch_size = 50\n        results = []\n\n        for i in range(0, len(events), batch_size):\n            batch = events[i:i + batch_size]\n\n            payload = {\n                \"events\": batch,\n                \"auto_geocode\": True\n            }\n\n            result = self.client.session.post(\n                f\"{self.client.base_url}/api/v1/events\",\n                json=payload\n            )\n            result.raise_for_status()\n            results.append(result.json())\n\n        return results\n\n    def export_events_to_csv(self, output_file, **filters):\n        \"\"\"Export events to CSV\"\"\"\n        import csv\n\n        # Get all events with filters\n        events_response = self.client.get_events(**filters)\n        events = events_response[\"events\"]\n\n        # Write to CSV\n        with open(output_file, 'w', newline='') as file:\n            if events:\n                fieldnames = events[0].keys()\n                writer = csv.DictWriter(file, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(events)\n\n        return len(events)\n\n# Usage\nprocessor = BulkEventProcessor(client)\n\n# Import events from CSV\nresults = processor.process_csv_events(\"events.csv\")\nprint(f\"Imported {sum(r['inserted_count'] for r in results)} events\")\n\n# Export technology events to CSV\ncount = processor.export_events_to_csv(\n    \"tech_events.csv\",\n    category=\"technology\"\n)\nprint(f\"Exported {count} events\")\n</code></pre>"},{"location":"api/endpoints/#javascripttypescript-client","title":"\ud83c\udf10 JavaScript/TypeScript Client","text":""},{"location":"api/endpoints/#basic-fetch-api","title":"Basic Fetch API","text":"<pre><code>class EventDiscoveryAPI {\n    constructor(baseUrl = 'http://localhost:8000') {\n        this.baseUrl = baseUrl;\n    }\n\n    async getEvents(filters = {}) {\n        const params = new URLSearchParams(filters);\n        const response = await fetch(`${this.baseUrl}/api/v1/events?${params}`);\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        return await response.json();\n    }\n\n    async createEvent(eventData, autoGeocode = true) {\n        const response = await fetch(`${this.baseUrl}/api/v1/events`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                events: [eventData],\n                auto_geocode: autoGeocode\n            })\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        return await response.json();\n    }\n\n    async geocodeAddresses(addresses) {\n        const response = await fetch(`${this.baseUrl}/api/v1/geocode`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({ addresses })\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        return await response.json();\n    }\n}\n\n// Usage\nconst api = new EventDiscoveryAPI();\n\n// Get events and display on map\nasync function loadEventsOnMap() {\n    try {\n        const response = await api.getEvents({\n            limit: 100,\n            has_coordinates: true\n        });\n\n        response.events.forEach(event =&gt; {\n            if (event.coordinates) {\n                addMarkerToMap(\n                    event.coordinates.latitude,\n                    event.coordinates.longitude,\n                    event.title,\n                    event.description\n                );\n            }\n        });\n\n    } catch (error) {\n        console.error('Failed to load events:', error);\n    }\n}\n</code></pre>"},{"location":"api/endpoints/#testing-examples","title":"\ud83e\uddea Testing Examples","text":""},{"location":"api/endpoints/#unit-testing-with-pytest","title":"Unit Testing with pytest","text":"<pre><code>import pytest\nimport requests\nfrom unittest.mock import patch\n\nclass TestEventAPI:\n    @pytest.fixture\n    def api_client(self):\n        return EventDiscoveryClient(\"http://localhost:8000\")\n\n    def test_get_events_success(self, api_client):\n        \"\"\"Test successful event retrieval\"\"\"\n        events = api_client.get_events(limit=10)\n\n        assert \"events\" in events\n        assert \"total\" in events\n        assert len(events[\"events\"]) &lt;= 10\n\n    def test_get_events_with_filters(self, api_client):\n        \"\"\"Test event retrieval with filters\"\"\"\n        events = api_client.get_events(\n            category=\"technology\",\n            has_coordinates=True\n        )\n\n        for event in events[\"events\"]:\n            assert event[\"category\"] == \"technology\"\n            assert \"coordinates\" in event\n            assert event[\"coordinates\"] is not None\n\n    @patch('requests.Session.post')\n    def test_create_event_with_geocoding(self, mock_post, api_client):\n        \"\"\"Test event creation with automatic geocoding\"\"\"\n        mock_post.return_value.json.return_value = {\n            \"message\": \"Events created successfully\",\n            \"inserted_count\": 1,\n            \"geocoded_count\": 1\n        }\n        mock_post.return_value.raise_for_status.return_value = None\n\n        event_data = {\n            \"id\": \"test_001\",\n            \"title\": \"Test Event\",\n            \"location\": \"Paris, France\"\n        }\n\n        result = api_client.create_event(event_data, auto_geocode=True)\n\n        assert result[\"inserted_count\"] == 1\n        assert result[\"geocoded_count\"] == 1\n\n    def test_geocoding_multiple_addresses(self, api_client):\n        \"\"\"Test geocoding service\"\"\"\n        addresses = [\n            \"15 rue de Milan, Paris\",\n            \"Invalid Address 123\"\n        ]\n\n        result = api_client.geocode_addresses(addresses)\n\n        assert \"results\" in result\n        assert len(result[\"results\"]) == 2\n        assert result[\"success_count\"] &gt;= 1\n</code></pre>"},{"location":"api/endpoints/#integration-testing","title":"Integration Testing","text":"<pre><code>class TestEventAPIIntegration:\n    @pytest.fixture(scope=\"class\")\n    def test_event_id(self):\n        \"\"\"Create a test event for integration tests\"\"\"\n        client = EventDiscoveryClient()\n\n        test_event = {\n            \"id\": \"integration_test_001\",\n            \"title\": \"Integration Test Event\",\n            \"location\": \"Test Location\",\n            \"category\": \"test\"\n        }\n\n        result = client.create_event(test_event)\n        yield test_event[\"id\"]\n\n        # Cleanup\n        client.session.delete(\n            f\"{client.base_url}/api/v1/events/{test_event['id']}\"\n        )\n\n    def test_event_lifecycle(self, test_event_id):\n        \"\"\"Test complete event lifecycle\"\"\"\n        client = EventDiscoveryClient()\n\n        # 1. Verify event was created\n        event = client.session.get(\n            f\"{client.base_url}/api/v1/events/{test_event_id}\"\n        ).json()\n        assert event[\"id\"] == test_event_id\n\n        # 2. Update event\n        update_data = {\n            \"title\": \"Updated Integration Test Event\",\n            \"description\": \"Updated description\"\n        }\n\n        client.session.put(\n            f\"{client.base_url}/api/v1/events/{test_event_id}\",\n            json=update_data\n        )\n\n        # 3. Verify update\n        updated_event = client.session.get(\n            f\"{client.base_url}/api/v1/events/{test_event_id}\"\n        ).json()\n        assert updated_event[\"title\"] == update_data[\"title\"]\n        assert updated_event[\"description\"] == update_data[\"description\"]\n</code></pre>"},{"location":"api/endpoints/#error-handling","title":"\ud83d\udcdd Error Handling","text":""},{"location":"api/endpoints/#common-error-responses","title":"Common Error Responses","text":"<pre><code>{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Invalid request parameters\",\n    \"details\": {\n      \"field\": \"date\",\n      \"reason\": \"Invalid ISO date format\"\n    }\n  }\n}\n</code></pre>"},{"location":"api/endpoints/#error-codes","title":"Error Codes","text":"Code Description HTTP Status <code>VALIDATION_ERROR</code> Invalid request parameters 400 <code>NOT_FOUND</code> Resource not found 404 <code>DATABASE_ERROR</code> Database operation failed 500 <code>GEOCODING_ERROR</code> Geocoding service unavailable 503 <code>MCP_ERROR</code> MCP server communication failed 502 <code>RATE_LIMIT_ERROR</code> Too many requests 429 <p>This comprehensive API reference should help you integrate with the Event Discovery application effectively! \ud83d\ude80</p>"},{"location":"architecture/overview/","title":"System Architecture Overview","text":"<p>This document provides a comprehensive overview of the Event Discovery system architecture, including all components, data flows, and integration patterns.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"\ud83c\udfd7\ufe0f High-Level Architecture","text":"<pre><code>graph TD\n    subgraph \"External Sources\"\n        EB[Eventbrite API]\n        MU[Meetup API] \n        LI[LinkedIn API]\n        CS[Custom Scrapers]\n    end\n\n    subgraph \"MCP Layer\"\n        MCP1[Eventbrite MCP]\n        MCP2[Meetup MCP]\n        MCP3[LinkedIn MCP]\n    end\n\n    subgraph \"Processing Layer\"\n        EP[Event Processor]\n        GEO[Geocoding Service]\n        VAL[Data Validator]\n        NORM[Data Normalizer]\n    end\n\n    subgraph \"Storage Layer\"\n        MONGO[(MongoDB Atlas)]\n        CACHE[Redis Cache]\n    end\n\n    subgraph \"API Layer\"\n        REST[REST API]\n        AUTH[Authentication]\n        RATE[Rate Limiting]\n    end\n\n    subgraph \"Frontend Layer\"\n        NEXT[Next.js App]\n        CHAT[Chat Interface]\n        MAP[Interactive Map]\n        UI[React Components]\n    end\n\n    subgraph \"Infrastructure\"\n        DEPLOY[Deployment]\n        MONITOR[Monitoring]\n        LOGS[Logging]\n    end\n\n    EB --&gt; MCP1\n    MU --&gt; MCP2\n    LI --&gt; MCP3\n    CS --&gt; EP\n\n    MCP1 --&gt; EP\n    MCP2 --&gt; EP\n    MCP3 --&gt; EP\n\n    EP --&gt; GEO\n    EP --&gt; VAL\n    VAL --&gt; NORM\n\n    GEO --&gt; MONGO\n    NORM --&gt; MONGO\n    MONGO --&gt; CACHE\n\n    CACHE --&gt; REST\n    MONGO --&gt; REST\n    REST --&gt; AUTH\n    REST --&gt; RATE\n\n    REST --&gt; NEXT\n    NEXT --&gt; CHAT\n    NEXT --&gt; MAP\n    NEXT --&gt; UI\n\n    NEXT --&gt; DEPLOY\n    DEPLOY --&gt; MONITOR\n    MONITOR --&gt; LOGS\n\n    style EB fill:#e3f2fd\n    style MU fill:#e3f2fd\n    style LI fill:#e3f2fd\n    style MONGO fill:#e8f5e8\n    style NEXT fill:#fff3e0\n    style MAP fill:#fce4ec</code></pre>"},{"location":"architecture/overview/#data-flow-architecture","title":"\ud83d\udd04 Data Flow Architecture","text":"<pre><code>sequenceDiagram\n    participant User\n    participant NextJS as Next.js Frontend\n    participant API as REST API\n    participant Processor as Event Processor\n    participant MCP as MCP Servers\n    participant Geocoder\n    participant MongoDB\n    participant Cache as Redis Cache\n\n    Note over User,Cache: Event Discovery Flow\n\n    User-&gt;&gt;NextJS: Search for events\n    NextJS-&gt;&gt;API: POST /api/events/search\n\n    API-&gt;&gt;Cache: Check cached results\n    alt Cache Hit\n        Cache--&gt;&gt;API: Return cached events\n        API--&gt;&gt;NextJS: Event data\n    else Cache Miss\n        API-&gt;&gt;Processor: Process search request\n\n        par Fetch from multiple sources\n            Processor-&gt;&gt;MCP: Fetch Eventbrite events\n            MCP--&gt;&gt;Processor: Eventbrite data\n        and\n            Processor-&gt;&gt;MCP: Fetch Meetup events  \n            MCP--&gt;&gt;Processor: Meetup data\n        and\n            Processor-&gt;&gt;MCP: Fetch LinkedIn events\n            MCP--&gt;&gt;Processor: LinkedIn data\n        end\n\n        Processor-&gt;&gt;Geocoder: Convert addresses to coordinates\n        Geocoder--&gt;&gt;Processor: Lat/lng coordinates\n\n        Processor-&gt;&gt;MongoDB: Store processed events\n        MongoDB--&gt;&gt;Processor: Storage confirmation\n\n        Processor-&gt;&gt;Cache: Cache search results\n        Processor--&gt;&gt;API: Processed event data\n        API--&gt;&gt;NextJS: Event data\n    end\n\n    NextJS-&gt;&gt;NextJS: Render interactive map\n    NextJS--&gt;&gt;User: Display events with map pins</code></pre>"},{"location":"architecture/overview/#component-architecture","title":"\ud83e\udde9 Component Architecture","text":""},{"location":"architecture/overview/#processing-pipeline","title":"Processing Pipeline","text":"<pre><code>flowchart LR\n    subgraph \"Input\"\n        A[Raw Event Data]\n    end\n\n    subgraph \"Validation\"\n        B[Schema Validation]\n        C[Required Fields Check]\n        D[Data Type Conversion]\n    end\n\n    subgraph \"Enhancement\"\n        E[Geocoding]\n        F[Duplicate Detection]\n        G[Category Normalization]\n    end\n\n    subgraph \"Storage\"\n        H[Database Insert]\n        I[Index Update]\n        J[Cache Update]\n    end\n\n    subgraph \"Output\"\n        K[Standardized Event]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n    H --&gt; I\n    I --&gt; J\n    J --&gt; K\n\n    style A fill:#e1f5fe\n    style K fill:#e8f5e8</code></pre>"},{"location":"architecture/overview/#mcp-integration-pattern","title":"MCP Integration Pattern","text":"<pre><code>graph TB\n    subgraph \"MCP Server Instance\"\n        MC[MCP Core]\n        AP[API Parser]\n        RL[Rate Limiter]\n        ER[Error Recovery]\n    end\n\n    subgraph \"External Platform\"\n        API[Platform API]\n        AUTH[Authentication]\n        DATA[Event Data]\n    end\n\n    subgraph \"Our Application\"\n        CLIENT[MCP Client]\n        PROC[Event Processor]\n        DB[(Database)]\n    end\n\n    CLIENT --&gt;|JSON-RPC| MC\n    MC --&gt; AP\n    AP --&gt; RL\n    RL --&gt; AUTH\n    AUTH --&gt; API\n    API --&gt; DATA\n    DATA --&gt; ER\n    ER --&gt; MC\n    MC --&gt;|Standardized Data| CLIENT\n    CLIENT --&gt; PROC\n    PROC --&gt; DB\n\n    style MC fill:#f3e5f5\n    style CLIENT fill:#e8f5e8\n    style DB fill:#fff3e0</code></pre>"},{"location":"architecture/overview/#database-architecture","title":"\ud83d\uddc4\ufe0f Database Architecture","text":""},{"location":"architecture/overview/#mongodb-collection-structure","title":"MongoDB Collection Structure","text":"<pre><code>erDiagram\n    EVENTS ||--o{ EVENT_TAGS : has\n    EVENTS ||--o{ EVENT_IMAGES : contains\n    EVENTS }o--|| VENUES : located_at\n    EVENTS }o--|| ORGANIZERS : organized_by\n\n    EVENTS {\n        ObjectId _id PK\n        string event_id UK\n        string title\n        text description\n        datetime start_datetime\n        datetime end_datetime\n        string timezone\n        string platform\n        boolean is_online\n        decimal price\n        string currency\n        string category\n        float latitude\n        float longitude\n        datetime scraped_at\n        datetime updated_at\n    }\n\n    VENUES {\n        ObjectId _id PK\n        string name\n        string address\n        string city\n        string postal_code\n        float latitude\n        float longitude\n        string country\n    }\n\n    ORGANIZERS {\n        ObjectId _id PK\n        string name\n        string profile_url\n        text description\n        string platform\n        string external_id\n    }\n\n    EVENT_TAGS {\n        ObjectId _id PK\n        ObjectId event_id FK\n        string tag\n        string source\n    }\n\n    EVENT_IMAGES {\n        ObjectId _id PK\n        ObjectId event_id FK\n        string image_url\n        string alt_text\n        string size\n    }</code></pre>"},{"location":"architecture/overview/#database-indexes","title":"Database Indexes","text":"<pre><code>graph LR\n    subgraph \"Primary Indexes\"\n        PI1[event_id - Unique]\n        PI2[_id - Primary]\n    end\n\n    subgraph \"Search Indexes\"\n        SI1[title - Text]\n        SI2[description - Text]  \n        SI3[category - Single]\n        SI4[platform - Single]\n    end\n\n    subgraph \"Geospatial Indexes\"\n        GI1[location - 2dsphere]\n        GI2[latitude_longitude - Compound]\n    end\n\n    subgraph \"Time Indexes\"\n        TI1[start_datetime - Single]\n        TI2[scraped_at - Single]\n        TI3[city_date - Compound]\n    end\n\n    style PI1 fill:#e3f2fd\n    style GI1 fill:#e8f5e8\n    style TI1 fill:#fff3e0</code></pre>"},{"location":"architecture/overview/#frontend-architecture","title":"\ud83c\udf10 Frontend Architecture","text":"<pre><code>graph TB\n    subgraph \"Next.js App Router\"\n        APP[App Layout]\n        HOME[Home Page]\n        SEARCH[Search Page]\n        EVENT[Event Detail]\n    end\n\n    subgraph \"Components\"\n        MAP[Map Component]\n        CHAT[Chat Interface]\n        SEARCH_BAR[Search Bar]\n        EVENT_CARD[Event Card]\n        FILTERS[Filter Panel]\n    end\n\n    subgraph \"State Management\"\n        CONTEXT[React Context]\n        HOOKS[Custom Hooks]\n        CACHE[SWR Cache]\n    end\n\n    subgraph \"External Services\"\n        MAPS_API[Google Maps API]\n        CHAT_API[Chat API]\n        EVENTS_API[Events API]\n    end\n\n    APP --&gt; HOME\n    APP --&gt; SEARCH\n    APP --&gt; EVENT\n\n    HOME --&gt; MAP\n    HOME --&gt; SEARCH_BAR\n    SEARCH --&gt; FILTERS\n    SEARCH --&gt; EVENT_CARD\n    EVENT --&gt; CHAT\n\n    MAP --&gt; CONTEXT\n    CHAT --&gt; HOOKS\n    SEARCH_BAR --&gt; CACHE\n\n    MAP --&gt; MAPS_API\n    CHAT --&gt; CHAT_API\n    EVENT_CARD --&gt; EVENTS_API\n\n    style APP fill:#e3f2fd\n    style MAP fill:#e8f5e8\n    style CHAT fill:#fff3e0</code></pre>"},{"location":"architecture/overview/#security-architecture","title":"\ud83d\udd12 Security Architecture","text":"<pre><code>graph TB\n    subgraph \"Authentication Layer\"\n        JWT[JWT Tokens]\n        OAUTH[OAuth Providers]\n        API_KEY[API Keys]\n    end\n\n    subgraph \"Authorization Layer\"\n        RBAC[Role-Based Access]\n        PERMS[Permissions]\n        SCOPE[API Scopes]\n    end\n\n    subgraph \"Data Protection\"\n        ENCRYPT[Data Encryption]\n        TLS[TLS/HTTPS]\n        HASH[Password Hashing]\n    end\n\n    subgraph \"Network Security\"\n        FIREWALL[Firewall Rules]\n        RATE_LIMIT[Rate Limiting]\n        IP_FILTER[IP Filtering]\n    end\n\n    subgraph \"Database Security\"\n        DB_AUTH[DB Authentication]\n        NET_ACCESS[Network Access Control]\n        BACKUP[Encrypted Backups]\n    end\n\n    JWT --&gt; RBAC\n    OAUTH --&gt; PERMS\n    API_KEY --&gt; SCOPE\n\n    RBAC --&gt; ENCRYPT\n    PERMS --&gt; TLS\n    SCOPE --&gt; HASH\n\n    ENCRYPT --&gt; FIREWALL\n    TLS --&gt; RATE_LIMIT\n    HASH --&gt; IP_FILTER\n\n    FIREWALL --&gt; DB_AUTH\n    RATE_LIMIT --&gt; NET_ACCESS\n    IP_FILTER --&gt; BACKUP\n\n    style JWT fill:#ffebee\n    style ENCRYPT fill:#e8f5e8\n    style FIREWALL fill:#e3f2fd</code></pre>"},{"location":"architecture/overview/#performance-considerations","title":"\ud83d\udcca Performance Considerations","text":""},{"location":"architecture/overview/#caching-strategy","title":"Caching Strategy","text":"<pre><code>graph LR\n    subgraph \"Cache Layers\"\n        L1[Browser Cache]\n        L2[CDN Cache]\n        L3[API Cache]\n        L4[Database Cache]\n    end\n\n    subgraph \"Cache Types\"\n        STATIC[Static Assets]\n        API_RESP[API Responses]\n        QUERY[Query Results]\n        SESSION[Session Data]\n    end\n\n    USER[User Request] --&gt; L1\n    L1 --&gt; L2\n    L2 --&gt; L3\n    L3 --&gt; L4\n\n    L1 --&gt; STATIC\n    L2 --&gt; STATIC\n    L3 --&gt; API_RESP\n    L4 --&gt; QUERY\n\n    style L1 fill:#e3f2fd\n    style L3 fill:#e8f5e8\n    style QUERY fill:#fff3e0</code></pre>"},{"location":"architecture/overview/#scalability-patterns","title":"Scalability Patterns","text":"<pre><code>graph TB\n    subgraph \"Horizontal Scaling\"\n        LB[Load Balancer]\n        APP1[App Instance 1]\n        APP2[App Instance 2]\n        APP3[App Instance N]\n    end\n\n    subgraph \"Database Scaling\"\n        PRIMARY[(Primary DB)]\n        REPLICA1[(Replica 1)]\n        REPLICA2[(Replica 2)]\n    end\n\n    subgraph \"Microservices\"\n        EVENT_SVC[Event Service]\n        GEO_SVC[Geocoding Service]\n        SEARCH_SVC[Search Service]\n        CACHE_SVC[Cache Service]\n    end\n\n    LB --&gt; APP1\n    LB --&gt; APP2\n    LB --&gt; APP3\n\n    APP1 --&gt; EVENT_SVC\n    APP2 --&gt; GEO_SVC\n    APP3 --&gt; SEARCH_SVC\n\n    EVENT_SVC --&gt; PRIMARY\n    GEO_SVC --&gt; REPLICA1\n    SEARCH_SVC --&gt; REPLICA2\n\n    EVENT_SVC --&gt; CACHE_SVC\n    GEO_SVC --&gt; CACHE_SVC\n    SEARCH_SVC --&gt; CACHE_SVC\n\n    style LB fill:#e3f2fd\n    style PRIMARY fill:#e8f5e8\n    style CACHE_SVC fill:#fff3e0</code></pre>"},{"location":"architecture/overview/#deployment-architecture","title":"\ud83d\ude80 Deployment Architecture","text":"<pre><code>graph TB\n    subgraph \"Development\"\n        DEV[Local Development]\n        TEST[Testing Environment]\n    end\n\n    subgraph \"CI/CD Pipeline\"\n        GIT[Git Repository]\n        BUILD[Build Process]\n        DEPLOY[Deployment]\n    end\n\n    subgraph \"Production\"\n        FRONT[Frontend (Vercel)]\n        API[API Server]\n        DB[MongoDB Atlas]\n        CACHE[Redis Cloud]\n    end\n\n    subgraph \"Monitoring\"\n        METRICS[Metrics Collection]\n        ALERTS[Alert System]\n        LOGS[Log Aggregation]\n    end\n\n    DEV --&gt; GIT\n    TEST --&gt; GIT\n    GIT --&gt; BUILD\n    BUILD --&gt; DEPLOY\n\n    DEPLOY --&gt; FRONT\n    DEPLOY --&gt; API\n    API --&gt; DB\n    API --&gt; CACHE\n\n    FRONT --&gt; METRICS\n    API --&gt; METRICS\n    DB --&gt; METRICS\n\n    METRICS --&gt; ALERTS\n    METRICS --&gt; LOGS\n\n    style DEV fill:#e8f5e8\n    style FRONT fill:#e3f2fd\n    style METRICS fill:#fff3e0</code></pre> <p>This architecture provides a robust, scalable foundation for the Event Discovery application with clear separation of concerns and modern best practices.</p>"},{"location":"components/frontend/","title":"Frontend Components","text":"<p>This document provides comprehensive documentation for the frontend components of the Event Discovery application.</p>"},{"location":"components/frontend/#overview","title":"\ud83c\udfa8 Overview","text":"<p>The frontend is built with Next.js 13+ using the App Router, TypeScript, and Tailwind CSS. It provides an interactive map interface for discovering and exploring events.</p> <pre><code>graph TB\n    subgraph \"Frontend Architecture\"\n        A[Next.js App Router] --&gt; B[Layout Component]\n        B --&gt; C[Page Components]\n        C --&gt; D[Map Component]\n        C --&gt; E[Chat Component]\n        C --&gt; F[Event Cards]\n\n        D --&gt; G[Leaflet Maps]\n        E --&gt; H[MCP Integration]\n        F --&gt; I[Event Details]\n    end\n\n    subgraph \"Data Flow\"\n        J[User Interaction] --&gt; K[React State]\n        K --&gt; L[API Calls]\n        L --&gt; M[Backend API]\n        M --&gt; N[Database]\n        N --&gt; O[UI Update]\n    end\n\n    style A fill:#e3f2fd\n    style G fill:#e8f5e8\n    style M fill:#fff3e0</code></pre>"},{"location":"components/frontend/#project-structure","title":"\ud83d\uddc2\ufe0f Project Structure","text":"<pre><code>frontend/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 layout.tsx          # Root layout component\n\u2502   \u251c\u2500\u2500 page.tsx            # Main page component\n\u2502   \u251c\u2500\u2500 globals.css         # Global styles\n\u2502   \u2514\u2500\u2500 api/\n\u2502       \u251c\u2500\u2500 chat/\n\u2502       \u2502   \u2514\u2500\u2500 route.ts    # Chat API route\n\u2502       \u2514\u2500\u2500 mcp/\n\u2502           \u2514\u2500\u2500 route.ts    # MCP integration route\n\u251c\u2500\u2500 components/\n\u2502   \u251c\u2500\u2500 Chat.tsx            # Chat interface component\n\u2502   \u2514\u2500\u2500 Map.tsx             # Interactive map component\n\u251c\u2500\u2500 public/                 # Static assets\n\u251c\u2500\u2500 package.json            # Dependencies\n\u251c\u2500\u2500 tailwind.config.ts      # Tailwind configuration\n\u251c\u2500\u2500 next.config.ts          # Next.js configuration\n\u2514\u2500\u2500 tsconfig.json          # TypeScript configuration\n</code></pre>"},{"location":"components/frontend/#core-components","title":"\ud83e\udde9 Core Components","text":""},{"location":"components/frontend/#layout-component-applayouttsx","title":"Layout Component (<code>app/layout.tsx</code>)","text":"<p>The root layout component that provides the basic structure for all pages.</p> <pre><code>import type { Metadata } from 'next'\nimport { Inter } from 'next/font/google'\nimport './globals.css'\n\nconst inter = Inter({ subsets: ['latin'] })\n\nexport const metadata: Metadata = {\n  title: 'Event Discovery App',\n  description: 'Discover events on an interactive map',\n}\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    &lt;html lang=\"en\"&gt;\n      &lt;body className={inter.className}&gt;\n        &lt;header className=\"bg-blue-600 text-white p-4\"&gt;\n          &lt;h1 className=\"text-2xl font-bold\"&gt;Event Discovery&lt;/h1&gt;\n          &lt;nav className=\"mt-2\"&gt;\n            &lt;a href=\"/\" className=\"mr-4 hover:underline\"&gt;Home&lt;/a&gt;\n            &lt;a href=\"/about\" className=\"mr-4 hover:underline\"&gt;About&lt;/a&gt;\n            &lt;a href=\"/api\" className=\"hover:underline\"&gt;API Docs&lt;/a&gt;\n          &lt;/nav&gt;\n        &lt;/header&gt;\n\n        &lt;main className=\"min-h-screen bg-gray-50\"&gt;\n          {children}\n        &lt;/main&gt;\n\n        &lt;footer className=\"bg-gray-800 text-white p-4 text-center\"&gt;\n          &lt;p&gt;&amp;copy; 2024 Event Discovery App. Built with Next.js and MongoDB.&lt;/p&gt;\n        &lt;/footer&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  )\n}\n</code></pre> <p>Features: - Responsive header with navigation - Global font loading (Inter) - SEO metadata configuration - Consistent footer across all pages</p>"},{"location":"components/frontend/#main-page-apppagetsx","title":"Main Page (<code>app/page.tsx</code>)","text":"<p>The main application page that combines the map and chat components.</p> <pre><code>'use client'\n\nimport { useState, useEffect } from 'react'\nimport dynamic from 'next/dynamic'\nimport Chat from '@/components/Chat'\n\n// Dynamic import to avoid SSR issues with Leaflet\nconst Map = dynamic(() =&gt; import('@/components/Map'), {\n  ssr: false,\n  loading: () =&gt; (\n    &lt;div className=\"flex items-center justify-center h-full\"&gt;\n      &lt;div className=\"animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  )\n})\n\ninterface Event {\n  id: string\n  title: string\n  description?: string\n  location: string\n  coordinates?: {\n    latitude: number\n    longitude: number\n  }\n  date: string\n  category: string\n  source: string\n  image_url?: string\n  url?: string\n}\n\nexport default function Home() {\n  const [events, setEvents] = useState&lt;Event[]&gt;([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState&lt;string | null&gt;(null)\n  const [selectedCategory, setSelectedCategory] = useState&lt;string&gt;('all')\n  const [searchQuery, setSearchQuery] = useState('')\n  const [showChat, setShowChat] = useState(false)\n\n  // Fetch events from API\n  useEffect(() =&gt; {\n    fetchEvents()\n  }, [selectedCategory, searchQuery])\n\n  const fetchEvents = async () =&gt; {\n    try {\n      setLoading(true)\n      setError(null)\n\n      const params = new URLSearchParams({\n        limit: '1000',\n        has_coordinates: 'true'\n      })\n\n      if (selectedCategory !== 'all') {\n        params.append('category', selectedCategory)\n      }\n\n      if (searchQuery) {\n        params.append('search', searchQuery)\n      }\n\n      const response = await fetch(`/api/events?${params}`)\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch events: ${response.statusText}`)\n      }\n\n      const data = await response.json()\n      setEvents(data.events || [])\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load events')\n      console.error('Error fetching events:', err)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  const handleChatMessage = (message: string) =&gt; {\n    // Handle chat messages - could trigger new searches or filters\n    console.log('Chat message:', message)\n\n    // Example: Parse message for location or category filters\n    if (message.toLowerCase().includes('paris')) {\n      setSearchQuery('paris')\n    }\n\n    if (message.toLowerCase().includes('technology')) {\n      setSelectedCategory('technology')\n    }\n  }\n\n  const categories = [\n    'all',\n    'technology',\n    'business',\n    'networking',\n    'entertainment',\n    'sports',\n    'education',\n    'other'\n  ]\n\n  return (\n    &lt;div className=\"flex h-screen\"&gt;\n      {/* Sidebar */}\n      &lt;div className=\"w-80 bg-white shadow-lg flex flex-col\"&gt;\n        {/* Search and Filters */}\n        &lt;div className=\"p-4 border-b\"&gt;\n          &lt;h2 className=\"text-lg font-semibold mb-4\"&gt;Event Discovery&lt;/h2&gt;\n\n          {/* Search Input */}\n          &lt;div className=\"mb-4\"&gt;\n            &lt;input\n              type=\"text\"\n              placeholder=\"Search events...\"\n              value={searchQuery}\n              onChange={(e) =&gt; setSearchQuery(e.target.value)}\n              className=\"w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n            /&gt;\n          &lt;/div&gt;\n\n          {/* Category Filter */}\n          &lt;div className=\"mb-4\"&gt;\n            &lt;label className=\"block text-sm font-medium text-gray-700 mb-2\"&gt;\n              Category\n            &lt;/label&gt;\n            &lt;select\n              value={selectedCategory}\n              onChange={(e) =&gt; setSelectedCategory(e.target.value)}\n              className=\"w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n            &gt;\n              {categories.map(category =&gt; (\n                &lt;option key={category} value={category}&gt;\n                  {category.charAt(0).toUpperCase() + category.slice(1)}\n                &lt;/option&gt;\n              ))}\n            &lt;/select&gt;\n          &lt;/div&gt;\n\n          {/* Stats */}\n          &lt;div className=\"text-sm text-gray-600\"&gt;\n            {loading ? (\n              'Loading events...'\n            ) : (\n              `${events.length} events found`\n            )}\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n        {/* Event List */}\n        &lt;div className=\"flex-1 overflow-y-auto p-4\"&gt;\n          {error &amp;&amp; (\n            &lt;div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4\"&gt;\n              {error}\n            &lt;/div&gt;\n          )}\n\n          {loading ? (\n            &lt;div className=\"space-y-4\"&gt;\n              {[...Array(5)].map((_, i) =&gt; (\n                &lt;div key={i} className=\"animate-pulse\"&gt;\n                  &lt;div className=\"h-4 bg-gray-200 rounded w-3/4 mb-2\"&gt;&lt;/div&gt;\n                  &lt;div className=\"h-3 bg-gray-200 rounded w-1/2\"&gt;&lt;/div&gt;\n                &lt;/div&gt;\n              ))}\n            &lt;/div&gt;\n          ) : (\n            &lt;div className=\"space-y-4\"&gt;\n              {events.map(event =&gt; (\n                &lt;EventCard\n                  key={event.id}\n                  event={event}\n                  onClick={() =&gt; {\n                    // Focus map on event location\n                    if (event.coordinates) {\n                      // This would trigger map focus\n                      console.log('Focus on event:', event.id)\n                    }\n                  }}\n                /&gt;\n              ))}\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n\n        {/* Chat Toggle */}\n        &lt;div className=\"p-4 border-t\"&gt;\n          &lt;button\n            onClick={() =&gt; setShowChat(!showChat)}\n            className=\"w-full bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition-colors\"\n          &gt;\n            {showChat ? 'Hide Chat' : 'Show Chat Assistant'}\n          &lt;/button&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Main Content */}\n      &lt;div className=\"flex-1 flex flex-col\"&gt;\n        {/* Map Container */}\n        &lt;div className=\"flex-1 relative\"&gt;\n          &lt;Map events={events} /&gt;\n\n          {/* Loading Overlay */}\n          {loading &amp;&amp; (\n            &lt;div className=\"absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10\"&gt;\n              &lt;div className=\"text-center\"&gt;\n                &lt;div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4\"&gt;&lt;/div&gt;\n                &lt;p className=\"text-gray-600\"&gt;Loading events...&lt;/p&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          )}\n        &lt;/div&gt;\n\n        {/* Chat Panel */}\n        {showChat &amp;&amp; (\n          &lt;div className=\"h-96 border-t\"&gt;\n            &lt;Chat onMessage={handleChatMessage} /&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n\n// Event Card Component\ninterface EventCardProps {\n  event: Event\n  onClick: () =&gt; void\n}\n\nfunction EventCard({ event, onClick }: EventCardProps) {\n  const formatDate = (dateString: string) =&gt; {\n    return new Date(dateString).toLocaleDateString('en-US', {\n      weekday: 'short',\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    })\n  }\n\n  const getCategoryColor = (category: string) =&gt; {\n    const colors: Record&lt;string, string&gt; = {\n      technology: 'bg-blue-100 text-blue-800',\n      business: 'bg-green-100 text-green-800',\n      networking: 'bg-purple-100 text-purple-800',\n      entertainment: 'bg-pink-100 text-pink-800',\n      sports: 'bg-orange-100 text-orange-800',\n      education: 'bg-indigo-100 text-indigo-800',\n      other: 'bg-gray-100 text-gray-800'\n    }\n    return colors[category] || colors.other\n  }\n\n  return (\n    &lt;div\n      onClick={onClick}\n      className=\"bg-white rounded-lg shadow-sm border border-gray-200 p-4 cursor-pointer hover:shadow-md transition-shadow\"\n    &gt;\n      {/* Event Image */}\n      {event.image_url &amp;&amp; (\n        &lt;img\n          src={event.image_url}\n          alt={event.title}\n          className=\"w-full h-32 object-cover rounded-md mb-3\"\n        /&gt;\n      )}\n\n      {/* Event Header */}\n      &lt;div className=\"flex items-start justify-between mb-2\"&gt;\n        &lt;h3 className=\"font-semibold text-gray-900 text-sm leading-tight flex-1 mr-2\"&gt;\n          {event.title}\n        &lt;/h3&gt;\n        &lt;span className={`px-2 py-1 rounded-full text-xs font-medium ${getCategoryColor(event.category)}`}&gt;\n          {event.category}\n        &lt;/span&gt;\n      &lt;/div&gt;\n\n      {/* Event Details */}\n      &lt;div className=\"space-y-1 text-xs text-gray-600\"&gt;\n        &lt;div className=\"flex items-center\"&gt;\n          &lt;svg className=\"w-3 h-3 mr-1\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n            &lt;path fillRule=\"evenodd\" d=\"M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z\" clipRule=\"evenodd\" /&gt;\n          &lt;/svg&gt;\n          &lt;span className=\"truncate\"&gt;{event.location}&lt;/span&gt;\n        &lt;/div&gt;\n\n        &lt;div className=\"flex items-center\"&gt;\n          &lt;svg className=\"w-3 h-3 mr-1\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n            &lt;path fillRule=\"evenodd\" d=\"M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z\" clipRule=\"evenodd\" /&gt;\n          &lt;/svg&gt;\n          &lt;span&gt;{formatDate(event.date)}&lt;/span&gt;\n        &lt;/div&gt;\n\n        &lt;div className=\"flex items-center\"&gt;\n          &lt;svg className=\"w-3 h-3 mr-1\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n            &lt;path fillRule=\"evenodd\" d=\"M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z\" clipRule=\"evenodd\" /&gt;\n          &lt;/svg&gt;\n          &lt;span className=\"text-blue-600\"&gt;{event.source}&lt;/span&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Event Description */}\n      {event.description &amp;&amp; (\n        &lt;p className=\"text-xs text-gray-600 mt-2 line-clamp-2\"&gt;\n          {event.description}\n        &lt;/p&gt;\n      )}\n\n      {/* External Link */}\n      {event.url &amp;&amp; (\n        &lt;div className=\"mt-2\"&gt;\n          &lt;a\n            href={event.url}\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n            onClick={(e) =&gt; e.stopPropagation()}\n            className=\"text-xs text-blue-600 hover:text-blue-800 hover:underline\"\n          &gt;\n            View Event Details \u2192\n          &lt;/a&gt;\n        &lt;/div&gt;\n      )}\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Features: - Real-time event search and filtering - Category-based event organization - Interactive event cards with details - Chat assistant integration - Responsive sidebar layout - Loading states and error handling</p>"},{"location":"components/frontend/#map-component-componentsmaptsx","title":"Map Component (<code>components/Map.tsx</code>)","text":"<p>Interactive map component using Leaflet for displaying events with markers and popups.</p> <pre><code>'use client'\n\nimport { useEffect, useRef, useState } from 'react'\nimport L from 'leaflet'\nimport 'leaflet/dist/leaflet.css'\n\n// Fix for default markers in Next.js\ndelete (L.Icon.Default.prototype as any)._getIconUrl\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: '/leaflet/marker-icon-2x.png',\n  iconUrl: '/leaflet/marker-icon.png',\n  shadowUrl: '/leaflet/marker-shadow.png',\n})\n\ninterface Event {\n  id: string\n  title: string\n  description?: string\n  location: string\n  coordinates?: {\n    latitude: number\n    longitude: number\n  }\n  date: string\n  category: string\n  source: string\n  image_url?: string\n  url?: string\n}\n\ninterface MapProps {\n  events: Event[]\n  center?: [number, number]\n  zoom?: number\n}\n\nexport default function Map({ events, center = [48.8566, 2.3522], zoom = 12 }: MapProps) {\n  const mapRef = useRef&lt;HTMLDivElement&gt;(null)\n  const leafletMapRef = useRef&lt;L.Map | null&gt;(null)\n  const markersRef = useRef&lt;L.LayerGroup | null&gt;(null)\n  const [selectedEvent, setSelectedEvent] = useState&lt;Event | null&gt;(null)\n\n  // Initialize map\n  useEffect(() =&gt; {\n    if (!mapRef.current || leafletMapRef.current) return\n\n    // Create map instance\n    const map = L.map(mapRef.current).setView(center, zoom)\n\n    // Add tile layer (OpenStreetMap)\n    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n      attribution: '\u00a9 OpenStreetMap contributors',\n      maxZoom: 19,\n    }).addTo(map)\n\n    // Create marker layer group\n    const markersGroup = L.layerGroup().addTo(map)\n\n    leafletMapRef.current = map\n    markersRef.current = markersGroup\n\n    return () =&gt; {\n      map.remove()\n      leafletMapRef.current = null\n      markersRef.current = null\n    }\n  }, [center, zoom])\n\n  // Update markers when events change\n  useEffect(() =&gt; {\n    if (!leafletMapRef.current || !markersRef.current) return\n\n    const map = leafletMapRef.current\n    const markersGroup = markersRef.current\n\n    // Clear existing markers\n    markersGroup.clearLayers()\n\n    // Add markers for events with coordinates\n    const validEvents = events.filter(event =&gt; event.coordinates)\n\n    if (validEvents.length === 0) return\n\n    const bounds: [number, number][] = []\n\n    validEvents.forEach(event =&gt; {\n      if (!event.coordinates) return\n\n      const { latitude, longitude } = event.coordinates\n      bounds.push([latitude, longitude])\n\n      // Create custom icon based on category\n      const icon = createCategoryIcon(event.category)\n\n      // Create marker\n      const marker = L.marker([latitude, longitude], { icon })\n        .bindPopup(createPopupContent(event), {\n          maxWidth: 300,\n          className: 'event-popup'\n        })\n\n      // Add click handler\n      marker.on('click', () =&gt; {\n        setSelectedEvent(event)\n      })\n\n      // Add to markers group\n      markersGroup.addLayer(marker)\n    })\n\n    // Fit map to show all markers\n    if (bounds.length &gt; 0) {\n      const group = new L.LatLngBounds(bounds)\n      map.fitBounds(group, { padding: [20, 20] })\n    }\n\n  }, [events])\n\n  const createCategoryIcon = (category: string): L.Icon =&gt; {\n    const iconColors: Record&lt;string, string&gt; = {\n      technology: '#3B82F6',\n      business: '#10B981',\n      networking: '#8B5CF6',\n      entertainment: '#EC4899',\n      sports: '#F97316',\n      education: '#6366F1',\n      other: '#6B7280'\n    }\n\n    const color = iconColors[category] || iconColors.other\n\n    // Create custom HTML icon\n    const iconHtml = `\n      &lt;div style=\"\n        background-color: ${color};\n        width: 25px;\n        height: 25px;\n        border-radius: 50% 50% 50% 0;\n        transform: rotate(-45deg);\n        border: 2px solid white;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.3);\n      \"&gt;\n        &lt;div style=\"\n          width: 8px;\n          height: 8px;\n          background-color: white;\n          border-radius: 50%;\n          position: absolute;\n          top: 6px;\n          left: 6px;\n          transform: rotate(45deg);\n        \"&gt;&lt;/div&gt;\n      &lt;/div&gt;\n    `\n\n    return L.divIcon({\n      html: iconHtml,\n      className: 'custom-marker',\n      iconSize: [25, 25],\n      iconAnchor: [12, 25],\n      popupAnchor: [0, -25]\n    })\n  }\n\n  const createPopupContent = (event: Event): string =&gt; {\n    const formatDate = (dateString: string) =&gt; {\n      return new Date(dateString).toLocaleDateString('en-US', {\n        weekday: 'short',\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      })\n    }\n\n    return `\n      &lt;div class=\"event-popup-content\"&gt;\n        ${event.image_url ? `\n          &lt;img \n            src=\"${event.image_url}\" \n            alt=\"${event.title}\"\n            style=\"width: 100%; height: 120px; object-fit: cover; border-radius: 4px; margin-bottom: 8px;\"\n          /&gt;\n        ` : ''}\n\n        &lt;h3 style=\"margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1F2937;\"&gt;\n          ${event.title}\n        &lt;/h3&gt;\n\n        &lt;div style=\"display: flex; align-items: center; margin-bottom: 4px; font-size: 12px; color: #6B7280;\"&gt;\n          &lt;svg width=\"12\" height=\"12\" fill=\"currentColor\" viewBox=\"0 0 20 20\" style=\"margin-right: 4px;\"&gt;\n            &lt;path fill-rule=\"evenodd\" d=\"M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z\" clip-rule=\"evenodd\" /&gt;\n          &lt;/svg&gt;\n          ${event.location}\n        &lt;/div&gt;\n\n        &lt;div style=\"display: flex; align-items: center; margin-bottom: 4px; font-size: 12px; color: #6B7280;\"&gt;\n          &lt;svg width=\"12\" height=\"12\" fill=\"currentColor\" viewBox=\"0 0 20 20\" style=\"margin-right: 4px;\"&gt;\n            &lt;path fill-rule=\"evenodd\" d=\"M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z\" clip-rule=\"evenodd\" /&gt;\n          &lt;/svg&gt;\n          ${formatDate(event.date)}\n        &lt;/div&gt;\n\n        &lt;div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;\"&gt;\n          &lt;span style=\"\n            background-color: #EFF6FF; \n            color: #1D4ED8; \n            padding: 2px 6px; \n            border-radius: 12px; \n            font-size: 10px; \n            font-weight: 500;\n          \"&gt;\n            ${event.category}\n          &lt;/span&gt;\n          &lt;span style=\"font-size: 10px; color: #9CA3AF;\"&gt;\n            ${event.source}\n          &lt;/span&gt;\n        &lt;/div&gt;\n\n        ${event.description ? `\n          &lt;p style=\"margin: 0 0 8px 0; font-size: 11px; color: #4B5563; line-height: 1.4;\"&gt;\n            ${event.description.length &gt; 100 ? event.description.substring(0, 100) + '...' : event.description}\n          &lt;/p&gt;\n        ` : ''}\n\n        &lt;div style=\"display: flex; gap: 8px; margin-top: 8px;\"&gt;\n          &lt;button \n            onclick=\"window.dispatchEvent(new CustomEvent('viewEventDetails', { detail: '${event.id}' }))\"\n            style=\"\n              background-color: #3B82F6; \n              color: white; \n              border: none; \n              padding: 4px 8px; \n              border-radius: 4px; \n              font-size: 11px; \n              cursor: pointer;\n            \"\n          &gt;\n            View Details\n          &lt;/button&gt;\n\n          ${event.url ? `\n            &lt;a \n              href=\"${event.url}\" \n              target=\"_blank\" \n              rel=\"noopener noreferrer\"\n              style=\"\n                background-color: #10B981; \n                color: white; \n                text-decoration: none; \n                padding: 4px 8px; \n                border-radius: 4px; \n                font-size: 11px;\n              \"\n            &gt;\n              External Link\n            &lt;/a&gt;\n          ` : ''}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    `\n  }\n\n  // Handle custom events from popup\n  useEffect(() =&gt; {\n    const handleViewEventDetails = (event: CustomEvent) =&gt; {\n      const eventId = event.detail\n      const selectedEvent = events.find(e =&gt; e.id === eventId)\n      if (selectedEvent) {\n        setSelectedEvent(selectedEvent)\n      }\n    }\n\n    window.addEventListener('viewEventDetails', handleViewEventDetails as EventListener)\n    return () =&gt; {\n      window.removeEventListener('viewEventDetails', handleViewEventDetails as EventListener)\n    }\n  }, [events])\n\n  return (\n    &lt;div className=\"relative w-full h-full\"&gt;\n      {/* Map Container */}\n      &lt;div ref={mapRef} className=\"w-full h-full\" /&gt;\n\n      {/* Map Controls */}\n      &lt;div className=\"absolute top-4 right-4 z-10 space-y-2\"&gt;\n        &lt;button\n          onClick={() =&gt; {\n            if (leafletMapRef.current &amp;&amp; events.length &gt; 0) {\n              const validEvents = events.filter(e =&gt; e.coordinates)\n              if (validEvents.length &gt; 0) {\n                const bounds = validEvents.map(e =&gt; [e.coordinates!.latitude, e.coordinates!.longitude] as [number, number])\n                const group = new L.LatLngBounds(bounds)\n                leafletMapRef.current.fitBounds(group, { padding: [20, 20] })\n              }\n            }\n          }}\n          className=\"bg-white shadow-md rounded-md p-2 hover:bg-gray-50 transition-colors\"\n          title=\"Fit all events\"\n        &gt;\n          &lt;svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n            &lt;path fillRule=\"evenodd\" d=\"M3 4a1 1 0 011-1h4a1 1 0 010 2H6.414l2.293 2.293a1 1 0 11-1.414 1.414L5 6.414V8a1 1 0 01-2 0V4zm9 1a1 1 0 010-2h4a1 1 0 011 1v4a1 1 0 01-2 0V6.414l-2.293 2.293a1 1 0 11-1.414-1.414L13.586 5H12zm-9 7a1 1 0 012 0v1.586l2.293-2.293a1 1 0 111.414 1.414L6.414 15H8a1 1 0 010 2H4a1 1 0 01-1-1v-4zm13-1a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 010-2h1.586l-2.293-2.293a1 1 0 111.414-1.414L15 13.586V12a1 1 0 011-1z\" clipRule=\"evenodd\" /&gt;\n          &lt;/svg&gt;\n        &lt;/button&gt;\n\n        &lt;div className=\"bg-white shadow-md rounded-md p-2 text-sm\"&gt;\n          &lt;div className=\"font-medium\"&gt;{events.length} Events&lt;/div&gt;\n          &lt;div className=\"text-gray-600 text-xs\"&gt;\n            {events.filter(e =&gt; e.coordinates).length} with location\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n\n      {/* Event Details Modal */}\n      {selectedEvent &amp;&amp; (\n        &lt;EventDetailsModal\n          event={selectedEvent}\n          onClose={() =&gt; setSelectedEvent(null)}\n        /&gt;\n      )}\n    &lt;/div&gt;\n  )\n}\n\n// Event Details Modal Component\ninterface EventDetailsModalProps {\n  event: Event\n  onClose: () =&gt; void\n}\n\nfunction EventDetailsModal({ event, onClose }: EventDetailsModalProps) {\n  const formatDate = (dateString: string) =&gt; {\n    return new Date(dateString).toLocaleDateString('en-US', {\n      weekday: 'long',\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit',\n      timeZoneName: 'short'\n    })\n  }\n\n  return (\n    &lt;div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\"&gt;\n      &lt;div className=\"bg-white rounded-lg max-w-2xl w-full max-h-[90vh] overflow-y-auto\"&gt;\n        {/* Header */}\n        &lt;div className=\"sticky top-0 bg-white border-b p-4 flex items-center justify-between\"&gt;\n          &lt;h2 className=\"text-xl font-semibold text-gray-900\"&gt;{event.title}&lt;/h2&gt;\n          &lt;button\n            onClick={onClose}\n            className=\"text-gray-400 hover:text-gray-600 transition-colors\"\n          &gt;\n            &lt;svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"&gt;\n              &lt;path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" /&gt;\n            &lt;/svg&gt;\n          &lt;/button&gt;\n        &lt;/div&gt;\n\n        {/* Content */}\n        &lt;div className=\"p-6\"&gt;\n          {/* Event Image */}\n          {event.image_url &amp;&amp; (\n            &lt;img\n              src={event.image_url}\n              alt={event.title}\n              className=\"w-full h-64 object-cover rounded-lg mb-6\"\n            /&gt;\n          )}\n\n          {/* Event Details */}\n          &lt;div className=\"space-y-4\"&gt;\n            &lt;div className=\"flex items-center text-gray-600\"&gt;\n              &lt;svg className=\"w-5 h-5 mr-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n                &lt;path fillRule=\"evenodd\" d=\"M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z\" clipRule=\"evenodd\" /&gt;\n              &lt;/svg&gt;\n              &lt;span&gt;{formatDate(event.date)}&lt;/span&gt;\n            &lt;/div&gt;\n\n            &lt;div className=\"flex items-center text-gray-600\"&gt;\n              &lt;svg className=\"w-5 h-5 mr-3\" fill=\"currentColor\" viewBox=\"0 0 20 20\"&gt;\n                &lt;path fillRule=\"evenodd\" d=\"M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z\" clipRule=\"evenodd\" /&gt;\n              &lt;/svg&gt;\n              &lt;span&gt;{event.location}&lt;/span&gt;\n            &lt;/div&gt;\n\n            &lt;div className=\"flex items-center justify-between\"&gt;\n              &lt;span className=\"bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-medium\"&gt;\n                {event.category}\n              &lt;/span&gt;\n              &lt;span className=\"text-sm text-gray-500\"&gt;Source: {event.source}&lt;/span&gt;\n            &lt;/div&gt;\n\n            {event.description &amp;&amp; (\n              &lt;div&gt;\n                &lt;h3 className=\"font-semibold text-gray-900 mb-2\"&gt;Description&lt;/h3&gt;\n                &lt;p className=\"text-gray-700 leading-relaxed\"&gt;{event.description}&lt;/p&gt;\n              &lt;/div&gt;\n            )}\n\n            {event.coordinates &amp;&amp; (\n              &lt;div&gt;\n                &lt;h3 className=\"font-semibold text-gray-900 mb-2\"&gt;Location Details&lt;/h3&gt;\n                &lt;p className=\"text-sm text-gray-600\"&gt;\n                  Latitude: {event.coordinates.latitude}&lt;br /&gt;\n                  Longitude: {event.coordinates.longitude}\n                &lt;/p&gt;\n              &lt;/div&gt;\n            )}\n          &lt;/div&gt;\n\n          {/* Actions */}\n          &lt;div className=\"flex gap-3 mt-6 pt-6 border-t\"&gt;\n            {event.url &amp;&amp; (\n              &lt;a\n                href={event.url}\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                className=\"bg-blue-600 text-white px-6 py-2 rounded-md hover:bg-blue-700 transition-colors\"\n              &gt;\n                View on {event.source}\n              &lt;/a&gt;\n            )}\n\n            {event.coordinates &amp;&amp; (\n              &lt;a\n                href={`https://www.google.com/maps?q=${event.coordinates.latitude},${event.coordinates.longitude}`}\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                className=\"bg-green-600 text-white px-6 py-2 rounded-md hover:bg-green-700 transition-colors\"\n              &gt;\n                Open in Maps\n              &lt;/a&gt;\n            )}\n\n            &lt;button\n              onClick={onClose}\n              className=\"bg-gray-300 text-gray-700 px-6 py-2 rounded-md hover:bg-gray-400 transition-colors\"\n            &gt;\n              Close\n            &lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Features: - Interactive Leaflet map with custom markers - Category-based marker styling - Rich popup content with event details - Event details modal - Map controls and bounds fitting - Custom icon creation based on event categories</p>"},{"location":"components/frontend/#chat-component-componentschattsx","title":"Chat Component (<code>components/Chat.tsx</code>)","text":"<p>AI-powered chat interface for event discovery and interaction.</p> <pre><code>'use client'\n\nimport { useState, useRef, useEffect } from 'react'\n\ninterface Message {\n  id: string\n  content: string\n  role: 'user' | 'assistant'\n  timestamp: Date\n}\n\ninterface ChatProps {\n  onMessage?: (message: string) =&gt; void\n}\n\nexport default function Chat({ onMessage }: ChatProps) {\n  const [messages, setMessages] = useState&lt;Message[]&gt;([\n    {\n      id: '1',\n      content: 'Hello! I can help you discover events. Try asking me about events in specific locations or categories.',\n      role: 'assistant',\n      timestamp: new Date()\n    }\n  ])\n  const [input, setInput] = useState('')\n  const [isLoading, setIsLoading] = useState(false)\n  const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null)\n\n  const scrollToBottom = () =&gt; {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })\n  }\n\n  useEffect(() =&gt; {\n    scrollToBottom()\n  }, [messages])\n\n  const handleSendMessage = async (e: React.FormEvent) =&gt; {\n    e.preventDefault()\n    if (!input.trim() || isLoading) return\n\n    const userMessage: Message = {\n      id: Date.now().toString(),\n      content: input.trim(),\n      role: 'user',\n      timestamp: new Date()\n    }\n\n    setMessages(prev =&gt; [...prev, userMessage])\n    setInput('')\n    setIsLoading(true)\n\n    // Call parent callback\n    onMessage?.(userMessage.content)\n\n    try {\n      // Send message to chat API\n      const response = await fetch('/api/chat', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          message: userMessage.content,\n          history: messages\n        }),\n      })\n\n      if (!response.ok) {\n        throw new Error('Failed to get response')\n      }\n\n      const data = await response.json()\n\n      const assistantMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        content: data.response,\n        role: 'assistant',\n        timestamp: new Date()\n      }\n\n      setMessages(prev =&gt; [...prev, assistantMessage])\n\n      // Execute any actions from the response\n      if (data.actions) {\n        handleChatActions(data.actions)\n      }\n\n    } catch (error) {\n      console.error('Chat error:', error)\n\n      const errorMessage: Message = {\n        id: (Date.now() + 1).toString(),\n        content: 'Sorry, I encountered an error. Please try again.',\n        role: 'assistant',\n        timestamp: new Date()\n      }\n\n      setMessages(prev =&gt; [...prev, errorMessage])\n    } finally {\n      setIsLoading(false)\n    }\n  }\n\n  const handleChatActions = (actions: any[]) =&gt; {\n    actions.forEach(action =&gt; {\n      switch (action.type) {\n        case 'search_events':\n          // Trigger event search\n          onMessage?.(action.query)\n          break\n        case 'filter_category':\n          // Apply category filter\n          onMessage?.(action.category)\n          break\n        case 'focus_location':\n          // Focus map on location\n          onMessage?.(action.location)\n          break\n        default:\n          console.log('Unknown action:', action)\n      }\n    })\n  }\n\n  const formatTime = (date: Date) =&gt; {\n    return date.toLocaleTimeString('en-US', {\n      hour: '2-digit',\n      minute: '2-digit'\n    })\n  }\n\n  return (\n    &lt;div className=\"flex flex-col h-full bg-gray-50\"&gt;\n      {/* Chat Header */}\n      &lt;div className=\"bg-white border-b px-4 py-3\"&gt;\n        &lt;h3 className=\"font-semibold text-gray-900\"&gt;Event Discovery Assistant&lt;/h3&gt;\n        &lt;p className=\"text-sm text-gray-600\"&gt;Ask me about events, locations, or categories&lt;/p&gt;\n      &lt;/div&gt;\n\n      {/* Messages Container */}\n      &lt;div className=\"flex-1 overflow-y-auto p-4 space-y-4\"&gt;\n        {messages.map((message) =&gt; (\n          &lt;div\n            key={message.id}\n            className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}\n          &gt;\n            &lt;div\n              className={`max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${\n                message.role === 'user'\n                  ? 'bg-blue-600 text-white'\n                  : 'bg-white text-gray-900 shadow-sm border'\n              }`}\n            &gt;\n              &lt;p className=\"text-sm\"&gt;{message.content}&lt;/p&gt;\n              &lt;p\n                className={`text-xs mt-1 ${\n                  message.role === 'user' ? 'text-blue-100' : 'text-gray-500'\n                }`}\n              &gt;\n                {formatTime(message.timestamp)}\n              &lt;/p&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        ))}\n\n        {/* Loading Indicator */}\n        {isLoading &amp;&amp; (\n          &lt;div className=\"flex justify-start\"&gt;\n            &lt;div className=\"bg-white text-gray-900 shadow-sm border max-w-xs lg:max-w-md px-4 py-2 rounded-lg\"&gt;\n              &lt;div className=\"flex items-center space-x-2\"&gt;\n                &lt;div className=\"flex space-x-1\"&gt;\n                  &lt;div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"&gt;&lt;/div&gt;\n                  &lt;div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0.1s' }}&gt;&lt;/div&gt;\n                  &lt;div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0.2s' }}&gt;&lt;/div&gt;\n                &lt;/div&gt;\n                &lt;span className=\"text-sm text-gray-500\"&gt;Thinking...&lt;/span&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        )}\n\n        &lt;div ref={messagesEndRef} /&gt;\n      &lt;/div&gt;\n\n      {/* Message Input */}\n      &lt;div className=\"bg-white border-t p-4\"&gt;\n        &lt;form onSubmit={handleSendMessage} className=\"flex space-x-3\"&gt;\n          &lt;input\n            type=\"text\"\n            value={input}\n            onChange={(e) =&gt; setInput(e.target.value)}\n            placeholder=\"Ask about events...\"\n            disabled={isLoading}\n            className=\"flex-1 border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent disabled:bg-gray-100\"\n          /&gt;\n          &lt;button\n            type=\"submit\"\n            disabled={!input.trim() || isLoading}\n            className=\"bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors\"\n          &gt;\n            {isLoading ? (\n              &lt;svg className=\"w-4 h-4 animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\"&gt;\n                &lt;circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"&gt;&lt;/circle&gt;\n                &lt;path className=\"opacity-75\" fill=\"currentColor\" d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"&gt;&lt;/path&gt;\n              &lt;/svg&gt;\n            ) : (\n              &lt;svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\"&gt;\n                &lt;path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" /&gt;\n              &lt;/svg&gt;\n            )}\n          &lt;/button&gt;\n        &lt;/form&gt;\n\n        {/* Quick Actions */}\n        &lt;div className=\"mt-3 flex flex-wrap gap-2\"&gt;\n          {[\n            'Show tech events in Paris',\n            'Find networking events this week',\n            'Events near me',\n            'Business conferences',\n            'Free events'\n          ].map((suggestion) =&gt; (\n            &lt;button\n              key={suggestion}\n              onClick={() =&gt; {\n                setInput(suggestion)\n                handleSendMessage(new Event('submit') as any)\n              }}\n              disabled={isLoading}\n              className=\"text-xs bg-gray-100 text-gray-700 px-3 py-1 rounded-full hover:bg-gray-200 transition-colors disabled:opacity-50\"\n            &gt;\n              {suggestion}\n            &lt;/button&gt;\n          ))}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Features: - Real-time chat interface - Message history and timestamps - Loading states and error handling - Quick action suggestions - Integration with backend chat API - Action execution based on chat responses</p>"},{"location":"components/frontend/#api-routes","title":"\ud83d\udd17 API Routes","text":""},{"location":"components/frontend/#chat-api-route-appapichatroutets","title":"Chat API Route (<code>app/api/chat/route.ts</code>)","text":"<p>Handles chat interactions and integrates with MCP servers for intelligent responses.</p> <pre><code>import { NextRequest, NextResponse } from 'next/server'\n\ninterface Message {\n  id: string\n  content: string\n  role: 'user' | 'assistant'\n  timestamp: Date\n}\n\ninterface ChatRequest {\n  message: string\n  history: Message[]\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { message, history }: ChatRequest = await request.json()\n\n    // Process the message and generate response\n    const response = await processMessage(message, history)\n\n    return NextResponse.json(response)\n  } catch (error) {\n    console.error('Chat API error:', error)\n    return NextResponse.json(\n      { error: 'Internal server error' },\n      { status: 500 }\n    )\n  }\n}\n\nasync function processMessage(message: string, history: Message[]) {\n  // Simple keyword-based processing\n  // In production, integrate with OpenAI, Anthropic, or other LLM APIs\n\n  const lowerMessage = message.toLowerCase()\n\n  // Location-based queries\n  if (lowerMessage.includes('paris')) {\n    return {\n      response: 'I found events in Paris! I\\'ll filter the map to show events in Paris.',\n      actions: [\n        { type: 'search_events', query: 'location:Paris' }\n      ]\n    }\n  }\n\n  // Category-based queries\n  const categories = ['technology', 'business', 'networking', 'entertainment', 'sports', 'education']\n  const mentionedCategory = categories.find(cat =&gt; lowerMessage.includes(cat))\n\n  if (mentionedCategory) {\n    return {\n      response: `Great! I'll show you ${mentionedCategory} events. Filtering the map now.`,\n      actions: [\n        { type: 'filter_category', category: mentionedCategory }\n      ]\n    }\n  }\n\n  // Time-based queries\n  if (lowerMessage.includes('today') || lowerMessage.includes('tonight')) {\n    return {\n      response: 'Looking for events happening today! Let me filter the results.',\n      actions: [\n        { type: 'search_events', query: 'date:today' }\n      ]\n    }\n  }\n\n  if (lowerMessage.includes('this week')) {\n    return {\n      response: 'Showing events for this week. Check the map for all upcoming events!',\n      actions: [\n        { type: 'search_events', query: 'date:week' }\n      ]\n    }\n  }\n\n  // General help\n  if (lowerMessage.includes('help') || lowerMessage.includes('what can you do')) {\n    return {\n      response: `I can help you discover events! Here's what I can do:\n\n\u2022 Find events by location (e.g., \"events in Paris\")\n\u2022 Filter by category (technology, business, networking, etc.)\n\u2022 Search by time (today, this week, this month)\n\u2022 Show event details and directions\n\u2022 Suggest similar events\n\nTry asking me something like \"Show me tech events in Paris\" or \"What's happening tonight?\"`,\n      actions: []\n    }\n  }\n\n  // Default response\n  return {\n    response: `I understand you're looking for \"${message}\". Let me search for relevant events. You can try being more specific about location or category!`,\n    actions: [\n      { type: 'search_events', query: message }\n    ]\n  }\n}\n</code></pre>"},{"location":"components/frontend/#mcp-api-route-appapimcproutets","title":"MCP API Route (<code>app/api/mcp/route.ts</code>)","text":"<p>Handles MCP server communication for event data synchronization.</p> <pre><code>import { NextRequest, NextResponse } from 'next/server'\n\ninterface MCPSyncRequest {\n  sources: string[]\n  location?: string\n  category?: string\n  dateRange?: {\n    start: string\n    end: string\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const syncRequest: MCPSyncRequest = await request.json()\n\n    // Trigger MCP synchronization\n    const syncId = await startMCPSync(syncRequest)\n\n    return NextResponse.json({\n      syncId,\n      status: 'started',\n      estimatedCompletion: new Date(Date.now() + 5 * 60 * 1000).toISOString()\n    })\n  } catch (error) {\n    console.error('MCP sync error:', error)\n    return NextResponse.json(\n      { error: 'Failed to start synchronization' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  const { searchParams } = new URL(request.url)\n  const syncId = searchParams.get('syncId')\n\n  if (syncId) {\n    // Get sync status\n    const status = await getMCPSyncStatus(syncId)\n    return NextResponse.json(status)\n  }\n\n  // Get available MCP sources\n  const sources = await getMCPSources()\n  return NextResponse.json({ sources })\n}\n\nasync function startMCPSync(syncRequest: MCPSyncRequest): Promise&lt;string&gt; {\n  // Generate unique sync ID\n  const syncId = `sync_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n\n  // In production, this would queue a background job\n  // For now, simulate the process\n\n  console.log('Starting MCP sync:', {\n    syncId,\n    sources: syncRequest.sources,\n    location: syncRequest.location,\n    category: syncRequest.category\n  })\n\n  // Simulate background processing\n  setTimeout(async () =&gt; {\n    await processMCPSync(syncId, syncRequest)\n  }, 1000)\n\n  return syncId\n}\n\nasync function processMCPSync(syncId: string, syncRequest: MCPSyncRequest) {\n  try {\n    const results: any = {}\n\n    for (const source of syncRequest.sources) {\n      console.log(`Processing ${source}...`)\n\n      // Simulate MCP server communication\n      const sourceResult = await communicateWithMCPServer(source, syncRequest)\n      results[source] = sourceResult\n    }\n\n    // Update sync status to completed\n    await updateSyncStatus(syncId, 'completed', results)\n\n  } catch (error) {\n    console.error(`MCP sync ${syncId} failed:`, error)\n    await updateSyncStatus(syncId, 'failed', { error: error.message })\n  }\n}\n\nasync function communicateWithMCPServer(source: string, syncRequest: MCPSyncRequest) {\n  // In production, this would make actual HTTP requests to MCP servers\n  // For now, return mock data\n\n  const mockResults = {\n    eventbrite: {\n      eventsFound: 25,\n      eventsSaved: 23,\n      eventsUpdated: 2,\n      errors: 0\n    },\n    meetup: {\n      eventsFound: 18,\n      eventsSaved: 18,\n      eventsUpdated: 0,\n      errors: 0\n    },\n    linkedin: {\n      eventsFound: 12,\n      eventsSaved: 10,\n      eventsUpdated: 1,\n      errors: 1\n    }\n  }\n\n  // Simulate network delay\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000))\n\n  return mockResults[source as keyof typeof mockResults] || {\n    eventsFound: 0,\n    eventsSaved: 0,\n    eventsUpdated: 0,\n    errors: 1\n  }\n}\n\nasync function getMCPSources() {\n  return [\n    {\n      name: 'eventbrite',\n      url: 'http://localhost:3001',\n      status: 'active',\n      lastSync: new Date().toISOString(),\n      eventCount: 150\n    },\n    {\n      name: 'meetup',\n      url: 'http://localhost:3002',\n      status: 'active',\n      lastSync: new Date().toISOString(),\n      eventCount: 89\n    },\n    {\n      name: 'linkedin',\n      url: 'http://localhost:3003',\n      status: 'inactive',\n      lastSync: null,\n      eventCount: 0\n    }\n  ]\n}\n\nasync function getMCPSyncStatus(syncId: string) {\n  // In production, this would query a database or cache\n  // For now, return mock status\n\n  return {\n    syncId,\n    status: 'completed',\n    startedAt: new Date(Date.now() - 5 * 60 * 1000).toISOString(),\n    completedAt: new Date().toISOString(),\n    results: {\n      eventbrite: {\n        eventsFound: 25,\n        eventsSaved: 23,\n        eventsUpdated: 2,\n        errors: 0\n      },\n      meetup: {\n        eventsFound: 18,\n        eventsSaved: 18,\n        eventsUpdated: 0,\n        errors: 0\n      }\n    },\n    totalEventsProcessed: 41,\n    geocodingResults: {\n      successful: 38,\n      failed: 3\n    }\n  }\n}\n\nasync function updateSyncStatus(syncId: string, status: string, results?: any) {\n  // In production, this would update a database\n  console.log(`Sync ${syncId} status updated to: ${status}`, results)\n}\n</code></pre>"},{"location":"components/frontend/#styling-configuration","title":"\ud83c\udfa8 Styling &amp; Configuration","text":""},{"location":"components/frontend/#tailwind-configuration-tailwindconfigts","title":"Tailwind Configuration (<code>tailwind.config.ts</code>)","text":"<pre><code>import type { Config } from 'tailwindcss'\n\nconst config: Config = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        primary: {\n          50: '#eff6ff',\n          500: '#3b82f6',\n          600: '#2563eb',\n          700: '#1d4ed8',\n        },\n        secondary: {\n          50: '#f0fdf4',\n          500: '#10b981',\n          600: '#059669',\n          700: '#047857',\n        }\n      },\n      fontFamily: {\n        sans: ['Inter', 'sans-serif'],\n      },\n      animation: {\n        'fade-in': 'fadeIn 0.5s ease-in-out',\n        'slide-up': 'slideUp 0.3s ease-out',\n      },\n      keyframes: {\n        fadeIn: {\n          '0%': { opacity: '0' },\n          '100%': { opacity: '1' },\n        },\n        slideUp: {\n          '0%': { transform: 'translateY(100%)' },\n          '100%': { transform: 'translateY(0)' },\n        },\n      }\n    },\n  },\n  plugins: [\n    require('@tailwindcss/forms'),\n    require('@tailwindcss/typography'),\n  ],\n}\n\nexport default config\n</code></pre>"},{"location":"components/frontend/#global-styles-appglobalscss","title":"Global Styles (<code>app/globals.css</code>)","text":"<pre><code>@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n/* Custom styles for Leaflet popups */\n.leaflet-popup-content-wrapper {\n  border-radius: 8px;\n  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);\n}\n\n.leaflet-popup-content {\n  margin: 0;\n  padding: 0;\n}\n\n.event-popup-content {\n  font-family: Inter, sans-serif;\n}\n\n/* Custom marker styles */\n.custom-marker {\n  background: transparent !important;\n  border: none !important;\n}\n\n/* Loading animations */\n.animate-pulse {\n  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n}\n\n@keyframes pulse {\n  0%, 100% {\n    opacity: 1;\n  }\n  50% {\n    opacity: .5;\n  }\n}\n\n/* Scrollbar customization */\n.overflow-y-auto::-webkit-scrollbar {\n  width: 6px;\n}\n\n.overflow-y-auto::-webkit-scrollbar-track {\n  background: #f1f5f9;\n}\n\n.overflow-y-auto::-webkit-scrollbar-thumb {\n  background: #cbd5e1;\n  border-radius: 3px;\n}\n\n.overflow-y-auto::-webkit-scrollbar-thumb:hover {\n  background: #94a3b8;\n}\n\n/* Line clamp utility */\n.line-clamp-2 {\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 2;\n}\n\n/* Focus styles */\n.focus-visible\\:ring-2:focus-visible {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n  box-shadow: 0 0 0 2px #3b82f6;\n}\n\n/* Custom button variants */\n.btn-primary {\n  @apply bg-blue-600 text-white px-4 py-2 rounded-md font-medium hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-colors;\n}\n\n.btn-secondary {\n  @apply bg-gray-200 text-gray-900 px-4 py-2 rounded-md font-medium hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-colors;\n}\n\n.btn-success {\n  @apply bg-green-600 text-white px-4 py-2 rounded-md font-medium hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition-colors;\n}\n\n/* Card styles */\n.card {\n  @apply bg-white rounded-lg shadow-sm border border-gray-200 p-4;\n}\n\n.card-hover {\n  @apply card hover:shadow-md transition-shadow cursor-pointer;\n}\n\n/* Form styles */\n.form-input {\n  @apply w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent;\n}\n\n.form-select {\n  @apply form-input bg-white;\n}\n\n.form-label {\n  @apply block text-sm font-medium text-gray-700 mb-1;\n}\n\n/* Responsive design helpers */\n@media (max-width: 768px) {\n  .mobile-hidden {\n    display: none;\n  }\n\n  .mobile-sidebar {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    z-index: 50;\n    transform: translateX(-100%);\n    transition: transform 0.3s ease;\n  }\n\n  .mobile-sidebar.open {\n    transform: translateX(0);\n  }\n}\n\n/* Dark mode support (future enhancement) */\n@media (prefers-color-scheme: dark) {\n  .dark\\:bg-gray-900 {\n    background-color: #1f2937;\n  }\n\n  .dark\\:text-white {\n    color: white;\n  }\n}\n</code></pre> <p>This comprehensive frontend documentation provides all the components, configurations, and styling needed for the Event Discovery application! \ud83c\udfa8</p>"},{"location":"components/geocoder/","title":"Geocoding Service","text":"<p>The geocoding service converts addresses and location names into precise latitude and longitude coordinates using the free OpenStreetMap Nominatim API.</p>"},{"location":"components/geocoder/#overview","title":"\ud83d\uddfa\ufe0f Overview","text":"<pre><code>graph LR\n    INPUT[Address String] --&gt; GEOCODER[Geocoding Service]\n    GEOCODER --&gt; NOMINATIM[Nominatim API]\n    NOMINATIM --&gt; PARSER[Response Parser]\n    PARSER --&gt; COORDS[Lat/Lng Coordinates]\n\n    GEOCODER --&gt; CACHE[Local Cache]\n    CACHE --&gt; COORDS\n\n    style GEOCODER fill:#e8f5e8\n    style NOMINATIM fill:#e3f2fd\n    style COORDS fill:#fff3e0</code></pre>"},{"location":"components/geocoder/#implementation","title":"\ud83d\udd27 Implementation","text":""},{"location":"components/geocoder/#core-geocoder-class","title":"Core Geocoder Class","text":"<pre><code>import requests\nimport time\nfrom typing import Tuple, Optional\n\nclass FreeGeocoder:\n    \"\"\"Free geocoding using OpenStreetMap Nominatim\"\"\"\n\n    def __init__(self):\n        self.base_url = \"https://nominatim.openstreetmap.org/search\"\n        self.session = requests.Session()\n        self.session.headers.update({\n            'User-Agent': 'EventApp/1.0 (your-email@example.com)'\n        })\n        self.cache = {}  # Simple in-memory cache\n\n    def geocode(self, address: str) -&gt; Optional[Tuple[float, float]]:\n        \"\"\"Convert address to latitude, longitude coordinates\"\"\"\n\n        if not address or address.strip() == '':\n            return None\n\n        # Check cache first\n        cache_key = address.lower().strip()\n        if cache_key in self.cache:\n            return self.cache[cache_key]\n\n        # Rate limiting - Nominatim allows 1 request per second\n        time.sleep(1)\n\n        params = {\n            'q': address,\n            'format': 'json',\n            'limit': 1,\n            'addressdetails': 1\n        }\n\n        try:\n            response = self.session.get(\n                self.base_url, \n                params=params, \n                timeout=5\n            )\n            response.raise_for_status()\n\n            data = response.json()\n\n            if data and len(data) &gt; 0:\n                result = data[0]\n                lat = float(result['lat'])\n                lon = float(result['lon'])\n\n                coords = (lat, lon)\n\n                # Cache the result\n                self.cache[cache_key] = coords\n\n                print(f\"\u2705 Geocoded '{address}' \u2192 {lat:.4f}, {lon:.4f}\")\n                return coords\n            else:\n                print(f\"\u274c No results for '{address}'\")\n                return None\n\n        except Exception as e:\n            print(f\"\u274c Geocoding error for '{address}': {e}\")\n            return None\n</code></pre>"},{"location":"components/geocoder/#usage-examples","title":"\ud83d\udccd Usage Examples","text":""},{"location":"components/geocoder/#basic-geocoding","title":"Basic Geocoding","text":"<pre><code>from geocoder import geocoder\n\n# Test various address formats\naddresses = [\n    \"15 rue de milan, paris\",           # Your test address\n    \"Eiffel Tower, Paris\",              # Landmark\n    \"Station F, Paris, France\",         # Venue\n    \"75001 Paris\",                      # Postal code\n    \"R\u00e9publique, Paris\",                # Metro station\n    \"La Sorbonne, Paris\"               # University\n]\n\nfor address in addresses:\n    coords = geocoder.geocode(address)\n    if coords:\n        lat, lng = coords\n        print(f\"\ud83d\udccd {address} \u2192 {lat:.4f}, {lng:.4f}\")\n    else:\n        print(f\"\u274c Failed to geocode: {address}\")\n</code></pre>"},{"location":"components/geocoder/#integration-with-event-processing","title":"Integration with Event Processing","text":"<pre><code>def process_event_location(event_data):\n    \"\"\"Process event and add coordinates if missing\"\"\"\n\n    # Check if coordinates already exist\n    lat = event_data.get('latitude', 0)\n    lng = event_data.get('longitude', 0)\n\n    if lat != 0 and lng != 0:\n        print(f\"\u2705 Event already has coordinates: {lat}, {lng}\")\n        return event_data\n\n    # Try to get location from various fields\n    location_sources = [\n        event_data.get('address', ''),\n        event_data.get('venue_name', ''),\n        event_data.get('location', ''),\n        event_data.get('city', '')\n    ]\n\n    # Find first non-empty location\n    location = next((loc for loc in location_sources if loc.strip()), None)\n\n    if location:\n        coords = geocoder.geocode(location)\n        if coords:\n            event_data['latitude'] = coords[0]\n            event_data['longitude'] = coords[1]\n            event_data['geocoded_from'] = location\n            print(f\"\ud83d\uddfa\ufe0f Added coordinates from '{location}'\")\n        else:\n            print(f\"\u26a0\ufe0f Could not geocode: {location}\")\n            # Set default coordinates (Paris center)\n            event_data['latitude'] = 48.8566\n            event_data['longitude'] = 2.3522\n            event_data['geocoded_from'] = 'default_paris'\n\n    return event_data\n</code></pre>"},{"location":"components/geocoder/#geocoding-workflow","title":"\ud83d\udd04 Geocoding Workflow","text":"<pre><code>sequenceDiagram\n    participant Event as Event Data\n    participant Processor as Event Processor\n    participant Cache as Local Cache\n    participant Geocoder as Geocoder\n    participant Nominatim as Nominatim API\n\n    Event-&gt;&gt;Processor: Raw event data\n    Processor-&gt;&gt;Processor: Check existing coordinates\n\n    alt Has coordinates\n        Processor--&gt;&gt;Event: Return with existing coords\n    else No coordinates\n        Processor-&gt;&gt;Processor: Extract location string\n        Processor-&gt;&gt;Cache: Check cache\n\n        alt Cache hit\n            Cache--&gt;&gt;Processor: Return cached coords\n        else Cache miss\n            Processor-&gt;&gt;Geocoder: geocode(address)\n            Geocoder-&gt;&gt;Nominatim: HTTP request\n            Nominatim--&gt;&gt;Geocoder: JSON response\n            Geocoder-&gt;&gt;Cache: Store result\n            Geocoder--&gt;&gt;Processor: Coordinates\n        end\n\n        Processor-&gt;&gt;Event: Add coordinates to event\n    end</code></pre>"},{"location":"components/geocoder/#supported-address-formats","title":"\ud83c\udf0d Supported Address Formats","text":""},{"location":"components/geocoder/#successful-geocoding-examples","title":"Successful Geocoding Examples","text":"<pre><code># Test cases that work well with Nominatim\ntest_cases = [\n    # Full addresses\n    \"15 rue de milan, 75009 Paris, France\",\n    \"226 Rue Saint-Denis, 75002 Paris\",\n\n    # Landmarks and venues\n    \"Eiffel Tower, Paris\",\n    \"Louvre Museum, Paris\",\n    \"Notre-Dame Cathedral, Paris\",\n\n    # Business venues\n    \"Station F, Paris\",\n    \"Le Trianon, Paris\",\n    \"Palais des Congr\u00e8s, Paris\",\n\n    # Areas and districts\n    \"Montmartre, Paris\",\n    \"Marais District, Paris\",\n    \"Champs-\u00c9lys\u00e9es, Paris\",\n\n    # With postal codes\n    \"75001 Paris, France\",\n    \"R\u00e9publique, 75003 Paris\",\n\n    # International addresses\n    \"Times Square, New York, USA\",\n    \"Piccadilly Circus, London, UK\",\n    \"Brandenburg Gate, Berlin, Germany\"\n]\n</code></pre>"},{"location":"components/geocoder/#address-quality-assessment","title":"Address Quality Assessment","text":"<pre><code>graph TB\n    subgraph \"High Quality (90%+ success)\"\n        HQ1[Full Street Address]\n        HQ2[Famous Landmarks]\n        HQ3[With Postal Codes]\n    end\n\n    subgraph \"Medium Quality (70%+ success)\"\n        MQ1[Venue Names]\n        MQ2[District Names]\n        MQ3[Metro Stations]\n    end\n\n    subgraph \"Low Quality (30%+ success)\"\n        LQ1[Vague Descriptions]\n        LQ2[Incomplete Addresses]\n        LQ3[Non-standard Formats]\n    end\n\n    style HQ1 fill:#e8f5e8\n    style MQ1 fill:#fff3e0\n    style LQ1 fill:#ffebee</code></pre>"},{"location":"components/geocoder/#performance-optimization","title":"\ud83d\ude80 Performance Optimization","text":""},{"location":"components/geocoder/#caching-strategy","title":"Caching Strategy","text":"<pre><code>class CachedGeocoder(FreeGeocoder):\n    \"\"\"Enhanced geocoder with persistent caching\"\"\"\n\n    def __init__(self, cache_file=\"geocode_cache.json\"):\n        super().__init__()\n        self.cache_file = cache_file\n        self.load_cache()\n\n    def load_cache(self):\n        \"\"\"Load cache from file\"\"\"\n        try:\n            with open(self.cache_file, 'r') as f:\n                import json\n                self.cache = json.load(f)\n            print(f\"\ud83d\udcc2 Loaded {len(self.cache)} cached locations\")\n        except FileNotFoundError:\n            self.cache = {}\n\n    def save_cache(self):\n        \"\"\"Save cache to file\"\"\"\n        try:\n            with open(self.cache_file, 'w') as f:\n                import json\n                json.dump(self.cache, f, indent=2)\n            print(f\"\ud83d\udcbe Saved {len(self.cache)} locations to cache\")\n        except Exception as e:\n            print(f\"\u274c Cache save failed: {e}\")\n\n    def geocode(self, address: str) -&gt; Optional[Tuple[float, float]]:\n        \"\"\"Geocode with persistent caching\"\"\"\n        result = super().geocode(address)\n\n        # Save cache after each geocoding operation\n        if result and len(self.cache) % 10 == 0:  # Save every 10 new entries\n            self.save_cache()\n\n        return result\n</code></pre>"},{"location":"components/geocoder/#batch-geocoding","title":"Batch Geocoding","text":"<pre><code>def batch_geocode(addresses, batch_size=10):\n    \"\"\"Geocode multiple addresses with rate limiting\"\"\"\n\n    geocoder = CachedGeocoder()\n    results = {}\n\n    print(f\"\ud83d\udd04 Geocoding {len(addresses)} addresses...\")\n\n    for i, address in enumerate(addresses):\n        if i &gt; 0 and i % batch_size == 0:\n            print(f\"\ud83d\udcca Progress: {i}/{len(addresses)} completed\")\n            # Longer pause every batch_size requests\n            time.sleep(5)\n\n        coords = geocoder.geocode(address)\n        results[address] = coords\n\n        # Show progress for long lists\n        if len(addresses) &gt; 20 and i % 5 == 0:\n            print(f\"\u23f3 {i+1}/{len(addresses)} processed...\")\n\n    # Save final cache\n    geocoder.save_cache()\n\n    return results\n</code></pre>"},{"location":"components/geocoder/#testing-your-specific-address","title":"\ud83e\uddea Testing Your Specific Address","text":"<p>Let's test your specific address: \"15 rue de milan, paris\"</p> <pre><code># Test the specific address\ndef test_your_address():\n    \"\"\"Test geocoding for 15 rue de milan, paris\"\"\"\n\n    address = \"15 rue de milan, paris\"\n    coords = geocoder.geocode(address)\n\n    if coords:\n        lat, lng = coords\n        print(f\"\u2705 Success!\")\n        print(f\"\ud83d\udccd Address: {address}\")\n        print(f\"\ud83d\udccd Coordinates: {lat:.6f}, {lng:.6f}\")\n        print(f\"\ud83d\udccd Google Maps: https://maps.google.com/?q={lat},{lng}\")\n\n        # Verify it's in Paris (approximate bounds)\n        if 48.8 &lt;= lat &lt;= 48.9 and 2.2 &lt;= lng &lt;= 2.5:\n            print(\"\u2705 Coordinates are within Paris bounds\")\n        else:\n            print(\"\u26a0\ufe0f Coordinates seem outside Paris\")\n    else:\n        print(f\"\u274c Failed to geocode: {address}\")\n\n        # Try variations\n        variations = [\n            \"15 rue de Milan, Paris, France\",\n            \"15 Rue de Milan, 75009 Paris\",\n            \"rue de Milan, Paris\",\n            \"Milan Street, Paris\"\n        ]\n\n        print(\"\ud83d\udd04 Trying variations...\")\n        for variation in variations:\n            coords = geocoder.geocode(variation)\n            if coords:\n                print(f\"\u2705 Success with: {variation} \u2192 {coords}\")\n                break\n</code></pre>"},{"location":"components/geocoder/#alternative-geocoding-services","title":"\ud83c\udf10 Alternative Geocoding Services","text":""},{"location":"components/geocoder/#google-geocoding-api-premium","title":"Google Geocoding API (Premium)","text":"<pre><code>class GoogleGeocoder:\n    \"\"\"Google Geocoding API for higher accuracy\"\"\"\n\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.base_url = \"https://maps.googleapis.com/maps/api/geocode/json\"\n\n    def geocode(self, address: str) -&gt; Optional[Tuple[float, float]]:\n        \"\"\"Geocode using Google Maps API\"\"\"\n\n        params = {\n            'address': address,\n            'key': self.api_key\n        }\n\n        try:\n            response = requests.get(self.base_url, params=params)\n            data = response.json()\n\n            if data['status'] == 'OK' and data['results']:\n                location = data['results'][0]['geometry']['location']\n                return (location['lat'], location['lng'])\n\n        except Exception as e:\n            print(f\"Google geocoding error: {e}\")\n\n        return None\n</code></pre>"},{"location":"components/geocoder/#fallback-strategy","title":"Fallback Strategy","text":"<pre><code>def robust_geocode(address: str) -&gt; Optional[Tuple[float, float]]:\n    \"\"\"Try multiple geocoding services as fallback\"\"\"\n\n    # Try Nominatim first (free)\n    coords = geocoder.geocode(address)\n    if coords:\n        return coords\n\n    # If Google API key is available, try Google\n    google_api_key = os.getenv('GOOGLE_GEOCODING_API_KEY')\n    if google_api_key:\n        google_geocoder = GoogleGeocoder(google_api_key)\n        coords = google_geocoder.geocode(address)\n        if coords:\n            return coords\n\n    # If all fail, try to extract city and use city center\n    if 'paris' in address.lower():\n        return (48.8566, 2.3522)  # Paris center\n    elif 'london' in address.lower():\n        return (51.5074, -0.1278)  # London center\n\n    return None\n</code></pre>"},{"location":"components/geocoder/#quality-metrics","title":"\ud83d\udcca Quality Metrics","text":""},{"location":"components/geocoder/#geocoding-success-rate","title":"Geocoding Success Rate","text":"<pre><code>def analyze_geocoding_quality(addresses):\n    \"\"\"Analyze geocoding success rate and quality\"\"\"\n\n    results = {\n        'total': len(addresses),\n        'successful': 0,\n        'failed': 0,\n        'paris_area': 0,\n        'outside_paris': 0\n    }\n\n    for address in addresses:\n        coords = geocoder.geocode(address)\n\n        if coords:\n            results['successful'] += 1\n            lat, lng = coords\n\n            # Check if in Paris area (rough bounds)\n            if 48.8 &lt;= lat &lt;= 48.9 and 2.2 &lt;= lng &lt;= 2.5:\n                results['paris_area'] += 1\n            else:\n                results['outside_paris'] += 1\n        else:\n            results['failed'] += 1\n\n    # Calculate percentages\n    results['success_rate'] = (results['successful'] / results['total']) * 100\n\n    return results\n</code></pre> <p>This geocoding service provides reliable address-to-coordinate conversion with proper error handling, caching, and fallback strategies for robust event location processing.</p>"},{"location":"components/mongo_connector/","title":"MongoDB Connector","text":"<p>The MongoDB connector provides a simple, clean interface for interacting with MongoDB Atlas. It handles connections, data insertion, querying, and error management.</p>"},{"location":"components/mongo_connector/#overview","title":"\ud83d\udd17 Overview","text":"<pre><code>graph LR\n    APP[Application] --&gt; CONNECTOR[MongoConnector]\n    CONNECTOR --&gt; CLIENT[MongoDB Client]\n    CLIENT --&gt; ATLAS[(MongoDB Atlas)]\n\n    CONNECTOR --&gt; VALIDATION[Data Validation]\n    CONNECTOR --&gt; INDEXING[Index Management]\n    CONNECTOR --&gt; ERROR[Error Handling]\n\n    style CONNECTOR fill:#e8f5e8\n    style ATLAS fill:#e3f2fd</code></pre>"},{"location":"components/mongo_connector/#class-structure","title":"\ud83d\udccb Class Structure","text":"<pre><code>classDiagram\n    class MongoConnector {\n        -string uri\n        -MongoClient client\n        -Database db\n        -Collection collection\n\n        +__init__(password: str)\n        +insert_event(event_data: Dict) bool\n        +insert_many_events(events_list: List[Dict]) int\n        +find_events(city: str, category: str, limit: int) List[Dict]\n        +count_events() int\n        +close() void\n        -_test_connection() bool\n        -_create_indexes() void\n    }\n\n    class Event {\n        +string event_id\n        +string title\n        +string description\n        +datetime start_datetime\n        +float latitude\n        +float longitude\n        +string city\n        +string category\n        +string platform\n        +datetime scraped_at\n    }\n\n    MongoConnector --&gt; Event : manages</code></pre>"},{"location":"components/mongo_connector/#usage-examples","title":"\ud83d\ude80 Usage Examples","text":""},{"location":"components/mongo_connector/#basic-connection","title":"Basic Connection","text":"<pre><code>from mongo_connector import MongoConnector\n\n# Initialize connection\nmongo = MongoConnector(\"your_atlas_password\")\n\n# Test connection (automatic on initialization)\n# \u2705 Connected to MongoDB!\n</code></pre>"},{"location":"components/mongo_connector/#single-event-insertion","title":"Single Event Insertion","text":"<pre><code># Create event data\nevent = {\n    \"event_id\": \"tech_meetup_001\",\n    \"title\": \"Python Workshop\",\n    \"description\": \"Learn Python basics\",\n    \"start_datetime\": \"2025-09-15T18:00:00Z\",\n    \"latitude\": 48.8566,\n    \"longitude\": 2.3522,\n    \"city\": \"Paris\",\n    \"category\": \"Technology\",\n    \"platform\": \"Meetup\"\n}\n\n# Insert single event\nsuccess = mongo.insert_event(event)\nif success:\n    print(\"Event inserted successfully!\")\n</code></pre>"},{"location":"components/mongo_connector/#batch-event-insertion","title":"Batch Event Insertion","text":"<pre><code># Multiple events\nevents = [\n    {\n        \"event_id\": \"event_001\",\n        \"title\": \"AI Conference\",\n        \"latitude\": 48.8566,\n        \"longitude\": 2.3522,\n        \"city\": \"Paris\",\n        \"category\": \"Technology\"\n    },\n    {\n        \"event_id\": \"event_002\", \n        \"title\": \"Art Exhibition\",\n        \"latitude\": 48.8606,\n        \"longitude\": 2.3376,\n        \"city\": \"Paris\",\n        \"category\": \"Art\"\n    }\n]\n\n# Batch insert\ninserted_count = mongo.insert_many_events(events)\nprint(f\"Inserted {inserted_count} events\")\n</code></pre>"},{"location":"components/mongo_connector/#querying-events","title":"Querying Events","text":"<pre><code># Find events by city\nparis_events = mongo.find_events(city=\"Paris\", limit=10)\nprint(f\"Found {len(paris_events)} events in Paris\")\n\n# Find events by category\ntech_events = mongo.find_events(category=\"Technology\", limit=5)\n\n# Find all events (no filters)\nall_events = mongo.find_events(limit=50)\n\n# Count total events\ntotal = mongo.count_events()\nprint(f\"Total events in database: {total}\")\n</code></pre>"},{"location":"components/mongo_connector/#data-flow","title":"\ud83d\udd04 Data Flow","text":"<pre><code>sequenceDiagram\n    participant App as Application\n    participant Connector as MongoConnector\n    participant Client as MongoDB Client\n    participant Atlas as MongoDB Atlas\n\n    App-&gt;&gt;Connector: insert_event(data)\n    Connector-&gt;&gt;Connector: Validate data\n\n    alt Data is valid\n        Connector-&gt;&gt;Connector: Add timestamp\n        Connector-&gt;&gt;Client: insert_one(document)\n        Client-&gt;&gt;Atlas: Insert document\n        Atlas--&gt;&gt;Client: Acknowledge\n        Client--&gt;&gt;Connector: InsertResult\n        Connector--&gt;&gt;App: True (success)\n    else Data is invalid\n        Connector--&gt;&gt;App: False (failure)\n    end\n\n    Note over App,Atlas: Error handling at each step</code></pre>"},{"location":"components/mongo_connector/#configuration","title":"\u2699\ufe0f Configuration","text":""},{"location":"components/mongo_connector/#connection-string-format","title":"Connection String Format","text":"<pre><code># MongoDB Atlas connection string template\nmongodb+srv://&lt;username&gt;:&lt;password&gt;@&lt;cluster&gt;.mongodb.net/&lt;database&gt;?retryWrites=true&amp;w=majority\n\n# Your specific format\nmongodb+srv://reetikagautam127:&lt;password&gt;@democluster.c5lpr.mongodb.net/events_db?retryWrites=true&amp;w=majority\n</code></pre>"},{"location":"components/mongo_connector/#environment-variables","title":"Environment Variables","text":"<pre><code># Recommended: Use environment variables\nimport os\nfrom mongo_connector import MongoConnector\n\npassword = os.getenv(\"MONGODB_PASSWORD\")\nmongo = MongoConnector(password)\n</code></pre>"},{"location":"components/mongo_connector/#database-schema","title":"\ud83d\udcca Database Schema","text":""},{"location":"components/mongo_connector/#event-document-structure","title":"Event Document Structure","text":"<pre><code>{\n  \"_id\": \"ObjectId('...')\",\n  \"event_id\": \"eventbrite_123456\",\n  \"title\": \"Python Workshop Paris\",\n  \"description\": \"Learn Python programming basics...\",\n  \"start_datetime\": \"2025-09-15T18:00:00Z\",\n  \"end_datetime\": \"2025-09-15T20:00:00Z\",\n  \"timezone\": \"Europe/Paris\",\n  \"event_url\": \"https://eventbrite.com/e/123456\",\n  \"platform\": \"Eventbrite\",\n  \"is_online\": false,\n  \"price\": 25.0,\n  \"currency\": \"EUR\",\n  \"venue_name\": \"Tech Hub Paris\",\n  \"address\": \"123 Tech Street, Paris\",\n  \"city\": \"Paris\",\n  \"postal_code\": \"75001\",\n  \"latitude\": 48.8566,\n  \"longitude\": 2.3522,\n  \"organizer_name\": \"Python Paris\",\n  \"category\": \"Technology\",\n  \"tags\": [\"python\", \"programming\", \"workshop\"],\n  \"image_url\": \"https://img.evbuc.com/image.jpg\",\n  \"scraped_at\": \"2025-08-31T14:22:01Z\",\n  \"source_site\": \"eventbrite.com\"\n}\n</code></pre>"},{"location":"components/mongo_connector/#required-vs-optional-fields","title":"Required vs Optional Fields","text":"<pre><code>graph TB\n    subgraph \"Required Fields\"\n        R1[event_id]\n        R2[title]\n        R3[latitude]\n        R4[longitude]\n        R5[scraped_at]\n    end\n\n    subgraph \"Optional Fields\"\n        O1[description]\n        O2[start_datetime]\n        O3[venue_name]\n        O4[category]\n        O5[price]\n        O6[image_url]\n        O7[organizer_name]\n        O8[tags]\n    end\n\n    subgraph \"Auto-Generated\"\n        A1[_id]\n        A2[scraped_at timestamp]\n    end\n\n    style R1 fill:#ffebee\n    style O1 fill:#e8f5e8\n    style A1 fill:#e3f2fd</code></pre>"},{"location":"components/mongo_connector/#indexing-strategy","title":"\ud83d\udd0d Indexing Strategy","text":""},{"location":"components/mongo_connector/#automatic-index-creation","title":"Automatic Index Creation","text":"<p>The connector automatically creates these indexes for optimal performance:</p> <pre><code># Primary index (unique)\ncollection.create_index(\"event_id\", unique=True)\n\n# Geospatial queries\ncollection.create_index([(\"latitude\", 1), (\"longitude\", 1)])\n\n# Common search fields\ncollection.create_index(\"city\")\ncollection.create_index(\"category\") \ncollection.create_index(\"start_datetime\")\ncollection.create_index(\"platform\")\n\n# Compound index for complex queries\ncollection.create_index([\n    (\"city\", 1),\n    (\"start_datetime\", 1), \n    (\"category\", 1)\n])\n</code></pre>"},{"location":"components/mongo_connector/#query-performance","title":"Query Performance","text":"<pre><code>graph LR\n    subgraph \"Fast Queries (Indexed)\"\n        F1[city = 'Paris']\n        F2[category = 'Technology']\n        F3[event_id = 'unique_id']\n        F4[lat/lng within radius]\n    end\n\n    subgraph \"Slower Queries (Full Scan)\"\n        S1[description contains 'python']\n        S2[title regex search]\n        S3[Complex aggregations]\n    end\n\n    style F1 fill:#e8f5e8\n    style S1 fill:#fff3e0</code></pre>"},{"location":"components/mongo_connector/#error-handling","title":"\ud83d\udee1\ufe0f Error Handling","text":""},{"location":"components/mongo_connector/#connection-errors","title":"Connection Errors","text":"<pre><code>try:\n    mongo = MongoConnector(\"invalid_password\")\nexcept Exception as e:\n    print(f\"Connection failed: {e}\")\n    # Handle connection failure\n</code></pre>"},{"location":"components/mongo_connector/#insertion-errors","title":"Insertion Errors","text":"<pre><code># Duplicate event handling\nsuccess = mongo.insert_event(duplicate_event)\nif not success:\n    print(\"Event already exists or insertion failed\")\n\n# Batch insertion with error tracking\ninserted_count = mongo.insert_many_events(events)\nif inserted_count &lt; len(events):\n    print(f\"Some events failed: {len(events) - inserted_count} errors\")\n</code></pre>"},{"location":"components/mongo_connector/#network-errors","title":"Network Errors","text":"<pre><code># Automatic retry with exponential backoff\nfrom time import sleep\nimport random\n\ndef robust_insert(mongo, event, max_retries=3):\n    for attempt in range(max_retries):\n        try:\n            return mongo.insert_event(event)\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise e\n            sleep(2 ** attempt + random.uniform(0, 1))\n    return False\n</code></pre>"},{"location":"components/mongo_connector/#advanced-usage","title":"\ud83d\udd27 Advanced Usage","text":""},{"location":"components/mongo_connector/#custom-queries","title":"Custom Queries","text":"<pre><code># Direct MongoDB operations\nfrom pymongo import MongoClient\n\n# Access the raw collection\nraw_collection = mongo.collection\n\n# Custom aggregation\npipeline = [\n    {\"$match\": {\"city\": \"Paris\"}},\n    {\"$group\": {\"_id\": \"$category\", \"count\": {\"$sum\": 1}}},\n    {\"$sort\": {\"count\": -1}}\n]\n\ncategory_stats = list(raw_collection.aggregate(pipeline))\n</code></pre>"},{"location":"components/mongo_connector/#geospatial-queries","title":"Geospatial Queries","text":"<pre><code># Find events near a location (requires 2dsphere index)\nnear_events = mongo.collection.find({\n    \"location\": {\n        \"$near\": {\n            \"$geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [2.3522, 48.8566]  # [lng, lat]\n            },\n            \"$maxDistance\": 1000  # meters\n        }\n    }\n})\n</code></pre>"},{"location":"components/mongo_connector/#monitoring-and-metrics","title":"\ud83d\udcc8 Monitoring and Metrics","text":""},{"location":"components/mongo_connector/#connection-health-check","title":"Connection Health Check","text":"<pre><code>def health_check(mongo):\n    \"\"\"Check if MongoDB connection is healthy\"\"\"\n    try:\n        # Simple ping test\n        mongo.client.admin.command('ping')\n\n        # Test basic operations\n        test_count = mongo.count_events()\n\n        return {\n            \"status\": \"healthy\",\n            \"total_events\": test_count,\n            \"connection\": \"active\"\n        }\n    except Exception as e:\n        return {\n            \"status\": \"unhealthy\", \n            \"error\": str(e),\n            \"connection\": \"failed\"\n        }\n</code></pre>"},{"location":"components/mongo_connector/#performance-metrics","title":"Performance Metrics","text":"<pre><code>import time\n\ndef timed_operation(func, *args, **kwargs):\n    \"\"\"Measure operation execution time\"\"\"\n    start = time.time()\n    result = func(*args, **kwargs)\n    duration = time.time() - start\n\n    print(f\"Operation took {duration:.3f} seconds\")\n    return result\n\n# Usage\ninserted = timed_operation(mongo.insert_many_events, events)\n</code></pre>"},{"location":"components/mongo_connector/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"components/mongo_connector/#unit-tests","title":"Unit Tests","text":"<pre><code>import unittest\nfrom mongo_connector import MongoConnector\n\nclass TestMongoConnector(unittest.TestCase):\n    def setUp(self):\n        self.mongo = MongoConnector(\"test_password\")\n\n    def test_event_insertion(self):\n        event = {\n            \"event_id\": \"test_001\",\n            \"title\": \"Test Event\",\n            \"latitude\": 48.8566,\n            \"longitude\": 2.3522\n        }\n\n        result = self.mongo.insert_event(event)\n        self.assertTrue(result)\n\n    def test_event_retrieval(self):\n        events = self.mongo.find_events(limit=1)\n        self.assertIsInstance(events, list)\n\n    def tearDown(self):\n        self.mongo.close()\n</code></pre>"},{"location":"components/mongo_connector/#integration-tests","title":"Integration Tests","text":"<pre><code>def test_full_workflow():\n    \"\"\"Test complete event processing workflow\"\"\"\n\n    # 1. Connect\n    mongo = MongoConnector(\"test_password\")\n\n    # 2. Insert test data\n    test_events = generate_test_events(10)\n    inserted = mongo.insert_many_events(test_events)\n    assert inserted == 10\n\n    # 3. Query data\n    results = mongo.find_events(city=\"Test City\")\n    assert len(results) &gt; 0\n\n    # 4. Cleanup\n    mongo.close()\n</code></pre> <p>This MongoDB connector provides a robust foundation for event data management with proper error handling, performance optimization, and ease of use.</p>"},{"location":"mcp/eventbrite/","title":"Eventbrite MCP Server","text":"<p>This document provides comprehensive documentation for the Eventbrite Model Context Protocol (MCP) server integration in Inttrest, covering setup, configuration, and usage.</p>"},{"location":"mcp/eventbrite/#overview","title":"\ud83c\udfaf Overview","text":"<p>The Eventbrite MCP server provides seamless integration with Eventbrite's event platform, allowing Inttrest to discover, fetch, and synchronize event data from one of the world's largest event platforms.</p> <pre><code>graph TB\n    subgraph \"Eventbrite MCP Architecture\"\n        A[MCP Client] --&gt; B[Eventbrite MCP Server]\n        B --&gt; C[Eventbrite API]\n        B --&gt; D[Data Processing]\n        B --&gt; E[Event Normalization]\n\n        D --&gt; F[Event Filtering]\n        D --&gt; G[Geocoding]\n        D --&gt; H[Category Mapping]\n\n        E --&gt; I[Standardized Event Data]\n\n        C --&gt; J[Event Search API]\n        C --&gt; K[Event Details API]\n        C --&gt; L[Organization API]\n        C --&gt; M[Venue API]\n    end\n\n    subgraph \"Inttrest Integration\"\n        N[AI Chat Interface] --&gt; A\n        O[Event Discovery] --&gt; A\n        P[Map Component] --&gt; A\n\n        I --&gt; Q[MongoDB Storage]\n        I --&gt; R[Real-time Updates]\n        I --&gt; S[User Interface]\n    end\n\n    style B fill:#e3f2fd\n    style C fill:#e8f5e8\n    style I fill:#fff3e0</code></pre>"},{"location":"mcp/eventbrite/#installation-setup","title":"\ud83d\udce6 Installation &amp; Setup","text":""},{"location":"mcp/eventbrite/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 18+ with npm/pnpm</li> <li>Eventbrite API Key (OAuth token)</li> <li>MCP SDK (@modelcontextprotocol/sdk)</li> </ul>"},{"location":"mcp/eventbrite/#installation","title":"Installation","text":"<pre><code># Navigate to MCP servers directory\ncd mcp_servers/eventbrite-mcp\n\n# Install dependencies\nnpm install\n# or\npnpm install\n\n# Build the server\nnpm run build\n</code></pre>"},{"location":"mcp/eventbrite/#configuration","title":"Configuration","text":"<p>Create a <code>.env</code> file in the <code>eventbrite-mcp</code> directory:</p> <pre><code># Eventbrite API Configuration\nEVENTBRITE_API_KEY=your_eventbrite_oauth_token_here\nEVENTBRITE_API_BASE_URL=https://www.eventbriteapi.com/v3\n\n# MCP Server Configuration\nMCP_SERVER_PORT=3001\nMCP_SERVER_HOST=localhost\n\n# Cache Configuration\nCACHE_TTL=300000  # 5 minutes in milliseconds\nCACHE_MAX_SIZE=1000\n\n# Rate Limiting\nRATE_LIMIT_REQUESTS=100\nRATE_LIMIT_WINDOW=60000  # 1 minute\n\n# Logging\nLOG_LEVEL=info\nLOG_FILE=eventbrite-mcp.log\n</code></pre>"},{"location":"mcp/eventbrite/#package-dependencies","title":"Package Dependencies","text":"<pre><code>{\n  \"name\": \"eventbrite-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n    \"axios\": \"^1.6.0\",\n    \"node-cache\": \"^5.1.2\",\n    \"winston\": \"^3.11.0\",\n    \"zod\": \"^4.1.5\",\n    \"dotenv\": \"^16.3.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"tsx\": \"^4.0.0\"\n  }\n}\n</code></pre>"},{"location":"mcp/eventbrite/#server-implementation","title":"\ud83c\udfd7\ufe0f Server Implementation","text":""},{"location":"mcp/eventbrite/#core-server-structure","title":"Core Server Structure","text":"<pre><code>// src/eventbrite-mcp-server.ts\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js'\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js'\nimport { EventbriteAPI } from './api/eventbrite-api.js'\nimport { EventProcessor } from './processors/event-processor.js'\nimport { Logger } from './utils/logger.js'\nimport { z } from 'zod'\n\nconst logger = new Logger('EventbriteMCP')\n\nclass EventbriteMCPServer {\n  private server: Server\n  private eventbriteAPI: EventbriteAPI\n  private eventProcessor: EventProcessor\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'eventbrite-mcp-server',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    )\n\n    this.eventbriteAPI = new EventbriteAPI({\n      apiKey: process.env.EVENTBRITE_API_KEY!,\n      baseUrl: process.env.EVENTBRITE_API_BASE_URL!,\n    })\n\n    this.eventProcessor = new EventProcessor()\n    this.setupToolHandlers()\n  }\n\n  private setupToolHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: 'search_events',\n            description: 'Search for events on Eventbrite',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                q: {\n                  type: 'string',\n                  description: 'Search query for events'\n                },\n                location: {\n                  type: 'string',\n                  description: 'Location to search for events (city, address, etc.)'\n                },\n                categories: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Event categories to filter by'\n                },\n                start_date: {\n                  type: 'string',\n                  description: 'Start date filter (ISO format)'\n                },\n                end_date: {\n                  type: 'string',\n                  description: 'End date filter (ISO format)'\n                },\n                price: {\n                  type: 'string',\n                  enum: ['free', 'paid'],\n                  description: 'Price filter'\n                },\n                sort_by: {\n                  type: 'string',\n                  enum: ['date', 'relevance', 'distance'],\n                  description: 'Sort order for results'\n                },\n                limit: {\n                  type: 'number',\n                  minimum: 1,\n                  maximum: 100,\n                  description: 'Maximum number of events to return'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'get_event_details',\n            description: 'Get detailed information about a specific event',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                event_id: {\n                  type: 'string',\n                  description: 'Eventbrite event ID'\n                }\n              },\n              required: ['event_id']\n            }\n          },\n          {\n            name: 'get_event_categories',\n            description: 'Get list of available event categories',\n            inputSchema: {\n              type: 'object',\n              properties: {},\n              required: []\n            }\n          },\n          {\n            name: 'search_venues',\n            description: 'Search for venues on Eventbrite',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                location: {\n                  type: 'string',\n                  description: 'Location to search for venues'\n                },\n                q: {\n                  type: 'string',\n                  description: 'Search query for venues'\n                }\n              },\n              required: []\n            }\n          }\n        ]\n      }\n    })\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      try {\n        const { name, arguments: args } = request.params\n\n        switch (name) {\n          case 'search_events':\n            return await this.handleSearchEvents(args)\n\n          case 'get_event_details':\n            return await this.handleGetEventDetails(args)\n\n          case 'get_event_categories':\n            return await this.handleGetEventCategories(args)\n\n          case 'search_venues':\n            return await this.handleSearchVenues(args)\n\n          default:\n            throw new Error(`Unknown tool: ${name}`)\n        }\n      } catch (error) {\n        logger.error('Tool execution failed:', error)\n        throw error\n      }\n    })\n  }\n\n  private async handleSearchEvents(args: any) {\n    const searchParams = EventSearchSchema.parse(args)\n\n    logger.info('Searching events with params:', searchParams)\n\n    const events = await this.eventbriteAPI.searchEvents(searchParams)\n    const processedEvents = await this.eventProcessor.processEvents(events)\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${processedEvents.length} events from Eventbrite`\n        }\n      ],\n      _meta: {\n        source: 'eventbrite',\n        count: processedEvents.length,\n        events: processedEvents\n      }\n    }\n  }\n\n  private async handleGetEventDetails(args: any) {\n    const { event_id } = EventDetailsSchema.parse(args)\n\n    logger.info('Fetching event details for:', event_id)\n\n    const eventDetails = await this.eventbriteAPI.getEventDetails(event_id)\n    const processedEvent = await this.eventProcessor.processEvent(eventDetails)\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Event details retrieved for: ${processedEvent.title}`\n        }\n      ],\n      _meta: {\n        source: 'eventbrite',\n        event: processedEvent\n      }\n    }\n  }\n\n  private async handleGetEventCategories(args: any) {\n    logger.info('Fetching event categories')\n\n    const categories = await this.eventbriteAPI.getCategories()\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Retrieved ${categories.length} event categories`\n        }\n      ],\n      _meta: {\n        source: 'eventbrite',\n        categories: categories\n      }\n    }\n  }\n\n  private async handleSearchVenues(args: any) {\n    const searchParams = VenueSearchSchema.parse(args)\n\n    logger.info('Searching venues with params:', searchParams)\n\n    const venues = await this.eventbriteAPI.searchVenues(searchParams)\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${venues.length} venues`\n        }\n      ],\n      _meta: {\n        source: 'eventbrite',\n        venues: venues\n      }\n    }\n  }\n\n  async start() {\n    const transport = new StdioServerTransport()\n    await this.server.connect(transport)\n    logger.info('Eventbrite MCP Server started successfully')\n  }\n}\n\n// Schema definitions\nconst EventSearchSchema = z.object({\n  q: z.string().optional(),\n  location: z.string().optional(),\n  categories: z.array(z.string()).optional(),\n  start_date: z.string().optional(),\n  end_date: z.string().optional(),\n  price: z.enum(['free', 'paid']).optional(),\n  sort_by: z.enum(['date', 'relevance', 'distance']).optional(),\n  limit: z.number().min(1).max(100).optional()\n})\n\nconst EventDetailsSchema = z.object({\n  event_id: z.string()\n})\n\nconst VenueSearchSchema = z.object({\n  location: z.string().optional(),\n  q: z.string().optional()\n})\n\n// Start the server\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const server = new EventbriteMCPServer()\n  server.start().catch(console.error)\n}\n\nexport { EventbriteMCPServer }\n</code></pre>"},{"location":"mcp/eventbrite/#eventbrite-api-client","title":"Eventbrite API Client","text":"<pre><code>// src/api/eventbrite-api.ts\nimport axios, { AxiosInstance } from 'axios'\nimport NodeCache from 'node-cache'\nimport { Logger } from '../utils/logger.js'\n\ninterface EventbriteConfig {\n  apiKey: string\n  baseUrl: string\n  timeout?: number\n}\n\ninterface EventSearchParams {\n  q?: string\n  location?: string\n  categories?: string[]\n  start_date?: string\n  end_date?: string\n  price?: 'free' | 'paid'\n  sort_by?: 'date' | 'relevance' | 'distance'\n  limit?: number\n}\n\ninterface VenueSearchParams {\n  location?: string\n  q?: string\n}\n\nexport class EventbriteAPI {\n  private client: AxiosInstance\n  private cache: NodeCache\n  private logger: Logger\n\n  constructor(config: EventbriteConfig) {\n    this.logger = new Logger('EventbriteAPI')\n\n    this.client = axios.create({\n      baseURL: config.baseUrl,\n      timeout: config.timeout || 30000,\n      headers: {\n        'Authorization': `Bearer ${config.apiKey}`,\n        'Content-Type': 'application/json'\n      }\n    })\n\n    this.cache = new NodeCache({\n      stdTTL: parseInt(process.env.CACHE_TTL || '300'), // 5 minutes\n      maxKeys: parseInt(process.env.CACHE_MAX_SIZE || '1000')\n    })\n\n    this.setupInterceptors()\n  }\n\n  private setupInterceptors() {\n    // Request interceptor for logging\n    this.client.interceptors.request.use(\n      (config) =&gt; {\n        this.logger.debug(`API Request: ${config.method?.toUpperCase()} ${config.url}`)\n        return config\n      },\n      (error) =&gt; {\n        this.logger.error('API Request Error:', error)\n        return Promise.reject(error)\n      }\n    )\n\n    // Response interceptor for logging and error handling\n    this.client.interceptors.response.use(\n      (response) =&gt; {\n        this.logger.debug(`API Response: ${response.status} ${response.config.url}`)\n        return response\n      },\n      (error) =&gt; {\n        this.logger.error('API Response Error:', {\n          status: error.response?.status,\n          statusText: error.response?.statusText,\n          url: error.config?.url\n        })\n        return Promise.reject(error)\n      }\n    )\n  }\n\n  async searchEvents(params: EventSearchParams) {\n    const cacheKey = `events:${JSON.stringify(params)}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      this.logger.debug('Returning cached events')\n      return cached\n    }\n\n    try {\n      const queryParams: any = {}\n\n      if (params.q) queryParams.q = params.q\n      if (params.location) queryParams['location.address'] = params.location\n      if (params.categories?.length) queryParams.categories = params.categories.join(',')\n      if (params.start_date) queryParams['start_date.range_start'] = params.start_date\n      if (params.end_date) queryParams['start_date.range_end'] = params.end_date\n      if (params.price === 'free') queryParams.price = 'free'\n      if (params.price === 'paid') queryParams.price = 'paid'\n      if (params.sort_by) queryParams.sort_by = params.sort_by\n\n      queryParams.expand = 'venue,category,subcategory,organizer'\n      queryParams.page_size = Math.min(params.limit || 50, 100)\n\n      const response = await this.client.get('/events/search/', {\n        params: queryParams\n      })\n\n      const events = response.data.events || []\n      this.cache.set(cacheKey, events)\n\n      this.logger.info(`Found ${events.length} events`)\n      return events\n\n    } catch (error) {\n      this.logger.error('Event search failed:', error)\n      throw new Error(`Failed to search events: ${error.message}`)\n    }\n  }\n\n  async getEventDetails(eventId: string) {\n    const cacheKey = `event:${eventId}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      this.logger.debug('Returning cached event details')\n      return cached\n    }\n\n    try {\n      const response = await this.client.get(`/events/${eventId}/`, {\n        params: {\n          expand: 'venue,category,subcategory,organizer,ticket_availability,logo'\n        }\n      })\n\n      const event = response.data\n      this.cache.set(cacheKey, event, 600) // Cache for 10 minutes\n\n      this.logger.info(`Retrieved details for event: ${event.name?.text}`)\n      return event\n\n    } catch (error) {\n      this.logger.error('Event details fetch failed:', error)\n      throw new Error(`Failed to get event details: ${error.message}`)\n    }\n  }\n\n  async getCategories() {\n    const cacheKey = 'categories'\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      this.logger.debug('Returning cached categories')\n      return cached\n    }\n\n    try {\n      const response = await this.client.get('/categories/')\n      const categories = response.data.categories || []\n\n      // Cache for 1 hour since categories don't change often\n      this.cache.set(cacheKey, categories, 3600)\n\n      this.logger.info(`Retrieved ${categories.length} categories`)\n      return categories\n\n    } catch (error) {\n      this.logger.error('Categories fetch failed:', error)\n      throw new Error(`Failed to get categories: ${error.message}`)\n    }\n  }\n\n  async searchVenues(params: VenueSearchParams) {\n    const cacheKey = `venues:${JSON.stringify(params)}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      this.logger.debug('Returning cached venues')\n      return cached\n    }\n\n    try {\n      const queryParams: any = {}\n\n      if (params.location) queryParams['location.address'] = params.location\n      if (params.q) queryParams.q = params.q\n\n      const response = await this.client.get('/venues/search/', {\n        params: queryParams\n      })\n\n      const venues = response.data.venues || []\n      this.cache.set(cacheKey, venues)\n\n      this.logger.info(`Found ${venues.length} venues`)\n      return venues\n\n    } catch (error) {\n      this.logger.error('Venue search failed:', error)\n      throw new Error(`Failed to search venues: ${error.message}`)\n    }\n  }\n\n  async getVenueDetails(venueId: string) {\n    const cacheKey = `venue:${venueId}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      return cached\n    }\n\n    try {\n      const response = await this.client.get(`/venues/${venueId}/`)\n      const venue = response.data\n\n      this.cache.set(cacheKey, venue, 1800) // Cache for 30 minutes\n      return venue\n\n    } catch (error) {\n      this.logger.error('Venue details fetch failed:', error)\n      throw new Error(`Failed to get venue details: ${error.message}`)\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/eventbrite/#event-data-processing","title":"Event Data Processing","text":"<pre><code>// src/processors/event-processor.ts\nimport { Logger } from '../utils/logger.js'\n\ninterface StandardEvent {\n  id: string\n  title: string\n  description: string\n  url: string\n  start_date: string\n  end_date?: string\n  timezone: string\n  is_online: boolean\n  location?: {\n    name: string\n    address: string\n    city: string\n    region: string\n    country: string\n    latitude?: number\n    longitude?: number\n  }\n  organizer: {\n    name: string\n    description?: string\n    url?: string\n  }\n  category: {\n    id: string\n    name: string\n    short_name: string\n  }\n  subcategory?: {\n    id: string\n    name: string\n  }\n  image_url?: string\n  ticket_info: {\n    is_free: boolean\n    currency?: string\n    minimum_price?: number\n    maximum_price?: number\n    sales_status: string\n  }\n  capacity?: number\n  attendance_count?: number\n  source: string\n  source_id: string\n  created_at: string\n  updated_at: string\n}\n\nexport class EventProcessor {\n  private logger: Logger\n\n  constructor() {\n    this.logger = new Logger('EventProcessor')\n  }\n\n  async processEvents(rawEvents: any[]): Promise&lt;StandardEvent[]&gt; {\n    this.logger.info(`Processing ${rawEvents.length} events`)\n\n    const processedEvents = await Promise.all(\n      rawEvents.map(event =&gt; this.processEvent(event))\n    )\n\n    return processedEvents.filter(event =&gt; event !== null) as StandardEvent[]\n  }\n\n  async processEvent(rawEvent: any): Promise&lt;StandardEvent | null&gt; {\n    try {\n      // Handle different event data structures from Eventbrite\n      const event = this.normalizeEventStructure(rawEvent)\n\n      const standardEvent: StandardEvent = {\n        id: `eventbrite_${event.id}`,\n        title: this.extractText(event.name),\n        description: this.extractText(event.description) || '',\n        url: event.url || '',\n        start_date: event.start?.utc || event.start_date,\n        end_date: event.end?.utc || event.end_date,\n        timezone: event.start?.timezone || 'UTC',\n        is_online: event.is_online_event || false,\n        location: this.processLocation(event.venue),\n        organizer: this.processOrganizer(event.organizer),\n        category: this.processCategory(event.category),\n        subcategory: this.processSubcategory(event.subcategory),\n        image_url: this.extractImageUrl(event.logo),\n        ticket_info: this.processTicketInfo(event),\n        capacity: event.capacity_integer,\n        attendance_count: event.attendance_count,\n        source: 'eventbrite',\n        source_id: event.id,\n        created_at: event.created,\n        updated_at: event.changed\n      }\n\n      this.logger.debug(`Processed event: ${standardEvent.title}`)\n      return standardEvent\n\n    } catch (error) {\n      this.logger.error('Failed to process event:', error)\n      return null\n    }\n  }\n\n  private normalizeEventStructure(event: any): any {\n    // Handle different API response formats\n    if (event.event) {\n      return event.event\n    }\n    return event\n  }\n\n  private extractText(textObject: any): string {\n    if (typeof textObject === 'string') {\n      return textObject\n    }\n    if (textObject?.text) {\n      return textObject.text\n    }\n    if (textObject?.html) {\n      // Strip HTML tags\n      return textObject.html.replace(/&lt;[^&gt;]*&gt;/g, '')\n    }\n    return ''\n  }\n\n  private processLocation(venue: any): StandardEvent['location'] | undefined {\n    if (!venue) return undefined\n\n    return {\n      name: venue.name || '',\n      address: venue.address?.localized_address_display || \n               venue.address?.address_1 || '',\n      city: venue.address?.city || '',\n      region: venue.address?.region || '',\n      country: venue.address?.country || '',\n      latitude: venue.latitude ? parseFloat(venue.latitude) : undefined,\n      longitude: venue.longitude ? parseFloat(venue.longitude) : undefined\n    }\n  }\n\n  private processOrganizer(organizer: any): StandardEvent['organizer'] {\n    return {\n      name: organizer?.name || 'Unknown Organizer',\n      description: this.extractText(organizer?.description),\n      url: organizer?.url\n    }\n  }\n\n  private processCategory(category: any): StandardEvent['category'] {\n    return {\n      id: category?.id || 'other',\n      name: category?.name || 'Other',\n      short_name: category?.short_name || category?.name || 'Other'\n    }\n  }\n\n  private processSubcategory(subcategory: any): StandardEvent['subcategory'] | undefined {\n    if (!subcategory) return undefined\n\n    return {\n      id: subcategory.id,\n      name: subcategory.name\n    }\n  }\n\n  private extractImageUrl(logo: any): string | undefined {\n    if (!logo) return undefined\n\n    // Eventbrite logos have different sizes\n    if (logo.crop_mask?.width &amp;&amp; logo.crop_mask?.height) {\n      return logo.url\n    }\n\n    if (logo.original?.url) {\n      return logo.original.url\n    }\n\n    return logo.url\n  }\n\n  private processTicketInfo(event: any): StandardEvent['ticket_info'] {\n    const ticketInfo: StandardEvent['ticket_info'] = {\n      is_free: event.is_free || false,\n      sales_status: 'unknown'\n    }\n\n    // Process ticket availability\n    if (event.ticket_availability) {\n      ticketInfo.sales_status = event.ticket_availability.is_sold_out ? 'sold_out' : 'available'\n\n      if (!ticketInfo.is_free &amp;&amp; event.ticket_availability.minimum_price) {\n        ticketInfo.currency = event.ticket_availability.minimum_price.currency\n        ticketInfo.minimum_price = parseFloat(event.ticket_availability.minimum_price.major_value)\n      }\n\n      if (event.ticket_availability.maximum_price) {\n        ticketInfo.maximum_price = parseFloat(event.ticket_availability.maximum_price.major_value)\n      }\n    }\n\n    return ticketInfo\n  }\n}\n</code></pre>"},{"location":"mcp/eventbrite/#configuration-usage","title":"\ud83d\udd27 Configuration &amp; Usage","text":""},{"location":"mcp/eventbrite/#environment-configuration","title":"Environment Configuration","text":"<pre><code>// src/config/eventbrite-config.ts\nexport interface EventbriteConfig {\n  apiKey: string\n  baseUrl: string\n  timeout: number\n  cache: {\n    ttl: number\n    maxSize: number\n  }\n  rateLimit: {\n    requests: number\n    window: number\n  }\n  logging: {\n    level: string\n    file?: string\n  }\n}\n\nexport function loadConfig(): EventbriteConfig {\n  const requiredEnvVars = ['EVENTBRITE_API_KEY']\n\n  for (const envVar of requiredEnvVars) {\n    if (!process.env[envVar]) {\n      throw new Error(`Missing required environment variable: ${envVar}`)\n    }\n  }\n\n  return {\n    apiKey: process.env.EVENTBRITE_API_KEY!,\n    baseUrl: process.env.EVENTBRITE_API_BASE_URL || 'https://www.eventbriteapi.com/v3',\n    timeout: parseInt(process.env.API_TIMEOUT || '30000'),\n    cache: {\n      ttl: parseInt(process.env.CACHE_TTL || '300'),\n      maxSize: parseInt(process.env.CACHE_MAX_SIZE || '1000')\n    },\n    rateLimit: {\n      requests: parseInt(process.env.RATE_LIMIT_REQUESTS || '100'),\n      window: parseInt(process.env.RATE_LIMIT_WINDOW || '60000')\n    },\n    logging: {\n      level: process.env.LOG_LEVEL || 'info',\n      file: process.env.LOG_FILE\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/eventbrite/#running-the-server","title":"Running the Server","text":"<pre><code># Start the MCP server\nnpm start\n\n# Run in development mode with auto-reload\nnpm run dev\n\n# Run with debug logging\nLOG_LEVEL=debug npm start\n\n# Run with custom port\nMCP_SERVER_PORT=3001 npm start\n</code></pre>"},{"location":"mcp/eventbrite/#integration-with-inttrest","title":"Integration with Inttrest","text":"<pre><code>// Example usage in the main application\nimport { MCPClient } from '@modelcontextprotocol/sdk/client/index.js'\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'\n\nasync function setupEventbriteMCP() {\n  const transport = new StdioClientTransport({\n    command: 'node',\n    args: ['./mcp_servers/eventbrite-mcp/dist/eventbrite-mcp-server.js']\n  })\n\n  const client = new MCPClient(\n    {\n      name: 'inttrest-client',\n      version: '1.0.0',\n    },\n    {\n      capabilities: {}\n    }\n  )\n\n  await client.connect(transport)\n  return client\n}\n\nasync function searchEventbriteEvents(query: string, location?: string) {\n  const client = await setupEventbriteMCP()\n\n  const result = await client.callTool({\n    name: 'search_events',\n    arguments: {\n      q: query,\n      location: location,\n      limit: 50\n    }\n  })\n\n  return result._meta?.events || []\n}\n</code></pre>"},{"location":"mcp/eventbrite/#api-endpoints-tools","title":"\ud83d\udcca API Endpoints &amp; Tools","text":""},{"location":"mcp/eventbrite/#available-mcp-tools","title":"Available MCP Tools","text":"Tool Name Description Parameters <code>search_events</code> Search for events q, location, categories, dates, price, etc. <code>get_event_details</code> Get detailed event info event_id <code>get_event_categories</code> List available categories None <code>search_venues</code> Search for venues location, q"},{"location":"mcp/eventbrite/#example-tool-calls","title":"Example Tool Calls","text":"<pre><code>// Search for tech events in San Francisco\nconst techEvents = await client.callTool({\n  name: 'search_events',\n  arguments: {\n    q: 'technology',\n    location: 'San Francisco, CA',\n    categories: ['103'], // Technology category ID\n    start_date: '2024-02-01T00:00:00Z',\n    end_date: '2024-02-29T23:59:59Z',\n    limit: 20\n  }\n})\n\n// Get specific event details\nconst eventDetails = await client.callTool({\n  name: 'get_event_details',\n  arguments: {\n    event_id: '123456789'\n  }\n})\n\n// Get all categories\nconst categories = await client.callTool({\n  name: 'get_event_categories',\n  arguments: {}\n})\n</code></pre>"},{"location":"mcp/eventbrite/#testing","title":"\ud83e\uddea Testing","text":""},{"location":"mcp/eventbrite/#unit-tests","title":"Unit Tests","text":"<pre><code>// tests/eventbrite-api.test.ts\nimport { EventbriteAPI } from '../src/api/eventbrite-api.js'\nimport { describe, it, expect, beforeEach } from 'vitest'\n\ndescribe('EventbriteAPI', () =&gt; {\n  let api: EventbriteAPI\n\n  beforeEach(() =&gt; {\n    api = new EventbriteAPI({\n      apiKey: 'test-key',\n      baseUrl: 'https://api.test.com'\n    })\n  })\n\n  it('should search events successfully', async () =&gt; {\n    const events = await api.searchEvents({\n      q: 'test',\n      location: 'San Francisco'\n    })\n\n    expect(Array.isArray(events)).toBe(true)\n  })\n\n  it('should handle API errors gracefully', async () =&gt; {\n    await expect(\n      api.getEventDetails('invalid-id')\n    ).rejects.toThrow()\n  })\n})\n</code></pre>"},{"location":"mcp/eventbrite/#integration-tests","title":"Integration Tests","text":"<pre><code>// tests/mcp-integration.test.ts\nimport { EventbriteMCPServer } from '../src/eventbrite-mcp-server.js'\n\ndescribe('Eventbrite MCP Integration', () =&gt; {\n  let server: EventbriteMCPServer\n\n  beforeEach(() =&gt; {\n    server = new EventbriteMCPServer()\n  })\n\n  it('should handle search_events tool call', async () =&gt; {\n    const result = await server.handleSearchEvents({\n      q: 'test event',\n      location: 'New York'\n    })\n\n    expect(result.content).toBeDefined()\n    expect(result._meta?.events).toBeDefined()\n  })\n})\n</code></pre>"},{"location":"mcp/eventbrite/#performance-monitoring","title":"\ud83d\udcc8 Performance &amp; Monitoring","text":""},{"location":"mcp/eventbrite/#metrics-collection","title":"Metrics Collection","text":"<pre><code>// src/utils/metrics.ts\nexport class EventbriteMetrics {\n  private static instance: EventbriteMetrics\n  private metrics: Map&lt;string, number&gt; = new Map()\n\n  static getInstance(): EventbriteMetrics {\n    if (!EventbriteMetrics.instance) {\n      EventbriteMetrics.instance = new EventbriteMetrics()\n    }\n    return EventbriteMetrics.instance\n  }\n\n  incrementCounter(metric: string): void {\n    const current = this.metrics.get(metric) || 0\n    this.metrics.set(metric, current + 1)\n  }\n\n  getMetrics(): Record&lt;string, number&gt; {\n    return Object.fromEntries(this.metrics)\n  }\n\n  reset(): void {\n    this.metrics.clear()\n  }\n}\n\n// Usage in API calls\nconst metrics = EventbriteMetrics.getInstance()\nmetrics.incrementCounter('api.search_events.calls')\n</code></pre>"},{"location":"mcp/eventbrite/#health-check","title":"Health Check","text":"<pre><code>// src/health/health-check.ts\nexport async function checkEventbriteHealth(): Promise&lt;{\n  status: 'healthy' | 'unhealthy'\n  details: Record&lt;string, any&gt;\n}&gt; {\n  try {\n    const api = new EventbriteAPI({\n      apiKey: process.env.EVENTBRITE_API_KEY!,\n      baseUrl: process.env.EVENTBRITE_API_BASE_URL!\n    })\n\n    // Simple test call\n    await api.getCategories()\n\n    return {\n      status: 'healthy',\n      details: {\n        api_connection: 'ok',\n        timestamp: new Date().toISOString()\n      }\n    }\n  } catch (error) {\n    return {\n      status: 'unhealthy',\n      details: {\n        api_connection: 'failed',\n        error: error.message,\n        timestamp: new Date().toISOString()\n      }\n    }\n  }\n}\n</code></pre> <p>This comprehensive documentation covers the Eventbrite MCP server implementation, providing everything needed to integrate Eventbrite event data into the Inttrest platform! \ud83c\udfab</p>"},{"location":"mcp/instagram/","title":"Instagram MCP Server","text":"<p>This document provides comprehensive documentation for the Instagram Model Context Protocol (MCP) server integration in Inttrest, enabling event discovery from Instagram posts and stories.</p>"},{"location":"mcp/instagram/#overview","title":"\ud83c\udfaf Overview","text":"<p>The Instagram MCP server leverages web scraping and automation to discover events from Instagram posts, stories, and profiles. It provides intelligent content analysis to extract event information from social media posts.</p> <pre><code>graph TB\n    subgraph \"Instagram MCP Architecture\"\n        A[MCP Client] --&gt; B[Instagram MCP Server]\n        B --&gt; C[Browser Service]\n        B --&gt; D[Profile Scraper]\n        B --&gt; E[Content Analyzer]\n\n        C --&gt; F[Puppeteer Browser]\n        C --&gt; G[Session Management]\n        C --&gt; H[Anti-Detection]\n\n        D --&gt; I[Post Extraction]\n        D --&gt; J[Story Analysis]\n        D --&gt; K[Bio Parsing]\n\n        E --&gt; L[AI Content Analysis]\n        E --&gt; M[Event Detection]\n        E --&gt; N[Location Extraction]\n\n        L --&gt; O[OpenAI API]\n        M --&gt; P[Event Classification]\n        N --&gt; Q[Geocoding Service]\n    end\n\n    subgraph \"Inttrest Integration\"\n        R[AI Chat Interface] --&gt; A\n        S[Event Discovery] --&gt; A\n        T[Social Feed] --&gt; A\n\n        P --&gt; U[Event Database]\n        Q --&gt; V[Map Integration]\n        N --&gt; W[Real-time Updates]\n    end\n\n    style B fill:#e3f2fd\n    style C fill:#e8f5e8\n    style E fill:#fff3e0\n    style O fill:#fce4ec</code></pre>"},{"location":"mcp/instagram/#installation-setup","title":"\ud83d\udce6 Installation &amp; Setup","text":""},{"location":"mcp/instagram/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 18+ with npm/pnpm</li> <li>Chrome/Chromium browser for Puppeteer</li> <li>OpenAI API Key for content analysis</li> <li>Instagram Account (optional, for authenticated scraping)</li> </ul>"},{"location":"mcp/instagram/#installation","title":"Installation","text":"<pre><code># Navigate to Instagram MCP server directory\ncd mcp_servers/instagram-server-next-mcp\n\n# Install dependencies\nnpm install\n# or\npnpm install\n\n# Install Puppeteer browser\nnpx puppeteer browsers install chrome\n\n# Build the server\nnpm run build\n</code></pre>"},{"location":"mcp/instagram/#configuration","title":"Configuration","text":"<p>Create a <code>.env</code> file in the <code>instagram-server-next-mcp</code> directory:</p> <pre><code># Instagram Configuration\nINSTAGRAM_USERNAME=your_instagram_username\nINSTAGRAM_PASSWORD=your_instagram_password\nINSTAGRAM_SESSION_FILE=./sessions/instagram_session.json\n\n# Browser Configuration\nBROWSER_HEADLESS=true\nBROWSER_TIMEOUT=30000\nBROWSER_VIEWPORT_WIDTH=1920\nBROWSER_VIEWPORT_HEIGHT=1080\n\n# OpenAI Configuration for Content Analysis\nOPENAI_API_KEY=your_openai_api_key_here\nOPENAI_MODEL=gpt-4-turbo-preview\n\n# Proxy Configuration (optional)\nPROXY_HOST=\nPROXY_PORT=\nPROXY_USERNAME=\nPROXY_PASSWORD=\n\n# Rate Limiting\nRATE_LIMIT_REQUESTS=10\nRATE_LIMIT_WINDOW=60000  # 1 minute\nCONCURRENT_REQUESTS=3\n\n# Cache Configuration\nCACHE_TTL=1800000  # 30 minutes\nCACHE_MAX_SIZE=500\n\n# Logging\nLOG_LEVEL=info\nLOG_FILE=instagram-mcp.log\n\n# Anti-Detection\nUSER_AGENT=\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36\"\nSTEALTH_MODE=true\nRANDOM_DELAYS=true\n</code></pre>"},{"location":"mcp/instagram/#package-dependencies","title":"Package Dependencies","text":"<pre><code>{\n  \"name\": \"instagram-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n    \"puppeteer\": \"^22.0.0\",\n    \"puppeteer-extra\": \"^3.3.6\",\n    \"puppeteer-extra-plugin-stealth\": \"^2.11.2\",\n    \"openai\": \"^4.20.1\",\n    \"cheerio\": \"^1.0.0-rc.12\",\n    \"node-cache\": \"^5.1.2\",\n    \"winston\": \"^3.11.0\",\n    \"zod\": \"^4.1.5\",\n    \"dotenv\": \"^16.3.1\",\n    \"axios\": \"^1.6.0\",\n    \"uuid\": \"^9.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"@types/puppeteer\": \"^7.0.4\",\n    \"typescript\": \"^5.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"vitest\": \"^1.0.0\"\n  }\n}\n</code></pre>"},{"location":"mcp/instagram/#server-implementation","title":"\ud83c\udfd7\ufe0f Server Implementation","text":""},{"location":"mcp/instagram/#core-server-structure","title":"Core Server Structure","text":"<pre><code>// src/instagram-mcp-server.ts\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js'\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js'\nimport { BrowserService } from './services/browser-service.js'\nimport { ProfileScraper } from './services/profile-scraper.js'\nimport { ContentAnalyzer } from './services/content-analyzer.js'\nimport { Logger } from './utils/logger.js'\nimport { z } from 'zod'\n\nconst logger = new Logger('InstagramMCP')\n\nclass InstagramMCPServer {\n  private server: Server\n  private browserService: BrowserService\n  private profileScraper: ProfileScraper\n  private contentAnalyzer: ContentAnalyzer\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'instagram-mcp-server',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    )\n\n    this.browserService = new BrowserService()\n    this.profileScraper = new ProfileScraper(this.browserService)\n    this.contentAnalyzer = new ContentAnalyzer()\n\n    this.setupToolHandlers()\n  }\n\n  private setupToolHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: 'search_instagram_events',\n            description: 'Search for events on Instagram using hashtags and locations',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                hashtags: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Hashtags to search for event-related content'\n                },\n                location: {\n                  type: 'string',\n                  description: 'Location to search for events'\n                },\n                date_range: {\n                  type: 'object',\n                  properties: {\n                    start: { type: 'string' },\n                    end: { type: 'string' }\n                  },\n                  description: 'Date range for event search'\n                },\n                max_posts: {\n                  type: 'number',\n                  minimum: 1,\n                  maximum: 100,\n                  description: 'Maximum number of posts to analyze'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'analyze_instagram_profile',\n            description: 'Analyze an Instagram profile for event-related content',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                username: {\n                  type: 'string',\n                  description: 'Instagram username to analyze'\n                },\n                include_stories: {\n                  type: 'boolean',\n                  description: 'Whether to include story analysis'\n                },\n                max_posts: {\n                  type: 'number',\n                  minimum: 1,\n                  maximum: 50,\n                  description: 'Maximum number of recent posts to analyze'\n                }\n              },\n              required: ['username']\n            }\n          },\n          {\n            name: 'extract_event_from_post',\n            description: 'Extract event information from a specific Instagram post',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                post_url: {\n                  type: 'string',\n                  description: 'URL of the Instagram post'\n                },\n                deep_analysis: {\n                  type: 'boolean',\n                  description: 'Whether to perform deep AI analysis of the content'\n                }\n              },\n              required: ['post_url']\n            }\n          },\n          {\n            name: 'monitor_instagram_accounts',\n            description: 'Monitor specific Instagram accounts for new event posts',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                usernames: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'List of usernames to monitor'\n                },\n                keywords: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Keywords to look for in posts'\n                },\n                check_interval: {\n                  type: 'number',\n                  description: 'Interval in minutes to check for new posts'\n                }\n              },\n              required: ['usernames']\n            }\n          }\n        ]\n      }\n    })\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      try {\n        const { name, arguments: args } = request.params\n\n        switch (name) {\n          case 'search_instagram_events':\n            return await this.handleSearchInstagramEvents(args)\n\n          case 'analyze_instagram_profile':\n            return await this.handleAnalyzeProfile(args)\n\n          case 'extract_event_from_post':\n            return await this.handleExtractEventFromPost(args)\n\n          case 'monitor_instagram_accounts':\n            return await this.handleMonitorAccounts(args)\n\n          default:\n            throw new Error(`Unknown tool: ${name}`)\n        }\n      } catch (error) {\n        logger.error('Tool execution failed:', error)\n        throw error\n      }\n    })\n  }\n\n  private async handleSearchInstagramEvents(args: any) {\n    const searchParams = InstagramSearchSchema.parse(args)\n\n    logger.info('Searching Instagram events:', searchParams)\n\n    const posts = await this.profileScraper.searchHashtagPosts(\n      searchParams.hashtags || ['event', 'party', 'concert'],\n      searchParams.location,\n      searchParams.max_posts || 20\n    )\n\n    const events = await this.contentAnalyzer.analyzePostsForEvents(posts)\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${events.length} potential events from ${posts.length} Instagram posts`\n        }\n      ],\n      _meta: {\n        source: 'instagram',\n        search_params: searchParams,\n        posts_analyzed: posts.length,\n        events_found: events.length,\n        events: events\n      }\n    }\n  }\n\n  private async handleAnalyzeProfile(args: any) {\n    const profileParams = ProfileAnalysisSchema.parse(args)\n\n    logger.info('Analyzing Instagram profile:', profileParams.username)\n\n    const profileData = await this.profileScraper.scrapeProfile(\n      profileParams.username,\n      profileParams.max_posts || 20,\n      profileParams.include_stories || false\n    )\n\n    const events = await this.contentAnalyzer.analyzeProfileForEvents(profileData)\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Analyzed profile @${profileParams.username} and found ${events.length} potential events`\n        }\n      ],\n      _meta: {\n        source: 'instagram',\n        profile: profileData.profile,\n        posts_analyzed: profileData.posts.length,\n        events_found: events.length,\n        events: events\n      }\n    }\n  }\n\n  private async handleExtractEventFromPost(args: any) {\n    const postParams = PostExtractionSchema.parse(args)\n\n    logger.info('Extracting event from post:', postParams.post_url)\n\n    const postData = await this.profileScraper.scrapePost(postParams.post_url)\n    const event = await this.contentAnalyzer.extractEventFromPost(\n      postData,\n      postParams.deep_analysis || false\n    )\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: event ? `Extracted event: ${event.title}` : 'No event detected in this post'\n        }\n      ],\n      _meta: {\n        source: 'instagram',\n        post_url: postParams.post_url,\n        event_detected: !!event,\n        event: event\n      }\n    }\n  }\n\n  private async handleMonitorAccounts(args: any) {\n    const monitorParams = AccountMonitoringSchema.parse(args)\n\n    logger.info('Setting up monitoring for accounts:', monitorParams.usernames)\n\n    // This would typically set up a background job\n    const results = await this.profileScraper.monitorAccounts(\n      monitorParams.usernames,\n      monitorParams.keywords || [],\n      monitorParams.check_interval || 60\n    )\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Monitoring setup for ${monitorParams.usernames.length} accounts`\n        }\n      ],\n      _meta: {\n        source: 'instagram',\n        monitoring_setup: results,\n        accounts: monitorParams.usernames\n      }\n    }\n  }\n\n  async start() {\n    await this.browserService.initialize()\n\n    const transport = new StdioServerTransport()\n    await this.server.connect(transport)\n\n    logger.info('Instagram MCP Server started successfully')\n  }\n\n  async stop() {\n    await this.browserService.close()\n    logger.info('Instagram MCP Server stopped')\n  }\n}\n\n// Schema definitions\nconst InstagramSearchSchema = z.object({\n  hashtags: z.array(z.string()).optional(),\n  location: z.string().optional(),\n  date_range: z.object({\n    start: z.string(),\n    end: z.string()\n  }).optional(),\n  max_posts: z.number().min(1).max(100).optional()\n})\n\nconst ProfileAnalysisSchema = z.object({\n  username: z.string(),\n  include_stories: z.boolean().optional(),\n  max_posts: z.number().min(1).max(50).optional()\n})\n\nconst PostExtractionSchema = z.object({\n  post_url: z.string().url(),\n  deep_analysis: z.boolean().optional()\n})\n\nconst AccountMonitoringSchema = z.object({\n  usernames: z.array(z.string()),\n  keywords: z.array(z.string()).optional(),\n  check_interval: z.number().optional()\n})\n\n// Start the server\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const server = new InstagramMCPServer()\n\n  process.on('SIGINT', async () =&gt; {\n    await server.stop()\n    process.exit(0)\n  })\n\n  server.start().catch(console.error)\n}\n\nexport { InstagramMCPServer }\n</code></pre>"},{"location":"mcp/instagram/#browser-service","title":"Browser Service","text":"<pre><code>// src/services/browser-service.ts\nimport puppeteer, { Browser, Page } from 'puppeteer'\nimport puppeteerExtra from 'puppeteer-extra'\nimport StealthPlugin from 'puppeteer-extra-plugin-stealth'\nimport { Logger } from '../utils/logger.js'\n\npuppeteerExtra.use(StealthPlugin())\n\ninterface BrowserConfig {\n  headless: boolean\n  timeout: number\n  viewport: {\n    width: number\n    height: number\n  }\n  userAgent?: string\n  proxy?: {\n    host: string\n    port: number\n    username?: string\n    password?: string\n  }\n}\n\nexport class BrowserService {\n  private browser: Browser | null = null\n  private config: BrowserConfig\n  private logger: Logger\n\n  constructor() {\n    this.logger = new Logger('BrowserService')\n    this.config = this.loadConfig()\n  }\n\n  private loadConfig(): BrowserConfig {\n    return {\n      headless: process.env.BROWSER_HEADLESS !== 'false',\n      timeout: parseInt(process.env.BROWSER_TIMEOUT || '30000'),\n      viewport: {\n        width: parseInt(process.env.BROWSER_VIEWPORT_WIDTH || '1920'),\n        height: parseInt(process.env.BROWSER_VIEWPORT_HEIGHT || '1080')\n      },\n      userAgent: process.env.USER_AGENT,\n      proxy: process.env.PROXY_HOST ? {\n        host: process.env.PROXY_HOST,\n        port: parseInt(process.env.PROXY_PORT || '8080'),\n        username: process.env.PROXY_USERNAME,\n        password: process.env.PROXY_PASSWORD\n      } : undefined\n    }\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    try {\n      const launchOptions: any = {\n        headless: this.config.headless,\n        defaultViewport: this.config.viewport,\n        args: [\n          '--no-sandbox',\n          '--disable-setuid-sandbox',\n          '--disable-dev-shm-usage',\n          '--disable-accelerated-2d-canvas',\n          '--no-first-run',\n          '--no-zygote',\n          '--disable-gpu',\n          '--disable-extensions'\n        ]\n      }\n\n      if (this.config.proxy) {\n        launchOptions.args.push(\n          `--proxy-server=${this.config.proxy.host}:${this.config.proxy.port}`\n        )\n      }\n\n      this.browser = await puppeteerExtra.launch(launchOptions)\n      this.logger.info('Browser initialized successfully')\n\n    } catch (error) {\n      this.logger.error('Failed to initialize browser:', error)\n      throw error\n    }\n  }\n\n  async createPage(): Promise&lt;Page&gt; {\n    if (!this.browser) {\n      await this.initialize()\n    }\n\n    const page = await this.browser!.newPage()\n\n    // Set user agent\n    if (this.config.userAgent) {\n      await page.setUserAgent(this.config.userAgent)\n    }\n\n    // Set timeout\n    page.setDefaultTimeout(this.config.timeout)\n\n    // Block unnecessary resources to speed up loading\n    await page.setRequestInterception(true)\n    page.on('request', (request) =&gt; {\n      const resourceType = request.resourceType()\n      if (['image', 'font', 'media'].includes(resourceType)) {\n        request.abort()\n      } else {\n        request.continue()\n      }\n    })\n\n    // Add stealth measures\n    await this.addStealthMeasures(page)\n\n    this.logger.debug('Created new page with stealth configuration')\n    return page\n  }\n\n  private async addStealthMeasures(page: Page): Promise&lt;void&gt; {\n    // Override navigator properties\n    await page.evaluateOnNewDocument(() =&gt; {\n      // Remove webdriver property\n      delete (navigator as any).webdriver\n\n      // Override plugins\n      Object.defineProperty(navigator, 'plugins', {\n        get: () =&gt; [1, 2, 3, 4, 5]\n      })\n\n      // Override languages\n      Object.defineProperty(navigator, 'languages', {\n        get: () =&gt; ['en-US', 'en']\n      })\n\n      // Override permissions\n      const originalQuery = window.navigator.permissions.query\n      window.navigator.permissions.query = (parameters) =&gt;\n        parameters.name === 'notifications'\n          ? Promise.resolve({ state: Notification.permission } as any)\n          : originalQuery(parameters)\n    })\n\n    // Random delays\n    if (process.env.RANDOM_DELAYS === 'true') {\n      await this.randomDelay(1000, 3000)\n    }\n  }\n\n  async randomDelay(min: number = 1000, max: number = 3000): Promise&lt;void&gt; {\n    const delay = Math.floor(Math.random() * (max - min + 1)) + min\n    await new Promise(resolve =&gt; setTimeout(resolve, delay))\n  }\n\n  async navigateToInstagram(page: Page): Promise&lt;void&gt; {\n    try {\n      await page.goto('https://www.instagram.com/', {\n        waitUntil: 'networkidle2',\n        timeout: this.config.timeout\n      })\n\n      await this.randomDelay(2000, 4000)\n      this.logger.debug('Navigated to Instagram')\n\n    } catch (error) {\n      this.logger.error('Failed to navigate to Instagram:', error)\n      throw error\n    }\n  }\n\n  async loginToInstagram(page: Page): Promise&lt;void&gt; {\n    const username = process.env.INSTAGRAM_USERNAME\n    const password = process.env.INSTAGRAM_PASSWORD\n\n    if (!username || !password) {\n      this.logger.info('No Instagram credentials provided, continuing without login')\n      return\n    }\n\n    try {\n      // Check if already logged in\n      const isLoggedIn = await page.$('svg[aria-label=\"Home\"]')\n      if (isLoggedIn) {\n        this.logger.info('Already logged in to Instagram')\n        return\n      }\n\n      // Click login button\n      await page.waitForSelector('a[href=\"/accounts/login/\"]', { timeout: 10000 })\n      await page.click('a[href=\"/accounts/login/\"]')\n      await this.randomDelay(2000, 3000)\n\n      // Fill in credentials\n      await page.waitForSelector('input[name=\"username\"]')\n      await page.type('input[name=\"username\"]', username, { delay: 100 })\n      await this.randomDelay(500, 1000)\n\n      await page.type('input[name=\"password\"]', password, { delay: 100 })\n      await this.randomDelay(1000, 2000)\n\n      // Submit login\n      await page.click('button[type=\"submit\"]')\n      await page.waitForNavigation({ waitUntil: 'networkidle2' })\n\n      // Handle potential security checks\n      await this.handleSecurityChecks(page)\n\n      this.logger.info('Successfully logged in to Instagram')\n\n    } catch (error) {\n      this.logger.error('Failed to login to Instagram:', error)\n      throw error\n    }\n  }\n\n  private async handleSecurityChecks(page: Page): Promise&lt;void&gt; {\n    try {\n      // Check for \"Save Your Login Info\" dialog\n      const saveLoginButton = await page.$('button:has-text(\"Not Now\")')\n      if (saveLoginButton) {\n        await saveLoginButton.click()\n        await this.randomDelay(1000, 2000)\n      }\n\n      // Check for \"Turn on Notifications\" dialog\n      const notificationButton = await page.$('button:has-text(\"Not Now\")')\n      if (notificationButton) {\n        await notificationButton.click()\n        await this.randomDelay(1000, 2000)\n      }\n\n      // Check for suspicious login activity\n      const suspiciousActivity = await page.$('text=\"We Detected Unusual Activity\"')\n      if (suspiciousActivity) {\n        this.logger.warn('Instagram detected unusual activity')\n        // Handle this case based on your needs\n      }\n\n    } catch (error) {\n      this.logger.debug('No security checks to handle')\n    }\n  }\n\n  async closePage(page: Page): Promise&lt;void&gt; {\n    try {\n      await page.close()\n      this.logger.debug('Page closed')\n    } catch (error) {\n      this.logger.error('Failed to close page:', error)\n    }\n  }\n\n  async close(): Promise&lt;void&gt; {\n    if (this.browser) {\n      await this.browser.close()\n      this.browser = null\n      this.logger.info('Browser closed')\n    }\n  }\n\n  async restartBrowser(): Promise&lt;void&gt; {\n    await this.close()\n    await this.initialize()\n    this.logger.info('Browser restarted')\n  }\n}\n</code></pre>"},{"location":"mcp/instagram/#profile-scraper","title":"Profile Scraper","text":"<pre><code>// src/services/profile-scraper.ts\nimport { Page } from 'puppeteer'\nimport { BrowserService } from './browser-service.js'\nimport { Logger } from '../utils/logger.js'\nimport * as cheerio from 'cheerio'\n\ninterface InstagramPost {\n  id: string\n  url: string\n  caption: string\n  timestamp: string\n  likes: number\n  comments: number\n  media_urls: string[]\n  hashtags: string[]\n  mentions: string[]\n  location?: {\n    name: string\n    id?: string\n  }\n}\n\ninterface InstagramProfile {\n  username: string\n  display_name: string\n  bio: string\n  follower_count: number\n  following_count: number\n  post_count: number\n  profile_pic_url: string\n  is_verified: boolean\n  is_business: boolean\n  external_url?: string\n}\n\ninterface ProfileData {\n  profile: InstagramProfile\n  posts: InstagramPost[]\n  stories?: any[]\n}\n\nexport class ProfileScraper {\n  private browserService: BrowserService\n  private logger: Logger\n\n  constructor(browserService: BrowserService) {\n    this.browserService = browserService\n    this.logger = new Logger('ProfileScraper')\n  }\n\n  async scrapeProfile(\n    username: string,\n    maxPosts: number = 20,\n    includeStories: boolean = false\n  ): Promise&lt;ProfileData&gt; {\n    const page = await this.browserService.createPage()\n\n    try {\n      await this.browserService.navigateToInstagram(page)\n      await this.browserService.loginToInstagram(page)\n\n      // Navigate to profile\n      await page.goto(`https://www.instagram.com/${username}/`, {\n        waitUntil: 'networkidle2'\n      })\n\n      // Extract profile information\n      const profile = await this.extractProfileInfo(page, username)\n\n      // Extract posts\n      const posts = await this.extractPosts(page, maxPosts)\n\n      // Extract stories if requested\n      let stories: any[] = []\n      if (includeStories) {\n        stories = await this.extractStories(page, username)\n      }\n\n      this.logger.info(`Scraped profile @${username}: ${posts.length} posts`)\n\n      return {\n        profile,\n        posts,\n        stories: includeStories ? stories : undefined\n      }\n\n    } catch (error) {\n      this.logger.error(`Failed to scrape profile @${username}:`, error)\n      throw error\n    } finally {\n      await this.browserService.closePage(page)\n    }\n  }\n\n  async scrapePost(postUrl: string): Promise&lt;InstagramPost&gt; {\n    const page = await this.browserService.createPage()\n\n    try {\n      await this.browserService.navigateToInstagram(page)\n      await this.browserService.loginToInstagram(page)\n\n      await page.goto(postUrl, { waitUntil: 'networkidle2' })\n\n      const post = await this.extractSinglePost(page, postUrl)\n\n      this.logger.info(`Scraped post: ${postUrl}`)\n      return post\n\n    } catch (error) {\n      this.logger.error(`Failed to scrape post ${postUrl}:`, error)\n      throw error\n    } finally {\n      await this.browserService.closePage(page)\n    }\n  }\n\n  async searchHashtagPosts(\n    hashtags: string[],\n    location?: string,\n    maxPosts: number = 20\n  ): Promise&lt;InstagramPost[]&gt; {\n    const page = await this.browserService.createPage()\n    const allPosts: InstagramPost[] = []\n\n    try {\n      await this.browserService.navigateToInstagram(page)\n      await this.browserService.loginToInstagram(page)\n\n      for (const hashtag of hashtags) {\n        this.logger.info(`Searching hashtag: #${hashtag}`)\n\n        const hashtagUrl = `https://www.instagram.com/explore/tags/${hashtag}/`\n        await page.goto(hashtagUrl, { waitUntil: 'networkidle2' })\n\n        const posts = await this.extractHashtagPosts(page, maxPosts / hashtags.length)\n        allPosts.push(...posts)\n\n        await this.browserService.randomDelay(2000, 4000)\n      }\n\n      // Filter by location if specified\n      if (location) {\n        return this.filterPostsByLocation(allPosts, location)\n      }\n\n      this.logger.info(`Found ${allPosts.length} posts from hashtag search`)\n      return allPosts.slice(0, maxPosts)\n\n    } catch (error) {\n      this.logger.error('Failed to search hashtag posts:', error)\n      throw error\n    } finally {\n      await this.browserService.closePage(page)\n    }\n  }\n\n  private async extractProfileInfo(page: Page, username: string): Promise&lt;InstagramProfile&gt; {\n    try {\n      // Wait for profile data to load\n      await page.waitForSelector('header section', { timeout: 10000 })\n\n      const profileData = await page.evaluate(() =&gt; {\n        // Extract from page script tags or DOM elements\n        const scripts = Array.from(document.querySelectorAll('script'))\n\n        for (const script of scripts) {\n          if (script.textContent?.includes('window._sharedData')) {\n            const sharedData = script.textContent.match(/window\\._sharedData = ({.*?});/)\n            if (sharedData) {\n              try {\n                const data = JSON.parse(sharedData[1])\n                const user = data.entry_data?.ProfilePage?.[0]?.graphql?.user\n                if (user) return user\n              } catch (e) {\n                // Continue to DOM extraction\n              }\n            }\n          }\n        }\n\n        // Fallback to DOM extraction\n        const header = document.querySelector('header section')\n        if (!header) return null\n\n        return {\n          username: document.querySelector('h2')?.textContent || username,\n          display_name: document.querySelector('h1')?.textContent || '',\n          bio: document.querySelector('div[data-testid=\"user-bio\"]')?.textContent || '',\n          follower_count: this.extractCountFromElement('a[href*=\"/followers/\"] span'),\n          following_count: this.extractCountFromElement('a[href*=\"/following/\"] span'),\n          post_count: this.extractCountFromElement('div:first-child span'),\n          profile_pic_url: document.querySelector('img[alt*=\"profile picture\"]')?.src || '',\n          is_verified: !!document.querySelector('[data-testid=\"verified-icon\"]'),\n          is_business: !!document.querySelector('[data-testid=\"business-icon\"]')\n        }\n      })\n\n      return {\n        username,\n        display_name: profileData?.full_name || profileData?.display_name || '',\n        bio: profileData?.biography || '',\n        follower_count: profileData?.edge_followed_by?.count || 0,\n        following_count: profileData?.edge_follow?.count || 0,\n        post_count: profileData?.edge_owner_to_timeline_media?.count || 0,\n        profile_pic_url: profileData?.profile_pic_url || '',\n        is_verified: profileData?.is_verified || false,\n        is_business: profileData?.is_business_account || false,\n        external_url: profileData?.external_url\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to extract profile info:', error)\n      return {\n        username,\n        display_name: '',\n        bio: '',\n        follower_count: 0,\n        following_count: 0,\n        post_count: 0,\n        profile_pic_url: '',\n        is_verified: false,\n        is_business: false\n      }\n    }\n  }\n\n  private async extractPosts(page: Page, maxPosts: number): Promise&lt;InstagramPost[]&gt; {\n    const posts: InstagramPost[] = []\n\n    try {\n      // Scroll to load posts\n      let loadedPosts = 0\n      while (loadedPosts &lt; maxPosts) {\n        const postElements = await page.$$('article a[href*=\"/p/\"]')\n\n        if (postElements.length === 0) break\n\n        for (let i = loadedPosts; i &lt; Math.min(postElements.length, maxPosts); i++) {\n          try {\n            const postUrl = await postElements[i].evaluate(el =&gt; el.href)\n            const post = await this.extractPostFromGrid(page, postUrl, i)\n            if (post) posts.push(post)\n            loadedPosts++\n          } catch (error) {\n            this.logger.debug(`Failed to extract post at index ${i}:`, error)\n          }\n        }\n\n        if (loadedPosts &lt; maxPosts) {\n          await page.evaluate(() =&gt; window.scrollTo(0, document.body.scrollHeight))\n          await this.browserService.randomDelay(2000, 3000)\n        }\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to extract posts:', error)\n    }\n\n    return posts\n  }\n\n  private async extractPostFromGrid(page: Page, postUrl: string, index: number): Promise&lt;InstagramPost | null&gt; {\n    try {\n      // Extract basic info from grid view\n      const postData = await page.evaluate((url, idx) =&gt; {\n        const postElement = document.querySelectorAll('article a[href*=\"/p/\"]')[idx]\n        if (!postElement) return null\n\n        const img = postElement.querySelector('img')\n        const timeElement = postElement.querySelector('time')\n\n        return {\n          url: url,\n          media_urls: img ? [img.src] : [],\n          timestamp: timeElement ? timeElement.getAttribute('datetime') : new Date().toISOString()\n        }\n      }, postUrl, index)\n\n      if (!postData) return null\n\n      // Extract post ID from URL\n      const postIdMatch = postUrl.match(/\\/p\\/([^\\/]+)\\//)\n      const postId = postIdMatch ? postIdMatch[1] : `post_${Date.now()}_${index}`\n\n      return {\n        id: postId,\n        url: postUrl,\n        caption: '', // Will be filled by detailed extraction if needed\n        timestamp: postData.timestamp,\n        likes: 0,\n        comments: 0,\n        media_urls: postData.media_urls,\n        hashtags: [],\n        mentions: [],\n        location: undefined\n      }\n\n    } catch (error) {\n      this.logger.debug(`Failed to extract post from grid:`, error)\n      return null\n    }\n  }\n\n  private async extractSinglePost(page: Page, postUrl: string): Promise&lt;InstagramPost&gt; {\n    try {\n      await page.waitForSelector('article', { timeout: 10000 })\n\n      const postData = await page.evaluate(() =&gt; {\n        const article = document.querySelector('article')\n        if (!article) throw new Error('Post not found')\n\n        // Extract caption\n        const captionElement = article.querySelector('div[data-testid=\"post-caption\"] span')\n        const caption = captionElement?.textContent || ''\n\n        // Extract hashtags and mentions from caption\n        const hashtags = (caption.match(/#\\w+/g) || []).map(tag =&gt; tag.slice(1))\n        const mentions = (caption.match(/@\\w+/g) || []).map(mention =&gt; mention.slice(1))\n\n        // Extract media URLs\n        const images = Array.from(article.querySelectorAll('img[src*=\"scontent\"]'))\n        const videos = Array.from(article.querySelectorAll('video source'))\n        const media_urls = [\n          ...images.map(img =&gt; img.src),\n          ...videos.map(video =&gt; video.src)\n        ]\n\n        // Extract engagement metrics\n        const likesElement = article.querySelector('button[data-testid=\"like-button\"] + span')\n        const likes = this.parseEngagementCount(likesElement?.textContent || '0')\n\n        // Extract timestamp\n        const timeElement = article.querySelector('time')\n        const timestamp = timeElement?.getAttribute('datetime') || new Date().toISOString()\n\n        // Extract location\n        const locationElement = article.querySelector('a[href*=\"/locations/\"]')\n        const location = locationElement ? {\n          name: locationElement.textContent || '',\n          id: locationElement.href.match(/\\/locations\\/(\\d+)\\//)?.[1]\n        } : undefined\n\n        return {\n          caption,\n          hashtags,\n          mentions,\n          media_urls,\n          likes,\n          timestamp,\n          location\n        }\n      })\n\n      const postIdMatch = postUrl.match(/\\/p\\/([^\\/]+)\\//)\n      const postId = postIdMatch ? postIdMatch[1] : `post_${Date.now()}`\n\n      return {\n        id: postId,\n        url: postUrl,\n        caption: postData.caption,\n        timestamp: postData.timestamp,\n        likes: postData.likes,\n        comments: 0, // Comments require separate extraction\n        media_urls: postData.media_urls,\n        hashtags: postData.hashtags,\n        mentions: postData.mentions,\n        location: postData.location\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to extract single post:', error)\n      throw error\n    }\n  }\n\n  private async extractHashtagPosts(page: Page, maxPosts: number): Promise&lt;InstagramPost[]&gt; {\n    const posts: InstagramPost[] = []\n\n    try {\n      // Wait for posts to load\n      await page.waitForSelector('article a[href*=\"/p/\"]', { timeout: 10000 })\n\n      const postLinks = await page.$$eval('article a[href*=\"/p/\"]', links =&gt; \n        links.slice(0, maxPosts).map(link =&gt; link.href)\n      )\n\n      for (const postUrl of postLinks) {\n        try {\n          // Extract basic info without navigating to each post\n          const postIdMatch = postUrl.match(/\\/p\\/([^\\/]+)\\//)\n          const postId = postIdMatch ? postIdMatch[1] : `hashtag_post_${Date.now()}`\n\n          posts.push({\n            id: postId,\n            url: postUrl,\n            caption: '',\n            timestamp: new Date().toISOString(),\n            likes: 0,\n            comments: 0,\n            media_urls: [],\n            hashtags: [],\n            mentions: [],\n            location: undefined\n          })\n\n        } catch (error) {\n          this.logger.debug(`Failed to process hashtag post ${postUrl}:`, error)\n        }\n      }\n\n    } catch (error) {\n      this.logger.error('Failed to extract hashtag posts:', error)\n    }\n\n    return posts\n  }\n\n  private async extractStories(page: Page, username: string): Promise&lt;any[]&gt; {\n    try {\n      // Stories require special handling and may not always be available\n      // This is a simplified implementation\n\n      const storiesButton = await page.$(`a[href=\"/${username}/\"] img[alt*=\"story\"]`)\n      if (!storiesButton) {\n        this.logger.debug('No stories available for this user')\n        return []\n      }\n\n      // Stories extraction would require more complex implementation\n      // due to Instagram's story viewing restrictions\n\n      return []\n\n    } catch (error) {\n      this.logger.debug('Failed to extract stories:', error)\n      return []\n    }\n  }\n\n  private filterPostsByLocation(posts: InstagramPost[], location: string): InstagramPost[] {\n    const locationLower = location.toLowerCase()\n\n    return posts.filter(post =&gt; {\n      if (post.location?.name?.toLowerCase().includes(locationLower)) {\n        return true\n      }\n\n      if (post.caption?.toLowerCase().includes(locationLower)) {\n        return true\n      }\n\n      return false\n    })\n  }\n\n  async monitorAccounts(\n    usernames: string[],\n    keywords: string[],\n    checkInterval: number\n  ): Promise&lt;any&gt; {\n    // This would implement a monitoring system\n    // For now, return setup confirmation\n\n    this.logger.info(`Setting up monitoring for ${usernames.length} accounts`)\n\n    return {\n      status: 'monitoring_setup',\n      accounts: usernames,\n      keywords: keywords,\n      interval_minutes: checkInterval,\n      next_check: new Date(Date.now() + checkInterval * 60000).toISOString()\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/instagram/#content-analyzer","title":"Content Analyzer","text":"<pre><code>// src/services/content-analyzer.ts\nimport OpenAI from 'openai'\nimport { Logger } from '../utils/logger.js'\nimport { InstagramPost, ProfileData } from './profile-scraper.js'\n\ninterface ExtractedEvent {\n  id: string\n  title: string\n  description: string\n  start_date?: string\n  end_date?: string\n  location?: {\n    name: string\n    address?: string\n    coordinates?: {\n      lat: number\n      lng: number\n    }\n  }\n  category: string\n  organizer: {\n    name: string\n    instagram: string\n  }\n  ticket_info?: {\n    is_free: boolean\n    price?: string\n    booking_url?: string\n  }\n  source_post: {\n    url: string\n    instagram_id: string\n  }\n  confidence_score: number\n  extracted_at: string\n}\n\nexport class ContentAnalyzer {\n  private openai: OpenAI\n  private logger: Logger\n\n  constructor() {\n    this.logger = new Logger('ContentAnalyzer')\n\n    if (!process.env.OPENAI_API_KEY) {\n      throw new Error('OPENAI_API_KEY is required for content analysis')\n    }\n\n    this.openai = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY\n    })\n  }\n\n  async analyzePostsForEvents(posts: InstagramPost[]): Promise&lt;ExtractedEvent[]&gt; {\n    this.logger.info(`Analyzing ${posts.length} posts for events`)\n\n    const events: ExtractedEvent[] = []\n\n    for (const post of posts) {\n      try {\n        const event = await this.extractEventFromPost(post, true)\n        if (event) {\n          events.push(event)\n        }\n      } catch (error) {\n        this.logger.debug(`Failed to analyze post ${post.id}:`, error)\n      }\n    }\n\n    this.logger.info(`Extracted ${events.length} events from ${posts.length} posts`)\n    return events\n  }\n\n  async analyzeProfileForEvents(profileData: ProfileData): Promise&lt;ExtractedEvent[]&gt; {\n    this.logger.info(`Analyzing profile @${profileData.profile.username} for events`)\n\n    // First, check if this is an event-related profile\n    const isEventProfile = await this.isEventRelatedProfile(profileData.profile)\n\n    if (!isEventProfile) {\n      this.logger.debug(`Profile @${profileData.profile.username} doesn't appear to be event-related`)\n      return []\n    }\n\n    return this.analyzePostsForEvents(profileData.posts)\n  }\n\n  async extractEventFromPost(\n    post: InstagramPost,\n    deepAnalysis: boolean = false\n  ): Promise&lt;ExtractedEvent | null&gt; {\n    try {\n      // Quick keyword-based filtering first\n      if (!this.containsEventKeywords(post.caption)) {\n        return null\n      }\n\n      if (deepAnalysis) {\n        return await this.performAIAnalysis(post)\n      } else {\n        return await this.performBasicAnalysis(post)\n      }\n\n    } catch (error) {\n      this.logger.error(`Failed to extract event from post ${post.id}:`, error)\n      return null\n    }\n  }\n\n  private async isEventRelatedProfile(profile: any): Promise&lt;boolean&gt; {\n    const eventKeywords = [\n      'event', 'events', 'party', 'concert', 'festival', 'show', 'performance',\n      'venue', 'club', 'bar', 'restaurant', 'theater', 'museum', 'gallery',\n      'conference', 'workshop', 'seminar', 'meetup', 'gathering', 'celebration'\n    ]\n\n    const profileText = `${profile.bio} ${profile.display_name}`.toLowerCase()\n\n    return eventKeywords.some(keyword =&gt; profileText.includes(keyword))\n  }\n\n  private containsEventKeywords(text: string): boolean {\n    const eventKeywords = [\n      'event', 'tonight', 'tomorrow', 'this weekend', 'next week',\n      'join us', 'come to', 'happening', 'live music', 'performance',\n      'show', 'concert', 'party', 'celebration', 'festival',\n      'workshop', 'seminar', 'meetup', 'conference',\n      'tickets', 'rsvp', 'register', 'book now',\n      'when:', 'where:', 'time:', 'date:', 'location:'\n    ]\n\n    const textLower = text.toLowerCase()\n    return eventKeywords.some(keyword =&gt; textLower.includes(keyword))\n  }\n\n  private async performBasicAnalysis(post: InstagramPost): Promise&lt;ExtractedEvent | null&gt; {\n    // Basic pattern matching for event information\n    const caption = post.caption\n\n    // Extract potential dates\n    const datePatterns = [\n      /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/g,\n      /(\\d{1,2}-\\d{1,2}-\\d{4})/g,\n      /(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/gi,\n      /(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\w*\\s+\\d{1,2}/gi\n    ]\n\n    let extractedDate: string | undefined\n    for (const pattern of datePatterns) {\n      const match = caption.match(pattern)\n      if (match) {\n        extractedDate = match[0]\n        break\n      }\n    }\n\n    // Extract potential times\n    const timePattern = /(\\d{1,2}:\\d{2}\\s*(am|pm|AM|PM)?)/g\n    const timeMatch = caption.match(timePattern)\n    const extractedTime = timeMatch ? timeMatch[0] : undefined\n\n    // Extract potential location\n    const locationPatterns = [\n      /at\\s+([A-Z][A-Za-z\\s]+)/g,\n      /location:\\s*([A-Za-z\\s]+)/gi,\n      /where:\\s*([A-Za-z\\s]+)/gi\n    ]\n\n    let extractedLocation: string | undefined\n    for (const pattern of locationPatterns) {\n      const match = caption.match(pattern)\n      if (match &amp;&amp; match[1]) {\n        extractedLocation = match[1].trim()\n        break\n      }\n    }\n\n    // If we found event indicators, create a basic event\n    if (extractedDate || extractedTime || extractedLocation) {\n      return {\n        id: `extracted_${post.id}`,\n        title: this.extractTitle(caption),\n        description: caption,\n        start_date: this.constructDateTime(extractedDate, extractedTime),\n        location: extractedLocation ? {\n          name: extractedLocation\n        } : post.location,\n        category: this.inferCategory(caption),\n        organizer: {\n          name: 'Instagram User', // Would need profile info\n          instagram: post.url.split('/')[3] || ''\n        },\n        source_post: {\n          url: post.url,\n          instagram_id: post.id\n        },\n        confidence_score: 0.6,\n        extracted_at: new Date().toISOString()\n      }\n    }\n\n    return null\n  }\n\n  private async performAIAnalysis(post: InstagramPost): Promise&lt;ExtractedEvent | null&gt; {\n    try {\n      const prompt = this.buildAnalysisPrompt(post)\n\n      const response = await this.openai.chat.completions.create({\n        model: process.env.OPENAI_MODEL || 'gpt-4-turbo-preview',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an expert at extracting event information from Instagram posts. Analyze the content and extract structured event data if an event is being promoted.'\n          },\n          {\n            role: 'user',\n            content: prompt\n          }\n        ],\n        functions: [\n          {\n            name: 'extract_event',\n            description: 'Extract event information from Instagram post',\n            parameters: {\n              type: 'object',\n              properties: {\n                is_event: {\n                  type: 'boolean',\n                  description: 'Whether this post is promoting an event'\n                },\n                event_title: {\n                  type: 'string',\n                  description: 'Title or name of the event'\n                },\n                event_description: {\n                  type: 'string',\n                  description: 'Description of the event'\n                },\n                start_date: {\n                  type: 'string',\n                  description: 'Event start date in ISO format'\n                },\n                end_date: {\n                  type: 'string',\n                  description: 'Event end date in ISO format (if different from start)'\n                },\n                location_name: {\n                  type: 'string',\n                  description: 'Name of the event location'\n                },\n                location_address: {\n                  type: 'string',\n                  description: 'Address of the event location'\n                },\n                category: {\n                  type: 'string',\n                  description: 'Event category (music, art, food, sports, etc.)'\n                },\n                is_free: {\n                  type: 'boolean',\n                  description: 'Whether the event is free'\n                },\n                ticket_price: {\n                  type: 'string',\n                  description: 'Ticket price if mentioned'\n                },\n                booking_info: {\n                  type: 'string',\n                  description: 'How to book or get tickets'\n                },\n                confidence_score: {\n                  type: 'number',\n                  description: 'Confidence score from 0 to 1'\n                }\n              },\n              required: ['is_event', 'confidence_score']\n            }\n          }\n        ],\n        function_call: { name: 'extract_event' }\n      })\n\n      const functionCall = response.choices[0]?.message?.function_call\n      if (!functionCall || functionCall.name !== 'extract_event') {\n        return null\n      }\n\n      const extractedData = JSON.parse(functionCall.arguments)\n\n      if (!extractedData.is_event || extractedData.confidence_score &lt; 0.5) {\n        return null\n      }\n\n      return {\n        id: `ai_extracted_${post.id}`,\n        title: extractedData.event_title || this.extractTitle(post.caption),\n        description: extractedData.event_description || post.caption,\n        start_date: extractedData.start_date,\n        end_date: extractedData.end_date,\n        location: {\n          name: extractedData.location_name || post.location?.name || '',\n          address: extractedData.location_address\n        },\n        category: extractedData.category || 'other',\n        organizer: {\n          name: 'Instagram User',\n          instagram: post.url.split('/')[3] || ''\n        },\n        ticket_info: {\n          is_free: extractedData.is_free || false,\n          price: extractedData.ticket_price,\n          booking_url: extractedData.booking_info\n        },\n        source_post: {\n          url: post.url,\n          instagram_id: post.id\n        },\n        confidence_score: extractedData.confidence_score,\n        extracted_at: new Date().toISOString()\n      }\n\n    } catch (error) {\n      this.logger.error('AI analysis failed:', error)\n      return this.performBasicAnalysis(post)\n    }\n  }\n\n  private buildAnalysisPrompt(post: InstagramPost): string {\n    return `\nAnalyze this Instagram post for event information:\n\nCaption: ${post.caption}\n\nHashtags: ${post.hashtags.join(', ')}\n\n${post.location ? `Location: ${post.location.name}` : ''}\n\nPosted: ${post.timestamp}\n\nMedia URLs: ${post.media_urls.slice(0, 3).join(', ')}\n\nPlease determine if this post is promoting an event and extract all relevant details including:\n- Event title and description\n- Date and time\n- Location details\n- Event category\n- Ticket information\n- How to attend/book\n\nProvide a confidence score based on how clear the event information is.\n`\n  }\n\n  private extractTitle(caption: string): string {\n    // Extract potential title from the first line or sentence\n    const lines = caption.split('\\n').filter(line =&gt; line.trim())\n    if (lines.length &gt; 0) {\n      const firstLine = lines[0].trim()\n      // Remove hashtags and mentions from title\n      return firstLine.replace(/#\\w+/g, '').replace(/@\\w+/g, '').trim().slice(0, 100)\n    }\n    return 'Instagram Event'\n  }\n\n  private constructDateTime(date?: string, time?: string): string | undefined {\n    if (!date &amp;&amp; !time) return undefined\n\n    try {\n      const now = new Date()\n      let eventDate = now\n\n      if (date) {\n        eventDate = new Date(date)\n        if (isNaN(eventDate.getTime())) {\n          eventDate = now\n        }\n      }\n\n      if (time) {\n        const timeMatch = time.match(/(\\d{1,2}):(\\d{2})\\s*(am|pm|AM|PM)?/)\n        if (timeMatch) {\n          let hours = parseInt(timeMatch[1])\n          const minutes = parseInt(timeMatch[2])\n          const ampm = timeMatch[3]?.toLowerCase()\n\n          if (ampm === 'pm' &amp;&amp; hours !== 12) {\n            hours += 12\n          } else if (ampm === 'am' &amp;&amp; hours === 12) {\n            hours = 0\n          }\n\n          eventDate.setHours(hours, minutes, 0, 0)\n        }\n      }\n\n      return eventDate.toISOString()\n    } catch (error) {\n      return undefined\n    }\n  }\n\n  private inferCategory(caption: string): string {\n    const categoryKeywords = {\n      music: ['concert', 'music', 'band', 'dj', 'live music', 'performance'],\n      food: ['food', 'restaurant', 'dining', 'taste', 'menu', 'chef'],\n      art: ['art', 'gallery', 'exhibition', 'artist', 'painting', 'sculpture'],\n      sports: ['game', 'match', 'sports', 'team', 'tournament', 'athletic'],\n      business: ['conference', 'workshop', 'seminar', 'networking', 'business'],\n      entertainment: ['show', 'comedy', 'theater', 'movie', 'entertainment'],\n      social: ['party', 'celebration', 'gathering', 'meetup', 'social']\n    }\n\n    const captionLower = caption.toLowerCase()\n\n    for (const [category, keywords] of Object.entries(categoryKeywords)) {\n      if (keywords.some(keyword =&gt; captionLower.includes(keyword))) {\n        return category\n      }\n    }\n\n    return 'other'\n  }\n}\n</code></pre> <p>This comprehensive Instagram MCP server documentation covers web scraping, content analysis, and AI-powered event extraction from Instagram! \ud83d\udcf8</p>"},{"location":"mcp/linkedin/","title":"LinkedIn MCP Server","text":"<p>This document provides comprehensive documentation for the LinkedIn Model Context Protocol (MCP) server integration in Inttrest, enabling professional event discovery from LinkedIn posts and company pages.</p>"},{"location":"mcp/linkedin/#overview","title":"\ud83c\udfaf Overview","text":"<p>The LinkedIn MCP server specializes in discovering professional events, networking opportunities, and business gatherings from LinkedIn content. It leverages LinkedIn's API and web scraping techniques to extract event information from posts, company pages, and professional profiles.</p> <pre><code>graph TB\n    subgraph \"LinkedIn MCP Architecture\"\n        A[MCP Client] --&gt; B[LinkedIn MCP Server]\n        B --&gt; C[LinkedIn API Client]\n        B --&gt; D[Web Scraper Service]\n        B --&gt; E[Professional Event Analyzer]\n\n        C --&gt; F[LinkedIn API v2]\n        C --&gt; G[OAuth Authentication]\n        C --&gt; H[Rate Limiting]\n\n        D --&gt; I[Selenium WebDriver]\n        D --&gt; J[Session Management]\n        D --&gt; K[Content Extraction]\n\n        E --&gt; L[Event Classification]\n        E --&gt; M[Professional Context]\n        E --&gt; N[Network Analysis]\n\n        F --&gt; O[Posts API]\n        F --&gt; P[Companies API]\n        F --&gt; Q[People API]\n\n        L --&gt; R[AI Analysis]\n        M --&gt; S[Industry Mapping]\n        N --&gt; T[Professional Networks]\n    end\n\n    subgraph \"Inttrest Integration\"\n        U[Professional Events] --&gt; A\n        V[Business Networking] --&gt; A\n        W[Industry Events] --&gt; A\n\n        R --&gt; X[Event Database]\n        S --&gt; Y[Professional Categories]\n        T --&gt; Z[Network Insights]\n    end\n\n    style B fill:#e3f2fd\n    style F fill:#e8f5e8\n    style E fill:#fff3e0\n    style R fill:#fce4ec</code></pre>"},{"location":"mcp/linkedin/#installation-setup","title":"\ud83d\udce6 Installation &amp; Setup","text":""},{"location":"mcp/linkedin/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 18+ with npm/pnpm</li> <li>LinkedIn Developer Account with API access</li> <li>Chrome/Chromium for web scraping fallback</li> <li>OpenAI API Key for content analysis</li> </ul>"},{"location":"mcp/linkedin/#installation","title":"Installation","text":"<pre><code># Navigate to LinkedIn MCP server directory\ncd mcp_servers/linkedin-mcp-server\n\n# Install dependencies\nnpm install\n# or\npnpm install\n\n# Install browser for web scraping\nnpx puppeteer browsers install chrome\n\n# Build the server\nnpm run build\n</code></pre>"},{"location":"mcp/linkedin/#configuration","title":"Configuration","text":"<p>Create a <code>.env</code> file in the <code>linkedin-mcp-server</code> directory:</p> <pre><code># LinkedIn API Configuration\nLINKEDIN_CLIENT_ID=your_linkedin_client_id\nLINKEDIN_CLIENT_SECRET=your_linkedin_client_secret\nLINKEDIN_REDIRECT_URI=http://localhost:3000/auth/linkedin/callback\nLINKEDIN_ACCESS_TOKEN=your_linkedin_access_token\n\n# LinkedIn Scraping (Fallback)\nLINKEDIN_EMAIL=your_linkedin_email\nLINKEDIN_PASSWORD=your_linkedin_password\nLINKEDIN_SESSION_FILE=./sessions/linkedin_session.json\n\n# Browser Configuration\nBROWSER_HEADLESS=true\nBROWSER_TIMEOUT=30000\nSELENIUM_DRIVER_PATH=./drivers/chromedriver\n\n# OpenAI Configuration\nOPENAI_API_KEY=your_openai_api_key\nOPENAI_MODEL=gpt-4-turbo-preview\n\n# Rate Limiting\nAPI_RATE_LIMIT=100\nAPI_RATE_WINDOW=3600000  # 1 hour\nSCRAPING_RATE_LIMIT=10\nSCRAPING_RATE_WINDOW=60000  # 1 minute\n\n# Cache Configuration\nCACHE_TTL=1800000  # 30 minutes\nCACHE_MAX_SIZE=1000\n\n# Professional Event Settings\nINDUSTRY_FOCUS=[\"technology\", \"finance\", \"healthcare\", \"marketing\"]\nEVENT_KEYWORDS=[\"conference\", \"seminar\", \"workshop\", \"networking\"]\nCOMPANY_SIZE_FILTER=[\"startup\", \"small\", \"medium\", \"enterprise\"]\n\n# Logging\nLOG_LEVEL=info\nLOG_FILE=linkedin-mcp.log\n</code></pre>"},{"location":"mcp/linkedin/#package-dependencies","title":"Package Dependencies","text":"<pre><code>{\n  \"name\": \"linkedin-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n    \"linkedin-api-v2\": \"^2.0.0\",\n    \"puppeteer\": \"^22.0.0\",\n    \"selenium-webdriver\": \"^4.15.0\",\n    \"openai\": \"^4.20.1\",\n    \"axios\": \"^1.6.0\",\n    \"node-cache\": \"^5.1.2\",\n    \"winston\": \"^3.11.0\",\n    \"zod\": \"^4.1.5\",\n    \"dotenv\": \"^16.3.1\",\n    \"cheerio\": \"^1.0.0-rc.12\",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"uuid\": \"^9.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"@types/selenium-webdriver\": \"^4.1.15\",\n    \"typescript\": \"^5.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"vitest\": \"^1.0.0\"\n  }\n}\n</code></pre>"},{"location":"mcp/linkedin/#server-implementation","title":"\ud83c\udfd7\ufe0f Server Implementation","text":""},{"location":"mcp/linkedin/#core-server-structure","title":"Core Server Structure","text":"<pre><code>// src/linkedin-mcp-server.ts\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js'\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js'\nimport { LinkedInAPIClient } from './services/linkedin-api-client.js'\nimport { LinkedInScraper } from './services/linkedin-scraper.js'\nimport { ProfessionalEventAnalyzer } from './services/professional-event-analyzer.js'\nimport { Logger } from './utils/logger.js'\nimport { z } from 'zod'\n\nconst logger = new Logger('LinkedInMCP')\n\nclass LinkedInMCPServer {\n  private server: Server\n  private apiClient: LinkedInAPIClient\n  private scraper: LinkedInScraper\n  private eventAnalyzer: ProfessionalEventAnalyzer\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'linkedin-mcp-server',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    )\n\n    this.apiClient = new LinkedInAPIClient()\n    this.scraper = new LinkedInScraper()\n    this.eventAnalyzer = new ProfessionalEventAnalyzer()\n\n    this.setupToolHandlers()\n  }\n\n  private setupToolHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: 'search_professional_events',\n            description: 'Search for professional events on LinkedIn',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                keywords: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Keywords for professional event search'\n                },\n                industry: {\n                  type: 'string',\n                  description: 'Industry focus for events'\n                },\n                location: {\n                  type: 'string',\n                  description: 'Geographic location for events'\n                },\n                event_type: {\n                  type: 'string',\n                  enum: ['conference', 'seminar', 'workshop', 'networking', 'webinar'],\n                  description: 'Type of professional event'\n                },\n                company_size: {\n                  type: 'string',\n                  enum: ['startup', 'small', 'medium', 'enterprise'],\n                  description: 'Company size filter'\n                },\n                date_range: {\n                  type: 'object',\n                  properties: {\n                    start: { type: 'string' },\n                    end: { type: 'string' }\n                  },\n                  description: 'Date range for events'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'analyze_company_events',\n            description: 'Analyze a specific company for hosted events',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                company_id: {\n                  type: 'string',\n                  description: 'LinkedIn company ID'\n                },\n                company_name: {\n                  type: 'string',\n                  description: 'Company name to search for'\n                },\n                include_employee_posts: {\n                  type: 'boolean',\n                  description: 'Include events from employee posts'\n                },\n                time_frame: {\n                  type: 'string',\n                  enum: ['week', 'month', 'quarter', 'year'],\n                  description: 'Time frame for event analysis'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'extract_event_from_post',\n            description: 'Extract event details from a LinkedIn post',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                post_id: {\n                  type: 'string',\n                  description: 'LinkedIn post ID'\n                },\n                post_url: {\n                  type: 'string',\n                  description: 'LinkedIn post URL'\n                },\n                analyze_engagement: {\n                  type: 'boolean',\n                  description: 'Analyze post engagement for event popularity'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'discover_industry_events',\n            description: 'Discover events by industry connections and influencers',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                industry: {\n                  type: 'string',\n                  description: 'Target industry for event discovery'\n                },\n                influencer_posts: {\n                  type: 'boolean',\n                  description: 'Include posts from industry influencers'\n                },\n                company_posts: {\n                  type: 'boolean',\n                  description: 'Include posts from industry companies'\n                },\n                network_level: {\n                  type: 'number',\n                  minimum: 1,\n                  maximum: 3,\n                  description: 'Connection degree (1st, 2nd, 3rd)'\n                }\n              },\n              required: ['industry']\n            }\n          },\n          {\n            name: 'monitor_professional_networks',\n            description: 'Monitor professional networks for new events',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                companies: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Companies to monitor'\n                },\n                professionals: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Professional profiles to monitor'\n                },\n                industries: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Industries to monitor'\n                },\n                check_interval: {\n                  type: 'number',\n                  description: 'Monitoring interval in hours'\n                }\n              },\n              required: []\n            }\n          }\n        ]\n      }\n    })\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      try {\n        const { name, arguments: args } = request.params\n\n        switch (name) {\n          case 'search_professional_events':\n            return await this.handleSearchProfessionalEvents(args)\n\n          case 'analyze_company_events':\n            return await this.handleAnalyzeCompanyEvents(args)\n\n          case 'extract_event_from_post':\n            return await this.handleExtractEventFromPost(args)\n\n          case 'discover_industry_events':\n            return await this.handleDiscoverIndustryEvents(args)\n\n          case 'monitor_professional_networks':\n            return await this.handleMonitorNetworks(args)\n\n          default:\n            throw new Error(`Unknown tool: ${name}`)\n        }\n      } catch (error) {\n        logger.error('Tool execution failed:', error)\n        throw error\n      }\n    })\n  }\n\n  private async handleSearchProfessionalEvents(args: any) {\n    const searchParams = ProfessionalEventSearchSchema.parse(args)\n\n    logger.info('Searching for professional events:', searchParams)\n\n    // Try API first, fallback to scraping\n    let posts: any[] = []\n\n    try {\n      posts = await this.apiClient.searchPosts({\n        keywords: searchParams.keywords,\n        industry: searchParams.industry,\n        location: searchParams.location\n      })\n    } catch (apiError) {\n      logger.warn('API search failed, falling back to scraping:', apiError)\n      posts = await this.scraper.searchEventPosts(searchParams)\n    }\n\n    const events = await this.eventAnalyzer.analyzePostsForEvents(posts, {\n      event_type: searchParams.event_type,\n      company_size: searchParams.company_size,\n      date_range: searchParams.date_range\n    })\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Found ${events.length} professional events from ${posts.length} LinkedIn posts`\n        }\n      ],\n      _meta: {\n        source: 'linkedin',\n        search_params: searchParams,\n        posts_analyzed: posts.length,\n        events_found: events.length,\n        events: events\n      }\n    }\n  }\n\n  private async handleAnalyzeCompanyEvents(args: any) {\n    const companyParams = CompanyAnalysisSchema.parse(args)\n\n    logger.info('Analyzing company events:', companyParams)\n\n    let companyData: any\n\n    if (companyParams.company_id) {\n      companyData = await this.apiClient.getCompany(companyParams.company_id)\n    } else if (companyParams.company_name) {\n      companyData = await this.scraper.searchCompany(companyParams.company_name)\n    } else {\n      throw new Error('Either company_id or company_name is required')\n    }\n\n    const events = await this.eventAnalyzer.analyzeCompanyForEvents(\n      companyData,\n      {\n        include_employee_posts: companyParams.include_employee_posts,\n        time_frame: companyParams.time_frame\n      }\n    )\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Analyzed ${companyData.name} and found ${events.length} company events`\n        }\n      ],\n      _meta: {\n        source: 'linkedin',\n        company: companyData,\n        events_found: events.length,\n        events: events\n      }\n    }\n  }\n\n  private async handleExtractEventFromPost(args: any) {\n    const postParams = PostExtractionSchema.parse(args)\n\n    logger.info('Extracting event from LinkedIn post:', postParams)\n\n    let postData: any\n\n    if (postParams.post_id) {\n      postData = await this.apiClient.getPost(postParams.post_id)\n    } else if (postParams.post_url) {\n      postData = await this.scraper.scrapePost(postParams.post_url)\n    } else {\n      throw new Error('Either post_id or post_url is required')\n    }\n\n    const event = await this.eventAnalyzer.extractEventFromPost(\n      postData,\n      { analyze_engagement: postParams.analyze_engagement }\n    )\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: event ? `Extracted professional event: ${event.title}` : 'No event detected in this post'\n        }\n      ],\n      _meta: {\n        source: 'linkedin',\n        post: postData,\n        event_detected: !!event,\n        event: event\n      }\n    }\n  }\n\n  private async handleDiscoverIndustryEvents(args: any) {\n    const industryParams = IndustryDiscoverySchema.parse(args)\n\n    logger.info('Discovering industry events:', industryParams)\n\n    const events = await this.eventAnalyzer.discoverIndustryEvents(industryParams)\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Discovered ${events.length} events in ${industryParams.industry} industry`\n        }\n      ],\n      _meta: {\n        source: 'linkedin',\n        industry: industryParams.industry,\n        discovery_params: industryParams,\n        events_found: events.length,\n        events: events\n      }\n    }\n  }\n\n  private async handleMonitorNetworks(args: any) {\n    const monitorParams = NetworkMonitoringSchema.parse(args)\n\n    logger.info('Setting up professional network monitoring:', monitorParams)\n\n    const monitoringSetup = await this.setupNetworkMonitoring(monitorParams)\n\n    return {\n      content: [\n        {\n          type: 'text',\n          text: `Monitoring setup for ${monitorParams.companies?.length || 0} companies and ${monitorParams.professionals?.length || 0} professionals`\n        }\n      ],\n      _meta: {\n        source: 'linkedin',\n        monitoring_setup: monitoringSetup,\n        params: monitorParams\n      }\n    }\n  }\n\n  private async setupNetworkMonitoring(params: any): Promise&lt;any&gt; {\n    // Implementation for setting up monitoring\n    return {\n      status: 'monitoring_active',\n      targets: {\n        companies: params.companies || [],\n        professionals: params.professionals || [],\n        industries: params.industries || []\n      },\n      check_interval_hours: params.check_interval || 24,\n      next_check: new Date(Date.now() + (params.check_interval || 24) * 60 * 60 * 1000).toISOString()\n    }\n  }\n\n  async start() {\n    try {\n      await this.apiClient.initialize()\n      await this.scraper.initialize()\n\n      const transport = new StdioServerTransport()\n      await this.server.connect(transport)\n\n      logger.info('LinkedIn MCP Server started successfully')\n    } catch (error) {\n      logger.error('Failed to start LinkedIn MCP Server:', error)\n      throw error\n    }\n  }\n\n  async stop() {\n    await this.scraper.close()\n    logger.info('LinkedIn MCP Server stopped')\n  }\n}\n\n// Schema definitions\nconst ProfessionalEventSearchSchema = z.object({\n  keywords: z.array(z.string()).optional(),\n  industry: z.string().optional(),\n  location: z.string().optional(),\n  event_type: z.enum(['conference', 'seminar', 'workshop', 'networking', 'webinar']).optional(),\n  company_size: z.enum(['startup', 'small', 'medium', 'enterprise']).optional(),\n  date_range: z.object({\n    start: z.string(),\n    end: z.string()\n  }).optional()\n})\n\nconst CompanyAnalysisSchema = z.object({\n  company_id: z.string().optional(),\n  company_name: z.string().optional(),\n  include_employee_posts: z.boolean().optional(),\n  time_frame: z.enum(['week', 'month', 'quarter', 'year']).optional()\n})\n\nconst PostExtractionSchema = z.object({\n  post_id: z.string().optional(),\n  post_url: z.string().optional(),\n  analyze_engagement: z.boolean().optional()\n})\n\nconst IndustryDiscoverySchema = z.object({\n  industry: z.string(),\n  influencer_posts: z.boolean().optional(),\n  company_posts: z.boolean().optional(),\n  network_level: z.number().min(1).max(3).optional()\n})\n\nconst NetworkMonitoringSchema = z.object({\n  companies: z.array(z.string()).optional(),\n  professionals: z.array(z.string()).optional(),\n  industries: z.array(z.string()).optional(),\n  check_interval: z.number().optional()\n})\n\n// Start the server\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const server = new LinkedInMCPServer()\n\n  process.on('SIGINT', async () =&gt; {\n    await server.stop()\n    process.exit(0)\n  })\n\n  server.start().catch(console.error)\n}\n\nexport { LinkedInMCPServer }\n</code></pre>"},{"location":"mcp/linkedin/#linkedin-api-client","title":"LinkedIn API Client","text":"<pre><code>// src/services/linkedin-api-client.ts\nimport axios, { AxiosInstance } from 'axios'\nimport jwt from 'jsonwebtoken'\nimport NodeCache from 'node-cache'\nimport { Logger } from '../utils/logger.js'\n\ninterface LinkedInConfig {\n  clientId: string\n  clientSecret: string\n  redirectUri: string\n  accessToken?: string\n}\n\ninterface SearchParams {\n  keywords?: string[]\n  industry?: string\n  location?: string\n  companyId?: string\n}\n\nexport class LinkedInAPIClient {\n  private client: AxiosInstance\n  private config: LinkedInConfig\n  private cache: NodeCache\n  private logger: Logger\n  private accessToken: string | null = null\n\n  constructor() {\n    this.logger = new Logger('LinkedInAPI')\n    this.config = this.loadConfig()\n\n    this.client = axios.create({\n      baseURL: 'https://api.linkedin.com/v2',\n      timeout: 30000,\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Restli-Protocol-Version': '2.0.0'\n      }\n    })\n\n    this.cache = new NodeCache({\n      stdTTL: parseInt(process.env.CACHE_TTL || '1800'), // 30 minutes\n      maxKeys: parseInt(process.env.CACHE_MAX_SIZE || '1000')\n    })\n\n    this.setupInterceptors()\n  }\n\n  private loadConfig(): LinkedInConfig {\n    const requiredEnvVars = ['LINKEDIN_CLIENT_ID', 'LINKEDIN_CLIENT_SECRET']\n\n    for (const envVar of requiredEnvVars) {\n      if (!process.env[envVar]) {\n        throw new Error(`Missing required environment variable: ${envVar}`)\n      }\n    }\n\n    return {\n      clientId: process.env.LINKEDIN_CLIENT_ID!,\n      clientSecret: process.env.LINKEDIN_CLIENT_SECRET!,\n      redirectUri: process.env.LINKEDIN_REDIRECT_URI!,\n      accessToken: process.env.LINKEDIN_ACCESS_TOKEN\n    }\n  }\n\n  private setupInterceptors() {\n    this.client.interceptors.request.use(\n      (config) =&gt; {\n        if (this.accessToken) {\n          config.headers.Authorization = `Bearer ${this.accessToken}`\n        }\n        this.logger.debug(`API Request: ${config.method?.toUpperCase()} ${config.url}`)\n        return config\n      },\n      (error) =&gt; {\n        this.logger.error('API Request Error:', error)\n        return Promise.reject(error)\n      }\n    )\n\n    this.client.interceptors.response.use(\n      (response) =&gt; {\n        this.logger.debug(`API Response: ${response.status} ${response.config.url}`)\n        return response\n      },\n      (error) =&gt; {\n        this.logger.error('API Response Error:', {\n          status: error.response?.status,\n          statusText: error.response?.statusText,\n          url: error.config?.url\n        })\n        return Promise.reject(error)\n      }\n    )\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    if (this.config.accessToken) {\n      this.accessToken = this.config.accessToken\n\n      // Validate token\n      try {\n        await this.getCurrentUser()\n        this.logger.info('LinkedIn API initialized with existing token')\n        return\n      } catch (error) {\n        this.logger.warn('Existing token invalid, need to refresh')\n      }\n    }\n\n    // If no valid token, would need OAuth flow\n    this.logger.warn('No valid LinkedIn access token available')\n  }\n\n  async getCurrentUser(): Promise&lt;any&gt; {\n    const cacheKey = 'current_user'\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      return cached\n    }\n\n    try {\n      const response = await this.client.get('/me')\n      const user = response.data\n\n      this.cache.set(cacheKey, user, 3600) // Cache for 1 hour\n      return user\n\n    } catch (error) {\n      this.logger.error('Failed to get current user:', error)\n      throw error\n    }\n  }\n\n  async searchPosts(params: SearchParams): Promise&lt;any[]&gt; {\n    const cacheKey = `posts:${JSON.stringify(params)}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      this.logger.debug('Returning cached posts')\n      return cached\n    }\n\n    try {\n      // LinkedIn's search API is limited, this is a simplified example\n      const queryParams: any = {\n        count: 50,\n        start: 0\n      }\n\n      if (params.keywords?.length) {\n        queryParams.keywords = params.keywords.join(' ')\n      }\n\n      // Note: Actual LinkedIn API has different endpoints and parameters\n      const response = await this.client.get('/shares', {\n        params: queryParams\n      })\n\n      const posts = response.data.elements || []\n      this.cache.set(cacheKey, posts)\n\n      this.logger.info(`Found ${posts.length} posts`)\n      return posts\n\n    } catch (error) {\n      this.logger.error('Post search failed:', error)\n      throw error\n    }\n  }\n\n  async getCompany(companyId: string): Promise&lt;any&gt; {\n    const cacheKey = `company:${companyId}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      return cached\n    }\n\n    try {\n      const response = await this.client.get(`/companies/${companyId}`)\n      const company = response.data\n\n      this.cache.set(cacheKey, company, 3600) // Cache for 1 hour\n      return company\n\n    } catch (error) {\n      this.logger.error('Failed to get company:', error)\n      throw error\n    }\n  }\n\n  async getCompanyPosts(companyId: string, options: any = {}): Promise&lt;any[]&gt; {\n    const cacheKey = `company_posts:${companyId}:${JSON.stringify(options)}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      return cached\n    }\n\n    try {\n      const response = await this.client.get(`/companies/${companyId}/updates`, {\n        params: {\n          count: options.count || 25,\n          start: options.start || 0,\n          'event-type': 'status-update'\n        }\n      })\n\n      const posts = response.data.values || []\n      this.cache.set(cacheKey, posts)\n\n      return posts\n\n    } catch (error) {\n      this.logger.error('Failed to get company posts:', error)\n      throw error\n    }\n  }\n\n  async getPost(postId: string): Promise&lt;any&gt; {\n    const cacheKey = `post:${postId}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      return cached\n    }\n\n    try {\n      const response = await this.client.get(`/shares/${postId}`)\n      const post = response.data\n\n      this.cache.set(cacheKey, post, 1800) // Cache for 30 minutes\n      return post\n\n    } catch (error) {\n      this.logger.error('Failed to get post:', error)\n      throw error\n    }\n  }\n\n  async searchCompanies(query: string): Promise&lt;any[]&gt; {\n    const cacheKey = `company_search:${query}`\n    const cached = this.cache.get(cacheKey)\n\n    if (cached) {\n      return cached\n    }\n\n    try {\n      const response = await this.client.get('/companySearch', {\n        params: {\n          keywords: query,\n          count: 25\n        }\n      })\n\n      const companies = response.data.companies?.values || []\n      this.cache.set(cacheKey, companies)\n\n      return companies\n\n    } catch (error) {\n      this.logger.error('Company search failed:', error)\n      throw error\n    }\n  }\n\n  async getIndustryInsights(industry: string): Promise&lt;any&gt; {\n    // This would use LinkedIn's industry insights API\n    // Placeholder implementation\n\n    return {\n      industry: industry,\n      top_companies: [],\n      trending_topics: [],\n      recent_posts: []\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/linkedin/#professional-event-analyzer","title":"Professional Event Analyzer","text":"<pre><code>// src/services/professional-event-analyzer.ts\nimport OpenAI from 'openai'\nimport { Logger } from '../utils/logger.js'\n\ninterface ProfessionalEvent {\n  id: string\n  title: string\n  description: string\n  type: 'conference' | 'seminar' | 'workshop' | 'networking' | 'webinar' | 'other'\n  industry: string\n  start_date?: string\n  end_date?: string\n  location?: {\n    name: string\n    address?: string\n    is_virtual: boolean\n  }\n  organizer: {\n    name: string\n    type: 'company' | 'individual' | 'organization'\n    linkedin_id?: string\n    industry?: string\n    company_size?: string\n  }\n  target_audience: {\n    seniority_levels: string[]\n    job_functions: string[]\n    industries: string[]\n  }\n  registration_info: {\n    is_free: boolean\n    price?: string\n    registration_url?: string\n    capacity?: number\n    registration_deadline?: string\n  }\n  networking_value: {\n    attendee_quality_score: number\n    industry_relevance_score: number\n    career_growth_potential: number\n  }\n  source_post: {\n    url: string\n    linkedin_id: string\n    engagement: {\n      likes: number\n      comments: number\n      shares: number\n      engagement_rate: number\n    }\n  }\n  confidence_score: number\n  extracted_at: string\n}\n\nexport class ProfessionalEventAnalyzer {\n  private openai: OpenAI\n  private logger: Logger\n\n  constructor() {\n    this.logger = new Logger('ProfessionalEventAnalyzer')\n\n    if (!process.env.OPENAI_API_KEY) {\n      throw new Error('OPENAI_API_KEY is required for content analysis')\n    }\n\n    this.openai = new OpenAI({\n      apiKey: process.env.OPENAI_API_KEY\n    })\n  }\n\n  async analyzePostsForEvents(posts: any[], filters: any = {}): Promise&lt;ProfessionalEvent[]&gt; {\n    this.logger.info(`Analyzing ${posts.length} LinkedIn posts for professional events`)\n\n    const events: ProfessionalEvent[] = []\n\n    for (const post of posts) {\n      try {\n        const event = await this.extractEventFromPost(post, { deep_analysis: true })\n        if (event &amp;&amp; this.matchesFilters(event, filters)) {\n          events.push(event)\n        }\n      } catch (error) {\n        this.logger.debug(`Failed to analyze post ${post.id}:`, error)\n      }\n    }\n\n    // Sort by confidence and networking value\n    events.sort((a, b) =&gt; {\n      const scoreA = a.confidence_score * a.networking_value.attendee_quality_score\n      const scoreB = b.confidence_score * b.networking_value.attendee_quality_score\n      return scoreB - scoreA\n    })\n\n    this.logger.info(`Extracted ${events.length} professional events`)\n    return events\n  }\n\n  async analyzeCompanyForEvents(companyData: any, options: any = {}): Promise&lt;ProfessionalEvent[]&gt; {\n    this.logger.info(`Analyzing company ${companyData.name} for events`)\n\n    // Get company posts\n    let posts = companyData.posts || []\n\n    if (options.include_employee_posts) {\n      // Would need to fetch employee posts\n      // This is a simplified implementation\n    }\n\n    // Filter by time frame\n    if (options.time_frame) {\n      posts = this.filterPostsByTimeFrame(posts, options.time_frame)\n    }\n\n    const events = await this.analyzePostsForEvents(posts)\n\n    // Add company context to events\n    return events.map(event =&gt; ({\n      ...event,\n      organizer: {\n        ...event.organizer,\n        name: companyData.name,\n        type: 'company' as const,\n        linkedin_id: companyData.id,\n        industry: companyData.industry,\n        company_size: this.categorizeCompanySize(companyData.employeeCount)\n      }\n    }))\n  }\n\n  async extractEventFromPost(post: any, options: any = {}): Promise&lt;ProfessionalEvent | null&gt; {\n    try {\n      // Quick keyword filtering for professional events\n      if (!this.containsProfessionalEventKeywords(post.text || post.content || '')) {\n        return null\n      }\n\n      if (options.deep_analysis) {\n        return await this.performProfessionalAIAnalysis(post, options)\n      } else {\n        return await this.performBasicProfessionalAnalysis(post)\n      }\n\n    } catch (error) {\n      this.logger.error(`Failed to extract event from post ${post.id}:`, error)\n      return null\n    }\n  }\n\n  async discoverIndustryEvents(params: any): Promise&lt;ProfessionalEvent[]&gt; {\n    this.logger.info(`Discovering events in ${params.industry} industry`)\n\n    const events: ProfessionalEvent[] = []\n\n    // This would implement industry-specific event discovery\n    // Placeholder implementation\n\n    return events\n  }\n\n  private containsProfessionalEventKeywords(text: string): boolean {\n    const professionalEventKeywords = [\n      // Event types\n      'conference', 'summit', 'symposium', 'convention', 'expo', 'trade show',\n      'seminar', 'workshop', 'masterclass', 'training', 'certification',\n      'webinar', 'virtual event', 'online session', 'live stream',\n      'networking', 'mixer', 'meetup', 'panel discussion', 'roundtable',\n\n      // Professional contexts\n      'professional development', 'career growth', 'industry insights',\n      'thought leadership', 'best practices', 'innovation', 'digital transformation',\n\n      // Registration/attendance\n      'register now', 'rsvp', 'limited seats', 'early bird', 'save the date',\n      'join us', 'don\\'t miss', 'exclusive event', 'invitation only',\n\n      // Business contexts\n      'c-suite', 'executives', 'leaders', 'professionals', 'entrepreneurs',\n      'startup', 'enterprise', 'fortune 500', 'industry leaders'\n    ]\n\n    const textLower = text.toLowerCase()\n    return professionalEventKeywords.some(keyword =&gt; textLower.includes(keyword))\n  }\n\n  private async performBasicProfessionalAnalysis(post: any): Promise&lt;ProfessionalEvent | null&gt; {\n    const content = post.text || post.content || ''\n\n    // Extract professional event indicators\n    const eventType = this.inferEventType(content)\n    const industry = this.inferIndustry(content)\n    const audienceLevel = this.inferAudienceLevel(content)\n\n    if (!eventType || !industry) {\n      return null\n    }\n\n    return {\n      id: `basic_${post.id}`,\n      title: this.extractProfessionalTitle(content),\n      description: content,\n      type: eventType,\n      industry: industry,\n      target_audience: {\n        seniority_levels: audienceLevel ? [audienceLevel] : [],\n        job_functions: this.inferJobFunctions(content),\n        industries: [industry]\n      },\n      organizer: {\n        name: post.author?.name || 'Professional',\n        type: this.inferOrganizerType(post)\n      },\n      networking_value: {\n        attendee_quality_score: this.calculateAttendeeQualityScore(post),\n        industry_relevance_score: 0.7,\n        career_growth_potential: 0.6\n      },\n      registration_info: {\n        is_free: this.inferIsFree(content)\n      },\n      source_post: {\n        url: post.url || '',\n        linkedin_id: post.id,\n        engagement: this.extractEngagement(post)\n      },\n      confidence_score: 0.6,\n      extracted_at: new Date().toISOString()\n    }\n  }\n\n  private async performProfessionalAIAnalysis(post: any, options: any): Promise&lt;ProfessionalEvent | null&gt; {\n    try {\n      const prompt = this.buildProfessionalAnalysisPrompt(post)\n\n      const response = await this.openai.chat.completions.create({\n        model: process.env.OPENAI_MODEL || 'gpt-4-turbo-preview',\n        messages: [\n          {\n            role: 'system',\n            content: 'You are an expert at analyzing LinkedIn posts for professional events, networking opportunities, and business gatherings. Extract detailed professional event information.'\n          },\n          {\n            role: 'user',\n            content: prompt\n          }\n        ],\n        functions: [\n          {\n            name: 'extract_professional_event',\n            description: 'Extract professional event information from LinkedIn post',\n            parameters: {\n              type: 'object',\n              properties: {\n                is_professional_event: {\n                  type: 'boolean',\n                  description: 'Whether this is a professional/business event'\n                },\n                event_title: {\n                  type: 'string',\n                  description: 'Professional event title'\n                },\n                event_type: {\n                  type: 'string',\n                  enum: ['conference', 'seminar', 'workshop', 'networking', 'webinar', 'other'],\n                  description: 'Type of professional event'\n                },\n                industry: {\n                  type: 'string',\n                  description: 'Primary industry focus'\n                },\n                target_seniority: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Target seniority levels (entry, mid, senior, executive)'\n                },\n                target_functions: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Target job functions'\n                },\n                networking_value: {\n                  type: 'number',\n                  description: 'Networking value score 0-1'\n                },\n                career_growth_potential: {\n                  type: 'number',\n                  description: 'Career growth potential score 0-1'\n                },\n                organizer_type: {\n                  type: 'string',\n                  enum: ['company', 'individual', 'organization'],\n                  description: 'Type of event organizer'\n                },\n                is_virtual: {\n                  type: 'boolean',\n                  description: 'Whether the event is virtual'\n                },\n                registration_required: {\n                  type: 'boolean',\n                  description: 'Whether registration is required'\n                },\n                is_free: {\n                  type: 'boolean',\n                  description: 'Whether the event is free'\n                },\n                confidence_score: {\n                  type: 'number',\n                  description: 'Confidence score 0-1'\n                }\n              },\n              required: ['is_professional_event', 'confidence_score']\n            }\n          }\n        ],\n        function_call: { name: 'extract_professional_event' }\n      })\n\n      const functionCall = response.choices[0]?.message?.function_call\n      if (!functionCall || functionCall.name !== 'extract_professional_event') {\n        return null\n      }\n\n      const extractedData = JSON.parse(functionCall.arguments)\n\n      if (!extractedData.is_professional_event || extractedData.confidence_score &lt; 0.6) {\n        return null\n      }\n\n      return {\n        id: `ai_professional_${post.id}`,\n        title: extractedData.event_title || this.extractProfessionalTitle(post.content),\n        description: post.content || post.text || '',\n        type: extractedData.event_type || 'other',\n        industry: extractedData.industry || 'general',\n        location: {\n          name: extractedData.is_virtual ? 'Virtual Event' : 'TBD',\n          is_virtual: extractedData.is_virtual || false\n        },\n        target_audience: {\n          seniority_levels: extractedData.target_seniority || [],\n          job_functions: extractedData.target_functions || [],\n          industries: [extractedData.industry || 'general']\n        },\n        organizer: {\n          name: post.author?.name || 'Professional',\n          type: extractedData.organizer_type || 'individual'\n        },\n        networking_value: {\n          attendee_quality_score: extractedData.networking_value || 0.5,\n          industry_relevance_score: 0.8,\n          career_growth_potential: extractedData.career_growth_potential || 0.6\n        },\n        registration_info: {\n          is_free: extractedData.is_free || false\n        },\n        source_post: {\n          url: post.url || '',\n          linkedin_id: post.id,\n          engagement: this.extractEngagement(post)\n        },\n        confidence_score: extractedData.confidence_score,\n        extracted_at: new Date().toISOString()\n      }\n\n    } catch (error) {\n      this.logger.error('Professional AI analysis failed:', error)\n      return this.performBasicProfessionalAnalysis(post)\n    }\n  }\n\n  private buildProfessionalAnalysisPrompt(post: any): string {\n    return `\nAnalyze this LinkedIn post for professional event information:\n\nPost Content: ${post.text || post.content || ''}\n\nAuthor: ${post.author?.name || 'Unknown'}\nAuthor Title: ${post.author?.headline || 'Unknown'}\nCompany: ${post.author?.company || 'Unknown'}\n\nEngagement: ${post.likes || 0} likes, ${post.comments || 0} comments, ${post.shares || 0} shares\n\nPlease analyze if this is promoting a professional event and extract:\n- Event type and industry focus\n- Target professional audience (seniority, functions)\n- Networking and career growth value\n- Registration and attendance details\n- Overall professional relevance\n\nFocus on business value, networking opportunities, and professional development aspects.\n`\n  }\n\n  private inferEventType(content: string): ProfessionalEvent['type'] | null {\n    const contentLower = content.toLowerCase()\n\n    if (contentLower.includes('conference') || contentLower.includes('summit')) return 'conference'\n    if (contentLower.includes('seminar') || contentLower.includes('symposium')) return 'seminar'\n    if (contentLower.includes('workshop') || contentLower.includes('training')) return 'workshop'\n    if (contentLower.includes('networking') || contentLower.includes('mixer')) return 'networking'\n    if (contentLower.includes('webinar') || contentLower.includes('virtual')) return 'webinar'\n\n    return null\n  }\n\n  private inferIndustry(content: string): string {\n    const industryKeywords = {\n      technology: ['tech', 'software', 'ai', 'machine learning', 'data', 'cloud', 'cybersecurity'],\n      finance: ['finance', 'fintech', 'banking', 'investment', 'crypto', 'blockchain'],\n      healthcare: ['healthcare', 'medical', 'pharma', 'biotech', 'health'],\n      marketing: ['marketing', 'advertising', 'brand', 'digital marketing', 'seo'],\n      consulting: ['consulting', 'strategy', 'management', 'advisory'],\n      manufacturing: ['manufacturing', 'industrial', 'automation', 'supply chain'],\n      education: ['education', 'learning', 'training', 'academic', 'university'],\n      real_estate: ['real estate', 'property', 'construction', 'architecture']\n    }\n\n    const contentLower = content.toLowerCase()\n\n    for (const [industry, keywords] of Object.entries(industryKeywords)) {\n      if (keywords.some(keyword =&gt; contentLower.includes(keyword))) {\n        return industry\n      }\n    }\n\n    return 'general'\n  }\n\n  private inferAudienceLevel(content: string): string | null {\n    const contentLower = content.toLowerCase()\n\n    if (contentLower.includes('c-suite') || contentLower.includes('ceo') || contentLower.includes('executive')) {\n      return 'executive'\n    }\n    if (contentLower.includes('senior') || contentLower.includes('director') || contentLower.includes('vp')) {\n      return 'senior'\n    }\n    if (contentLower.includes('manager') || contentLower.includes('lead')) {\n      return 'mid'\n    }\n    if (contentLower.includes('junior') || contentLower.includes('entry') || contentLower.includes('graduate')) {\n      return 'entry'\n    }\n\n    return null\n  }\n\n  private inferJobFunctions(content: string): string[] {\n    const functions: string[] = []\n    const contentLower = content.toLowerCase()\n\n    const functionKeywords = {\n      'engineering': ['engineer', 'developer', 'programmer', 'technical'],\n      'sales': ['sales', 'business development', 'account management'],\n      'marketing': ['marketing', 'brand', 'content', 'digital'],\n      'hr': ['hr', 'human resources', 'talent', 'recruiting'],\n      'finance': ['finance', 'accounting', 'controller', 'cfo'],\n      'operations': ['operations', 'project management', 'logistics'],\n      'product': ['product manager', 'product owner', 'ux', 'ui']\n    }\n\n    for (const [func, keywords] of Object.entries(functionKeywords)) {\n      if (keywords.some(keyword =&gt; contentLower.includes(keyword))) {\n        functions.push(func)\n      }\n    }\n\n    return functions\n  }\n\n  private inferOrganizerType(post: any): 'company' | 'individual' | 'organization' {\n    if (post.author?.company || post.isCompanyPost) {\n      return 'company'\n    }\n\n    // Check if it's from a professional organization\n    const authorName = post.author?.name?.toLowerCase() || ''\n    if (authorName.includes('association') || authorName.includes('institute') || \n        authorName.includes('foundation') || authorName.includes('society')) {\n      return 'organization'\n    }\n\n    return 'individual'\n  }\n\n  private calculateAttendeeQualityScore(post: any): number {\n    let score = 0.5 // Base score\n\n    // Higher score for company posts\n    if (post.isCompanyPost) score += 0.2\n\n    // Higher score for verified accounts\n    if (post.author?.isVerified) score += 0.1\n\n    // Higher score based on engagement\n    const engagement = this.extractEngagement(post)\n    if (engagement.engagement_rate &gt; 0.05) score += 0.1\n    if (engagement.engagement_rate &gt; 0.1) score += 0.1\n\n    return Math.min(score, 1.0)\n  }\n\n  private inferIsFree(content: string): boolean {\n    const contentLower = content.toLowerCase()\n    return contentLower.includes('free') || \n           contentLower.includes('no cost') || \n           contentLower.includes('complimentary')\n  }\n\n  private extractEngagement(post: any): any {\n    const likes = post.likes || post.reactions || 0\n    const comments = post.comments || 0\n    const shares = post.shares || post.reposts || 0\n    const total = likes + comments + shares\n\n    // Estimate reach for engagement rate calculation\n    const estimatedReach = (post.author?.followers || 1000) * 0.1 // Assume 10% reach\n    const engagementRate = estimatedReach &gt; 0 ? total / estimatedReach : 0\n\n    return {\n      likes,\n      comments,\n      shares,\n      engagement_rate: Math.min(engagementRate, 1.0)\n    }\n  }\n\n  private extractProfessionalTitle(content: string): string {\n    // Extract first line that looks like a title\n    const lines = content.split('\\n').filter(line =&gt; line.trim())\n    if (lines.length &gt; 0) {\n      const firstLine = lines[0].trim()\n      return firstLine.slice(0, 100)\n    }\n    return 'Professional Event'\n  }\n\n  private matchesFilters(event: ProfessionalEvent, filters: any): boolean {\n    if (filters.event_type &amp;&amp; event.type !== filters.event_type) {\n      return false\n    }\n\n    if (filters.company_size &amp;&amp; event.organizer.company_size !== filters.company_size) {\n      return false\n    }\n\n    if (filters.date_range &amp;&amp; event.start_date) {\n      const eventDate = new Date(event.start_date)\n      const startDate = new Date(filters.date_range.start)\n      const endDate = new Date(filters.date_range.end)\n\n      if (eventDate &lt; startDate || eventDate &gt; endDate) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private filterPostsByTimeFrame(posts: any[], timeFrame: string): any[] {\n    const now = new Date()\n    let cutoffDate: Date\n\n    switch (timeFrame) {\n      case 'week':\n        cutoffDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)\n        break\n      case 'month':\n        cutoffDate = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)\n        break\n      case 'quarter':\n        cutoffDate = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000)\n        break\n      case 'year':\n        cutoffDate = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000)\n        break\n      default:\n        return posts\n    }\n\n    return posts.filter(post =&gt; {\n      const postDate = new Date(post.createdAt || post.timestamp)\n      return postDate &gt;= cutoffDate\n    })\n  }\n\n  private categorizeCompanySize(employeeCount: number): string {\n    if (employeeCount &lt;= 10) return 'startup'\n    if (employeeCount &lt;= 50) return 'small'\n    if (employeeCount &lt;= 1000) return 'medium'\n    return 'enterprise'\n  }\n}\n</code></pre> <p>This comprehensive LinkedIn MCP server documentation covers professional event discovery, company analysis, and industry-specific networking opportunities! \ud83d\udcbc</p>"},{"location":"mcp/meetup/","title":"Meetup MCP Server","text":"<p>This document provides comprehensive documentation for the Meetup Model Context Protocol (MCP) server integration in Inttrest, enabling community-driven event discovery from Meetup.com.</p>"},{"location":"mcp/meetup/#overview","title":"\ud83c\udfaf Overview","text":"<p>The Meetup MCP server integrates with Meetup.com's API and web scraping capabilities to discover community events, local gatherings, and interest-based meetups. It specializes in grassroots community events and recurring group activities.</p> <pre><code>graph TB\n    subgraph \"Meetup MCP Architecture\"\n        A[MCP Client] --&gt; B[Meetup MCP Server]\n        B --&gt; C[Meetup API Client]\n        B --&gt; D[Community Scraper]\n        B --&gt; E[Group Analyzer]\n        B --&gt; F[Event Recommender]\n\n        C --&gt; G[Meetup REST API]\n        C --&gt; H[GraphQL API]\n        C --&gt; I[OAuth Authentication]\n\n        D --&gt; J[Group Discovery]\n        D --&gt; K[Event Extraction]\n        D --&gt; L[Member Analysis]\n\n        E --&gt; M[Community Insights]\n        E --&gt; N[Group Health Score]\n        E --&gt; O[Activity Patterns]\n\n        F --&gt; P[Interest Matching]\n        F --&gt; Q[Location Filtering]\n        F --&gt; R[Time Preferences]\n\n        G --&gt; S[Events API]\n        G --&gt; T[Groups API]\n        G --&gt; U[Members API]\n        G --&gt; V[Categories API]\n    end\n\n    subgraph \"Inttrest Integration\"\n        W[Community Events] --&gt; A\n        X[Local Meetups] --&gt; A\n        Y[Interest Groups] --&gt; A\n\n        M --&gt; Z[Community Database]\n        P --&gt; AA[Recommendation Engine]\n        Q --&gt; BB[Geographic Search]\n    end\n\n    style B fill:#e3f2fd\n    style G fill:#e8f5e8\n    style E fill:#fff3e0\n    style F fill:#fce4ec</code></pre>"},{"location":"mcp/meetup/#installation-setup","title":"\ud83d\udce6 Installation &amp; Setup","text":""},{"location":"mcp/meetup/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js 18+ with npm/pnpm</li> <li>Meetup Pro Account or API access</li> <li>Chrome/Chromium for web scraping fallback</li> <li>Redis for caching (optional)</li> </ul>"},{"location":"mcp/meetup/#installation","title":"Installation","text":"<pre><code># Navigate to Meetup MCP server directory\ncd mcp_servers/mcp-meetup\n\n# Install dependencies\nnpm install\n# or\npnpm install\n\n# Install browser for web scraping\nnpx puppeteer browsers install chrome\n\n# Build the server\nnpm run build\n</code></pre>"},{"location":"mcp/meetup/#configuration","title":"Configuration","text":"<p>Create a <code>.env</code> file in the <code>mcp-meetup</code> directory:</p> <pre><code># Meetup API Configuration\nMEETUP_API_KEY=your_meetup_api_key\nMEETUP_CLIENT_ID=your_oauth_client_id\nMEETUP_CLIENT_SECRET=your_oauth_client_secret\nMEETUP_REDIRECT_URI=http://localhost:3000/auth/meetup/callback\nMEETUP_ACCESS_TOKEN=your_access_token\n\n# Meetup Web Scraping (Fallback)\nMEETUP_EMAIL=your_meetup_email\nMEETUP_PASSWORD=your_meetup_password\n\n# Geographic Configuration\nDEFAULT_RADIUS=25  # miles\nMAX_RADIUS=100\nDEFAULT_LOCATION=37.7749,-122.4194  # San Francisco coordinates\n\n# Event Filtering\nMAX_EVENTS_PER_REQUEST=50\nDEFAULT_DAYS_AHEAD=30\nMAX_DAYS_AHEAD=365\n\n# Categories of Interest\nFEATURED_CATEGORIES=[\"tech\", \"business\", \"health\", \"arts\", \"sports\", \"food\", \"photography\"]\nEXCLUDE_CATEGORIES=[\"dating\", \"singles\"]\n\n# Cache Configuration\nREDIS_URL=redis://localhost:6379\nCACHE_TTL=3600000  # 1 hour\nCACHE_MAX_SIZE=2000\n\n# Rate Limiting\nAPI_RATE_LIMIT=200\nAPI_RATE_WINDOW=3600000  # 1 hour\nSCRAPING_RATE_LIMIT=20\nSCRAPING_RATE_WINDOW=300000  # 5 minutes\n\n# Group Analysis\nMIN_GROUP_MEMBERS=10\nMIN_GROUP_ACTIVITY_SCORE=3\nFEATURED_GROUP_MIN_MEMBERS=100\n\n# Browser Configuration\nBROWSER_HEADLESS=true\nBROWSER_TIMEOUT=30000\n\n# Logging\nLOG_LEVEL=info\nLOG_FILE=meetup-mcp.log\n</code></pre>"},{"location":"mcp/meetup/#package-dependencies","title":"Package Dependencies","text":"<pre><code>{\n  \"name\": \"meetup-mcp-server\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.17.4\",\n    \"axios\": \"^1.6.0\",\n    \"puppeteer\": \"^22.0.0\",\n    \"node-cache\": \"^5.1.2\",\n    \"redis\": \"^4.6.0\",\n    \"winston\": \"^3.11.0\",\n    \"zod\": \"^4.1.5\",\n    \"dotenv\": \"^16.3.1\",\n    \"cheerio\": \"^1.0.0-rc.12\",\n    \"geolib\": \"^3.3.4\",\n    \"moment\": \"^2.29.4\",\n    \"uuid\": \"^9.0.1\",\n    \"lodash\": \"^4.17.21\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"@types/lodash\": \"^4.14.0\",\n    \"typescript\": \"^5.0.0\",\n    \"tsx\": \"^4.0.0\",\n    \"vitest\": \"^1.0.0\"\n  }\n}\n</code></pre>"},{"location":"mcp/meetup/#server-implementation","title":"\ud83c\udfd7\ufe0f Server Implementation","text":""},{"location":"mcp/meetup/#core-server-structure","title":"Core Server Structure","text":"<pre><code>// src/meetup-mcp-server.ts\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js'\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js'\nimport { MeetupAPIClient } from './services/meetup-api-client.js'\nimport { CommunityAnalyzer } from './services/community-analyzer.js'\nimport { EventRecommender } from './services/event-recommender.js'\nimport { MeetupScraper } from './services/meetup-scraper.js'\nimport { Logger } from './utils/logger.js'\nimport { z } from 'zod'\n\nconst logger = new Logger('MeetupMCP')\n\nclass MeetupMCPServer {\n  private server: Server\n  private apiClient: MeetupAPIClient\n  private communityAnalyzer: CommunityAnalyzer\n  private eventRecommender: EventRecommender\n  private scraper: MeetupScraper\n\n  constructor() {\n    this.server = new Server(\n      {\n        name: 'meetup-mcp-server',\n        version: '1.0.0',\n      },\n      {\n        capabilities: {\n          tools: {},\n        },\n      }\n    )\n\n    this.apiClient = new MeetupAPIClient()\n    this.communityAnalyzer = new CommunityAnalyzer()\n    this.eventRecommender = new EventRecommender()\n    this.scraper = new MeetupScraper()\n\n    this.setupToolHandlers()\n  }\n\n  private setupToolHandlers() {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return {\n        tools: [\n          {\n            name: 'search_meetup_events',\n            description: 'Search for Meetup events by location and interests',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                location: {\n                  type: 'string',\n                  description: 'Location (city, zip code, or coordinates)'\n                },\n                radius: {\n                  type: 'number',\n                  minimum: 1,\n                  maximum: 100,\n                  description: 'Search radius in miles'\n                },\n                categories: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Event categories of interest'\n                },\n                keywords: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Keywords to search for'\n                },\n                date_range: {\n                  type: 'object',\n                  properties: {\n                    start: { type: 'string' },\n                    end: { type: 'string' }\n                  },\n                  description: 'Date range for events'\n                },\n                group_size_min: {\n                  type: 'number',\n                  description: 'Minimum group size'\n                },\n                event_status: {\n                  type: 'string',\n                  enum: ['upcoming', 'past', 'proposed', 'suggested'],\n                  description: 'Event status filter'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'discover_local_groups',\n            description: 'Discover active Meetup groups in an area',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                location: {\n                  type: 'string',\n                  description: 'Location to search for groups'\n                },\n                categories: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Group categories of interest'\n                },\n                min_members: {\n                  type: 'number',\n                  description: 'Minimum number of group members'\n                },\n                activity_level: {\n                  type: 'string',\n                  enum: ['low', 'medium', 'high'],\n                  description: 'Required group activity level'\n                },\n                include_new_groups: {\n                  type: 'boolean',\n                  description: 'Include recently created groups'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'analyze_group_health',\n            description: 'Analyze the health and activity of a Meetup group',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                group_id: {\n                  type: 'string',\n                  description: 'Meetup group ID'\n                },\n                group_url: {\n                  type: 'string',\n                  description: 'Meetup group URL'\n                },\n                analyze_members: {\n                  type: 'boolean',\n                  description: 'Include member activity analysis'\n                },\n                analyze_events: {\n                  type: 'boolean',\n                  description: 'Include event history analysis'\n                },\n                time_period: {\n                  type: 'string',\n                  enum: ['month', 'quarter', 'year'],\n                  description: 'Time period for analysis'\n                }\n              },\n              required: []\n            }\n          },\n          {\n            name: 'get_personalized_recommendations',\n            description: 'Get personalized event recommendations based on interests',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                interests: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'User interests and hobbies'\n                },\n                location: {\n                  type: 'string',\n                  description: 'User location'\n                },\n                availability: {\n                  type: 'object',\n                  properties: {\n                    weekdays: { type: 'boolean' },\n                    weekends: { type: 'boolean' },\n                    evenings: { type: 'boolean' },\n                    mornings: { type: 'boolean' }\n                  },\n                  description: 'Time availability preferences'\n                },\n                group_size_preference: {\n                  type: 'string',\n                  enum: ['small', 'medium', 'large', 'any'],\n                  description: 'Preferred group size'\n                },\n                experience_level: {\n                  type: 'string',\n                  enum: ['beginner', 'intermediate', 'advanced', 'any'],\n                  description: 'Experience level in interests'\n                }\n              },\n              required: ['interests', 'location']\n            }\n          },\n          {\n            name: 'monitor_group_activities',\n            description: 'Monitor specific groups for new events and updates',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                groups: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Group IDs or URLs to monitor'\n                },\n                notification_types: {\n                  type: 'array',\n                  items: { \n                    type: 'string',\n                    enum: ['new_events', 'event_updates', 'group_updates', 'new_members']\n                  },\n                  description: 'Types of notifications to monitor'\n                },\n                check_interval: {\n                  type: 'number',\n                  description: 'Check interval in hours'\n                }\n              },\n              required: ['groups']\n            }\n          },\n          {\n            name: 'analyze_event_trends',\n            description: 'Analyze trends in local Meetup events',\n            inputSchema: {\n              type: 'object',\n              properties: {\n                location: {\n                  type: 'string',\n                  description: 'Location for trend analysis'\n                },\n                categories: {\n                  type: 'array',\n                  items: { type: 'string' },\n                  description: 'Categories to analyze'\n                },\n                time_period: {\n                  type: 'string',\n                  enum: ['month', 'quarter', 'year'],\n                  description: 'Time period for trend analysis'\n                },\n                metrics: {\n                  type: 'array',\n                  items: {\n                    type: 'string',\n                    enum: ['attendance', 'frequency', 'new_groups', 'popular_topics']\n                  },\n                  description: 'Metrics to analyze'\n                }\n              },\n              required: ['location']\n            }\n          }\n        ]\n      }\n    })\n\n    // Handle tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      try {\n        const { name, arguments: args } = request.params\n\n        switch (name) {\n          case 'search_meetup_events':\n            return await this.handleSearchEvents(args)\n\n          case 'discover_local_groups':\n            return await this.handleDiscoverGroups(args)\n\n          case 'analyze_group_health':\n            return await this.handleAnalyzeGroupHealth(args)\n\n          case 'get_personalized_recommendations':\n            return await this.handleGetRecommendations(args)\n\n          case 'monitor_group_activities':\n            return await this.handleMonitorGroups(args)\n\n          case 'analyze_event_trends':\n            return await this.handleAnalyzeTrends(args)\n\n          default:\n            throw new Error(`Unknown tool: ${name}`)\n        }\n      } catch (error) {\n        logger.error('Tool execution failed:', error)\n        throw error\n      }\n    })\n  }\n\n  async start() {\n    try {\n      await this.apiClient.initialize()\n      await this.scraper.initialize()\n\n      const transport = new StdioServerTransport()\n      await this.server.connect(transport)\n\n      logger.info('Meetup MCP Server started successfully')\n    } catch (error) {\n      logger.error('Failed to start Meetup MCP Server:', error)\n      throw error\n    }\n  }\n\n  async stop() {\n    await this.scraper.close()\n    logger.info('Meetup MCP Server stopped')\n  }\n}\n</code></pre>"},{"location":"mcp/meetup/#configuration-usage","title":"\ud83d\udd27 Configuration &amp; Usage","text":""},{"location":"mcp/meetup/#mcp-server-integration","title":"MCP Server Integration","text":"<pre><code>// Example integration with Inttrest\nimport { MCPClient } from '@modelcontextprotocol/sdk/client/index.js'\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'\n\nasync function setupMeetupMCP() {\n  const transport = new StdioClientTransport({\n    command: 'node',\n    args: ['./mcp_servers/mcp-meetup/dist/meetup-mcp-server.js']\n  })\n\n  const client = new MCPClient(\n    {\n      name: 'inttrest-client',\n      version: '1.0.0',\n    },\n    {\n      capabilities: {}\n    }\n  )\n\n  await client.connect(transport)\n  return client\n}\n\n// Search for local tech meetups\nasync function findTechMeetups(location: string) {\n  const client = await setupMeetupMCP()\n\n  const result = await client.callTool({\n    name: 'search_meetup_events',\n    arguments: {\n      location: location,\n      categories: ['tech', 'software-development'],\n      radius: 25,\n      date_range: {\n        start: new Date().toISOString(),\n        end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\n      }\n    }\n  })\n\n  return result._meta?.events || []\n}\n</code></pre>"},{"location":"mcp/meetup/#api-tools-examples","title":"\ud83d\udcca API Tools &amp; Examples","text":""},{"location":"mcp/meetup/#search-meetup-events","title":"Search Meetup Events","text":"<pre><code>// Find Python programming meetups\nconst pythonEvents = await client.callTool({\n  name: 'search_meetup_events',\n  arguments: {\n    location: 'San Francisco, CA',\n    keywords: ['python', 'programming'],\n    radius: 15,\n    group_size_min: 50\n  }\n})\n\n// Find weekend events for families\nconst familyEvents = await client.callTool({\n  name: 'search_meetup_events',\n  arguments: {\n    location: 'New York, NY',\n    categories: ['family', 'kids'],\n    date_range: {\n      start: '2024-02-03T00:00:00Z', // Saturday\n      end: '2024-02-04T23:59:59Z'    // Sunday\n    }\n  }\n})\n</code></pre>"},{"location":"mcp/meetup/#discover-local-groups","title":"Discover Local Groups","text":"<pre><code>// Find active photography groups\nconst photoGroups = await client.callTool({\n  name: 'discover_local_groups',\n  arguments: {\n    location: 'Austin, TX',\n    categories: ['photography', 'arts'],\n    min_members: 100,\n    activity_level: 'high'\n  }\n})\n\n// Find new startup groups\nconst startupGroups = await client.callTool({\n  name: 'discover_local_groups',\n  arguments: {\n    location: 'Boston, MA',\n    categories: ['business', 'entrepreneurship'],\n    include_new_groups: true,\n    min_members: 25\n  }\n})\n</code></pre>"},{"location":"mcp/meetup/#analyze-group-health","title":"Analyze Group Health","text":"<pre><code>// Analyze a specific tech group\nconst groupHealth = await client.callTool({\n  name: 'analyze_group_health',\n  arguments: {\n    group_url: 'https://www.meetup.com/san-francisco-react-js',\n    analyze_members: true,\n    analyze_events: true,\n    time_period: 'quarter'\n  }\n})\n\nconsole.log('Group Health Score:', groupHealth._meta.health_analysis.overall_score)\nconsole.log('Recommendations:', groupHealth._meta.health_analysis.insights.recommendations)\n</code></pre>"},{"location":"mcp/meetup/#get-personalized-recommendations","title":"Get Personalized Recommendations","text":"<pre><code>// Get recommendations for a software developer\nconst recommendations = await client.callTool({\n  name: 'get_personalized_recommendations',\n  arguments: {\n    interests: ['javascript', 'react', 'node.js', 'networking'],\n    location: 'Seattle, WA',\n    availability: {\n      weekdays: false,\n      weekends: true,\n      evenings: true,\n      mornings: false\n    },\n    group_size_preference: 'medium',\n    experience_level: 'intermediate'\n  }\n})\n</code></pre>"},{"location":"mcp/meetup/#monitor-group-activities","title":"Monitor Group Activities","text":"<pre><code>// Monitor favorite groups for updates\nconst monitoring = await client.callTool({\n  name: 'monitor_group_activities',\n  arguments: {\n    groups: [\n      'https://www.meetup.com/reactjs-san-francisco',\n      'https://www.meetup.com/node-js-sf',\n      'https://www.meetup.com/javascript-sf'\n    ],\n    notification_types: ['new_events', 'event_updates'],\n    check_interval: 24 // Check daily\n  }\n})\n</code></pre>"},{"location":"mcp/meetup/#testing-development","title":"\ud83e\uddea Testing &amp; Development","text":""},{"location":"mcp/meetup/#unit-tests","title":"Unit Tests","text":"<pre><code>// tests/meetup-api.test.ts\nimport { MeetupAPIClient } from '../src/services/meetup-api-client.js'\nimport { describe, it, expect, beforeEach } from 'vitest'\n\ndescribe('MeetupAPIClient', () =&gt; {\n  let api: MeetupAPIClient\n\n  beforeEach(() =&gt; {\n    api = new MeetupAPIClient()\n  })\n\n  it('should search events successfully', async () =&gt; {\n    const events = await api.searchEvents({\n      location: 'San Francisco',\n      categories: ['tech']\n    })\n\n    expect(Array.isArray(events)).toBe(true)\n    expect(events.length).toBeGreaterThan(0)\n  })\n\n  it('should discover groups by location', async () =&gt; {\n    const groups = await api.discoverGroups({\n      location: 'New York',\n      min_members: 50\n    })\n\n    expect(Array.isArray(groups)).toBe(true)\n    groups.forEach(group =&gt; {\n      expect(group.members).toBeGreaterThanOrEqual(50)\n    })\n  })\n})\n</code></pre>"},{"location":"mcp/meetup/#integration-tests","title":"Integration Tests","text":"<pre><code>// tests/mcp-integration.test.ts\nimport { MeetupMCPServer } from '../src/meetup-mcp-server.js'\n\ndescribe('Meetup MCP Integration', () =&gt; {\n  let server: MeetupMCPServer\n\n  beforeEach(() =&gt; {\n    server = new MeetupMCPServer()\n  })\n\n  it('should handle search_meetup_events tool call', async () =&gt; {\n    const result = await server.handleSearchEvents({\n      location: 'Los Angeles',\n      categories: ['tech', 'business']\n    })\n\n    expect(result.content).toBeDefined()\n    expect(result._meta?.events).toBeDefined()\n    expect(result._meta.events.length).toBeGreaterThan(0)\n  })\n})\n</code></pre>"},{"location":"mcp/meetup/#development-scripts","title":"Development Scripts","text":"<pre><code>{\n  \"scripts\": {\n    \"dev\": \"tsx src/meetup-mcp-server.ts\",\n    \"build\": \"tsc\",\n    \"test\": \"vitest\",\n    \"test:watch\": \"vitest --watch\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"start\": \"node dist/meetup-mcp-server.js\"\n  }\n}\n</code></pre>"},{"location":"mcp/meetup/#performance-monitoring","title":"\ud83d\udcc8 Performance &amp; Monitoring","text":""},{"location":"mcp/meetup/#caching-strategy","title":"Caching Strategy","text":"<pre><code>// Cache configuration for optimal performance\nconst cacheConfig = {\n  // Event searches - cache for 1 hour\n  events: { ttl: 3600, maxSize: 1000 },\n\n  // Group data - cache for 4 hours\n  groups: { ttl: 14400, maxSize: 500 },\n\n  // Group health analysis - cache for 24 hours\n  health_analysis: { ttl: 86400, maxSize: 100 },\n\n  // Categories - cache for 7 days\n  categories: { ttl: 604800, maxSize: 50 }\n}\n</code></pre>"},{"location":"mcp/meetup/#rate-limiting","title":"Rate Limiting","text":"<pre><code>// Rate limiting configuration\nconst rateLimits = {\n  api: {\n    requests: 200,\n    window: 3600000, // 1 hour\n    burst: 10\n  },\n  scraping: {\n    requests: 20,\n    window: 300000, // 5 minutes\n    delay: 2000 // 2 second delay between requests\n  }\n}\n</code></pre>"},{"location":"mcp/meetup/#health-monitoring","title":"Health Monitoring","text":"<pre><code>// Health check endpoint\nasync function checkMeetupHealth(): Promise&lt;{\n  status: 'healthy' | 'degraded' | 'unhealthy'\n  details: Record&lt;string, any&gt;\n}&gt; {\n  try {\n    const api = new MeetupAPIClient()\n    await api.initialize()\n\n    // Test API connectivity\n    const categories = await api.getCategories()\n\n    return {\n      status: 'healthy',\n      details: {\n        api_connection: 'ok',\n        categories_count: categories.length,\n        timestamp: new Date().toISOString()\n      }\n    }\n  } catch (error) {\n    return {\n      status: 'unhealthy',\n      details: {\n        api_connection: 'failed',\n        error: error.message,\n        timestamp: new Date().toISOString()\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"mcp/meetup/#security-privacy","title":"\ud83d\udd12 Security &amp; Privacy","text":""},{"location":"mcp/meetup/#data-protection","title":"Data Protection","text":"<pre><code>// Anonymize user data\nfunction anonymizeUserData(userData: any): any {\n  return {\n    ...userData,\n    email: undefined,\n    phone: undefined,\n    full_name: userData.name ? userData.name.split(' ')[0] : undefined\n  }\n}\n\n// Rate limiting per user\nconst userRateLimits = new Map&lt;string, {\n  requests: number\n  resetTime: number\n}&gt;()\n</code></pre>"},{"location":"mcp/meetup/#api-security","title":"API Security","text":"<pre><code># Environment variables for security\nMEETUP_API_KEY_ENCRYPTED=encrypted_api_key\nMEETUP_WEBHOOK_SECRET=webhook_secret_for_verification\nALLOWED_ORIGINS=[\"https://inttrest.com\", \"https://app.inttrest.com\"]\n</code></pre> <p>This comprehensive Meetup MCP server documentation provides everything needed for community-driven event discovery and group analysis in the Inttrest platform! \ud83c\udfaf</p>"},{"location":"mcp/overview/","title":"MCP Servers Overview","text":"<p>This document provides a comprehensive overview of all Model Context Protocol (MCP) servers integrated into the Inttrest platform for AI-powered event discovery.</p>"},{"location":"mcp/overview/#platform-integration","title":"\ud83c\udfaf Platform Integration","text":"<p>The Inttrest platform leverages four specialized MCP servers to provide comprehensive event discovery across multiple platforms:</p> <pre><code>graph TB\n    subgraph \"Inttrest AI Platform\"\n        A[Vercel AI SDK] --&gt; B[MCP Client Manager]\n        B --&gt; C[Event Aggregation Engine]\n        C --&gt; D[AI Analysis &amp; Recommendations]\n        D --&gt; E[User Interface]\n    end\n\n    subgraph \"MCP Server Ecosystem\"\n        F[Eventbrite MCP] --&gt; B\n        G[Instagram MCP] --&gt; B\n        H[LinkedIn MCP] --&gt; B\n        I[Meetup MCP] --&gt; B\n    end\n\n    subgraph \"Data Sources\"\n        J[Eventbrite API] --&gt; F\n        K[Instagram Web Scraping] --&gt; G\n        L[LinkedIn API/Scraping] --&gt; H\n        M[Meetup API] --&gt; I\n    end\n\n    subgraph \"User Experience\"\n        E --&gt; N[Chat Interface]\n        E --&gt; O[Map Visualization]\n        E --&gt; P[Event Recommendations]\n        E --&gt; Q[Professional Networking]\n    end\n\n    style A fill:#e3f2fd\n    style B fill:#e8f5e8\n    style C fill:#fff3e0\n    style D fill:#fce4ec</code></pre>"},{"location":"mcp/overview/#server-comparison","title":"\ud83d\udccb Server Comparison","text":"Server Primary Focus Data Source Use Cases Strengths Eventbrite Professional Events Eventbrite API Conferences, Workshops, Ticketed Events Official API, Rich metadata, Payment info Instagram Social Events Web Scraping + AI Parties, Social gatherings, Trendy events Visual content, Social buzz, Real-time discovery LinkedIn Business Events LinkedIn API + Scraping Networking, Professional development Professional context, Industry insights, Quality networking Meetup Community Events Meetup API Local meetups, Interest groups, Recurring events Community-driven, Group health analysis, Local focus"},{"location":"mcp/overview/#technical-architecture","title":"\ud83d\udee0\ufe0f Technical Architecture","text":""},{"location":"mcp/overview/#common-mcp-framework","title":"Common MCP Framework","text":"<p>All servers follow the same architectural pattern:</p> <pre><code>// Standard MCP server structure\ninterface MCPServer {\n  // Core server setup\n  server: Server\n  apiClient: APIClient\n  contentAnalyzer: ContentAnalyzer\n\n  // Tool handlers\n  setupToolHandlers(): void\n\n  // Lifecycle management\n  start(): Promise&lt;void&gt;\n  stop(): Promise&lt;void&gt;\n}\n</code></pre>"},{"location":"mcp/overview/#shared-components","title":"Shared Components","text":""},{"location":"mcp/overview/#1-authentication-management","title":"1. Authentication Management","text":"<pre><code>// OAuth 2.0 flow for API access\ninterface AuthConfig {\n  clientId: string\n  clientSecret: string\n  redirectUri: string\n  accessToken?: string\n  refreshToken?: string\n}\n</code></pre>"},{"location":"mcp/overview/#2-rate-limiting","title":"2. Rate Limiting","text":"<pre><code>// Consistent rate limiting across all servers\ninterface RateLimitConfig {\n  requests: number\n  window: number // milliseconds\n  burst?: number\n  backoff?: 'exponential' | 'linear'\n}\n</code></pre>"},{"location":"mcp/overview/#3-caching-strategy","title":"3. Caching Strategy","text":"<pre><code>// Multi-tier caching for optimal performance\ninterface CacheConfig {\n  redis?: RedisConfig     // Distributed cache\n  memory: MemoryConfig    // Local cache\n  ttl: number            // Time to live\n}\n</code></pre>"},{"location":"mcp/overview/#4-ai-integration","title":"4. AI Integration","text":"<pre><code>// OpenAI integration for content analysis\ninterface AIAnalysisConfig {\n  provider: 'openai' | 'anthropic'\n  model: string\n  temperature: number\n  maxTokens: number\n}\n</code></pre>"},{"location":"mcp/overview/#installation-setup","title":"\ud83d\udd27 Installation &amp; Setup","text":""},{"location":"mcp/overview/#quick-start","title":"Quick Start","text":"<pre><code># Clone the repository\ngit clone https://github.com/FilippTrigub/inttrest\ncd inttrest\n\n# Install dependencies\nnpm install\n\n# Set up environment variables\ncp .env.example .env\n# Edit .env with your API keys\n\n# Build all MCP servers\nnpm run build:mcp\n\n# Start the platform\nnpm run dev\n</code></pre>"},{"location":"mcp/overview/#environment-configuration","title":"Environment Configuration","text":"<p>Create a comprehensive <code>.env</code> file:</p> <pre><code># ===== EVENTBRITE MCP =====\nEVENTBRITE_API_KEY=your_eventbrite_oauth_token\nEVENTBRITE_API_BASE_URL=https://www.eventbriteapi.com/v3\n\n# ===== INSTAGRAM MCP =====\nINSTAGRAM_USERNAME=your_instagram_username\nINSTAGRAM_PASSWORD=your_instagram_password\nOPENAI_API_KEY=your_openai_api_key\n\n# ===== LINKEDIN MCP =====\nLINKEDIN_CLIENT_ID=your_linkedin_client_id\nLINKEDIN_CLIENT_SECRET=your_linkedin_client_secret\nLINKEDIN_ACCESS_TOKEN=your_linkedin_access_token\n\n# ===== MEETUP MCP =====\nMEETUP_API_KEY=your_meetup_api_key\nMEETUP_CLIENT_ID=your_oauth_client_id\nMEETUP_CLIENT_SECRET=your_oauth_client_secret\n\n# ===== SHARED CONFIGURATION =====\n# AI Analysis\nOPENAI_API_KEY=your_openai_api_key\nOPENAI_MODEL=gpt-4-turbo-preview\n\n# Cache &amp; Performance\nREDIS_URL=redis://localhost:6379\nCACHE_TTL=3600000\nRATE_LIMIT_REQUESTS=100\nRATE_LIMIT_WINDOW=3600000\n\n# Logging\nLOG_LEVEL=info\nLOG_FILE=inttrest-mcp.log\n\n# Geographic Defaults\nDEFAULT_LOCATION=37.7749,-122.4194  # San Francisco\nDEFAULT_RADIUS=25\n</code></pre>"},{"location":"mcp/overview/#usage-examples","title":"\ud83d\udcca Usage Examples","text":""},{"location":"mcp/overview/#unified-event-search","title":"Unified Event Search","text":"<pre><code>// Search across all platforms simultaneously\nasync function searchAllPlatforms(query: string, location: string) {\n  const mcpClient = await setupMCPClients()\n\n  const [eventbriteEvents, instagramEvents, linkedinEvents, meetupEvents] = \n    await Promise.all([\n      mcpClient.eventbrite.callTool({\n        name: 'search_events',\n        arguments: { q: query, location }\n      }),\n\n      mcpClient.instagram.callTool({\n        name: 'search_instagram_events',\n        arguments: { hashtags: [query], location }\n      }),\n\n      mcpClient.linkedin.callTool({\n        name: 'search_professional_events',\n        arguments: { keywords: [query], location }\n      }),\n\n      mcpClient.meetup.callTool({\n        name: 'search_meetup_events',\n        arguments: { keywords: [query], location }\n      })\n    ])\n\n  return {\n    professional: [...eventbriteEvents._meta.events, ...linkedinEvents._meta.events],\n    social: instagramEvents._meta.events,\n    community: meetupEvents._meta.events,\n    total: eventbriteEvents._meta.events.length + \n           instagramEvents._meta.events.length + \n           linkedinEvents._meta.events.length + \n           meetupEvents._meta.events.length\n  }\n}\n</code></pre>"},{"location":"mcp/overview/#ai-powered-event-analysis","title":"AI-Powered Event Analysis","text":"<pre><code>// Cross-platform event analysis with AI\nasync function analyzeEventLandscape(location: string, interests: string[]) {\n  const events = await searchAllPlatforms(interests.join(' '), location)\n\n  const analysis = await openai.chat.completions.create({\n    model: 'gpt-4-turbo-preview',\n    messages: [{\n      role: 'system',\n      content: 'Analyze the event landscape and provide insights about trends, opportunities, and recommendations.'\n    }, {\n      role: 'user',\n      content: `\nAnalyze these events in ${location}:\n- Professional Events: ${events.professional.length}\n- Social Events: ${events.social.length}  \n- Community Events: ${events.community.length}\n\nUser interests: ${interests.join(', ')}\n\nProvide insights about:\n1. Event trends in this location\n2. Best networking opportunities\n3. Personalized recommendations\n4. Optimal timing for attendance\n`\n    }]\n  })\n\n  return {\n    events,\n    insights: analysis.choices[0].message.content,\n    recommendations: await generatePersonalizedRecommendations(events, interests)\n  }\n}\n</code></pre>"},{"location":"mcp/overview/#real-time-event-monitoring","title":"Real-time Event Monitoring","text":"<pre><code>// Set up monitoring across all platforms\nasync function setupEventMonitoring(userPreferences: UserPreferences) {\n  const mcpClients = await setupMCPClients()\n\n  // Monitor professional events\n  await mcpClients.eventbrite.callTool({\n    name: 'monitor_events',\n    arguments: {\n      categories: userPreferences.professionalInterests,\n      location: userPreferences.location\n    }\n  })\n\n  // Monitor social events  \n  await mcpClients.instagram.callTool({\n    name: 'monitor_instagram_accounts',\n    arguments: {\n      usernames: userPreferences.followedAccounts,\n      keywords: userPreferences.socialInterests\n    }\n  })\n\n  // Monitor networking events\n  await mcpClients.linkedin.callTool({\n    name: 'monitor_professional_networks', \n    arguments: {\n      companies: userPreferences.companiesOfInterest,\n      industries: userPreferences.industries\n    }\n  })\n\n  // Monitor community events\n  await mcpClients.meetup.callTool({\n    name: 'monitor_group_activities',\n    arguments: {\n      groups: userPreferences.meetupGroups,\n      notification_types: ['new_events', 'event_updates']\n    }\n  })\n}\n</code></pre>"},{"location":"mcp/overview/#testing-strategy","title":"\ud83e\uddea Testing Strategy","text":""},{"location":"mcp/overview/#comprehensive-test-suite","title":"Comprehensive Test Suite","text":"<pre><code>// Cross-platform integration tests\ndescribe('MCP Server Integration', () =&gt; {\n  test('all servers start successfully', async () =&gt; {\n    const servers = await Promise.all([\n      startEventbriteMCP(),\n      startInstagramMCP(), \n      startLinkedInMCP(),\n      startMeetupMCP()\n    ])\n\n    servers.forEach(server =&gt; {\n      expect(server.status).toBe('running')\n    })\n  })\n\n  test('unified event search works', async () =&gt; {\n    const results = await searchAllPlatforms('tech conference', 'San Francisco')\n\n    expect(results.total).toBeGreaterThan(0)\n    expect(results.professional.length).toBeGreaterThan(0)\n    expect(results.community.length).toBeGreaterThan(0)\n  })\n\n  test('AI analysis provides meaningful insights', async () =&gt; {\n    const analysis = await analyzeEventLandscape('New York', ['technology', 'networking'])\n\n    expect(analysis.insights).toBeDefined()\n    expect(analysis.recommendations.length).toBeGreaterThan(0)\n  })\n})\n</code></pre>"},{"location":"mcp/overview/#load-testing","title":"Load Testing","text":"<pre><code># Test MCP server performance under load\nnpm run test:load -- --servers=all --concurrent=50 --duration=60s\n</code></pre>"},{"location":"mcp/overview/#performance-optimization","title":"\ud83d\udcc8 Performance Optimization","text":""},{"location":"mcp/overview/#caching-hierarchy","title":"Caching Hierarchy","text":"<pre><code>graph TD\n    A[Client Request] --&gt; B{Memory Cache}\n    B --&gt;|Hit| C[Return Cached Data]\n    B --&gt;|Miss| D{Redis Cache}\n    D --&gt;|Hit| E[Update Memory &amp; Return]\n    D --&gt;|Miss| F[MCP Server Call]\n    F --&gt; G[API/Scraping]\n    G --&gt; H[Cache in Redis &amp; Memory]\n    H --&gt; I[Return Fresh Data]</code></pre>"},{"location":"mcp/overview/#performance-metrics","title":"Performance Metrics","text":"<pre><code>// Monitor performance across all servers\ninterface PerformanceMetrics {\n  eventbrite: {\n    avgResponseTime: number\n    successRate: number\n    cacheHitRate: number\n  }\n  instagram: {\n    avgResponseTime: number\n    successRate: number\n    scrapingSuccessRate: number\n  }\n  linkedin: {\n    avgResponseTime: number\n    successRate: number\n    apiQuotaUsage: number\n  }\n  meetup: {\n    avgResponseTime: number\n    successRate: number\n    communityAnalysisTime: number\n  }\n}\n</code></pre>"},{"location":"mcp/overview/#security-privacy","title":"\ud83d\udd12 Security &amp; Privacy","text":""},{"location":"mcp/overview/#data-protection","title":"Data Protection","text":"<pre><code>// Consistent data anonymization\ninterface PrivacyConfig {\n  anonymizeUserData: boolean\n  retentionPeriodDays: number\n  encryptSensitiveData: boolean\n  auditLogging: boolean\n}\n\n// GDPR compliance\nfunction anonymizeEventData(event: any): any {\n  return {\n    ...event,\n    attendees: event.attendees?.map(anonymizeUser),\n    organizer: anonymizeUser(event.organizer),\n    sensitiveFields: undefined\n  }\n}\n</code></pre>"},{"location":"mcp/overview/#rate-limiting-abuse-prevention","title":"Rate Limiting &amp; Abuse Prevention","text":"<pre><code>// Multi-layered rate limiting\nconst rateLimits = {\n  perUser: { requests: 100, window: 3600000 },\n  perIP: { requests: 1000, window: 3600000 },\n  perServer: { requests: 10000, window: 3600000 }\n}\n</code></pre>"},{"location":"mcp/overview/#deployment","title":"\ud83d\ude80 Deployment","text":""},{"location":"mcp/overview/#docker-configuration","title":"Docker Configuration","text":"<pre><code># docker-compose.yml\nversion: '3.8'\nservices:\n  inttrest-app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n    depends_on:\n      - redis\n      - postgres\n\n  eventbrite-mcp:\n    build: ./mcp_servers/eventbrite-mcp\n    environment:\n      - EVENTBRITE_API_KEY=${EVENTBRITE_API_KEY}\n\n  instagram-mcp:\n    build: ./mcp_servers/instagram-server-next-mcp\n    environment:\n      - OPENAI_API_KEY=${OPENAI_API_KEY}\n\n  linkedin-mcp:\n    build: ./mcp_servers/linkedin-mcp-server\n    environment:\n      - LINKEDIN_CLIENT_ID=${LINKEDIN_CLIENT_ID}\n\n  meetup-mcp:\n    build: ./mcp_servers/mcp-meetup\n    environment:\n      - MEETUP_API_KEY=${MEETUP_API_KEY}\n\n  redis:\n    image: redis:7-alpine\n\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      - POSTGRES_DB=inttrest\n</code></pre>"},{"location":"mcp/overview/#production-monitoring","title":"Production Monitoring","text":"<pre><code>// Health checks for all MCP servers\nasync function healthCheck(): Promise&lt;SystemHealth&gt; {\n  const checks = await Promise.allSettled([\n    checkEventbriteHealth(),\n    checkInstagramHealth(),\n    checkLinkedInHealth(),\n    checkMeetupHealth()\n  ])\n\n  return {\n    overall: checks.every(check =&gt; check.status === 'fulfilled') ? 'healthy' : 'degraded',\n    servers: {\n      eventbrite: checks[0].status,\n      instagram: checks[1].status,\n      linkedin: checks[2].status,\n      meetup: checks[3].status\n    },\n    timestamp: new Date().toISOString()\n  }\n}\n</code></pre>"},{"location":"mcp/overview/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<ul> <li>Eventbrite MCP Documentation</li> <li>Instagram MCP Documentation</li> <li>LinkedIn MCP Documentation</li> <li>Meetup MCP Documentation</li> <li>Vercel AI SDK Integration</li> <li>Architecture Overview</li> </ul> <p>This comprehensive MCP server ecosystem powers the Inttrest platform's AI-driven event discovery capabilities across multiple platforms! \ud83d\ude80</p>"},{"location":"setup/colleague_access/","title":"Colleague Access Setup","text":"<p>This guide helps you set up database access for your colleagues working on the Event Discovery project.</p>"},{"location":"setup/colleague_access/#overview","title":"\ud83c\udfaf Overview","text":"<p>When working with MongoDB Atlas in a team, you need to grant database access to your colleagues. This guide provides multiple methods to accomplish this securely.</p> <pre><code>graph TD\n    subgraph \"Access Methods\"\n        A[Manual Setup&lt;br/&gt;Quick &amp; Simple] \n        B[API Setup&lt;br/&gt;Automated]\n        C[Invitation&lt;br/&gt;Collaborative]\n    end\n\n    subgraph \"Required Information\"\n        D[Email Address]\n        E[IP Address]\n        F[Access Level]\n    end\n\n    subgraph \"Atlas Configuration\"\n        G[Database User]\n        H[Network Access]\n        I[Connection String]\n    end\n\n    A --&gt; D\n    B --&gt; D\n    C --&gt; D\n\n    D --&gt; G\n    E --&gt; H\n    F --&gt; G\n\n    G --&gt; I\n    H --&gt; I\n\n    style A fill:#e3f2fd\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8</code></pre>"},{"location":"setup/colleague_access/#quick-setup-recommended","title":"\ud83d\ude80 Quick Setup (Recommended)","text":""},{"location":"setup/colleague_access/#step-1-gather-colleague-information","title":"Step 1: Gather Colleague Information","text":"<p>Create a file <code>colleague_info.txt</code> with the following format:</p> <pre><code># Colleague Information\nName: John Doe\nEmail: john.doe@company.com\nIP Address: 192.168.1.100\nRole: Developer\nAccess Level: readWrite\n</code></pre>"},{"location":"setup/colleague_access/#step-2-run-the-setup-script","title":"Step 2: Run the Setup Script","text":"<pre><code># Use the automated setup script\npython colleague_setup.py\n</code></pre> <p>The script will guide you through the process:</p> <pre><code>\ud83d\udd27 Setting up colleague access to MongoDB Atlas...\n\nEnter colleague email: john.doe@company.com\nEnter colleague IP address (or 'anywhere' for 0.0.0.0/0): 192.168.1.100\nSelect access level:\n1. Read Only (recommended for analysts)\n2. Read/Write (recommended for developers)\n3. Admin (recommended for team leads)\nChoice: 2\n\n\u2705 Database user created successfully!\n\u2705 IP address added to access list!\n\ud83d\udd17 Connection string: mongodb+srv://john_doe:generatedPassword123@cluster.mongodb.net/\n</code></pre>"},{"location":"setup/colleague_access/#manual-setup-method","title":"\ud83d\udcdd Manual Setup Method","text":""},{"location":"setup/colleague_access/#step-1-access-mongodb-atlas-console","title":"Step 1: Access MongoDB Atlas Console","text":"<ol> <li>Login to MongoDB Atlas</li> <li>Select your project</li> <li>Navigate to the appropriate section for each task</li> </ol>"},{"location":"setup/colleague_access/#step-2-create-database-user","title":"Step 2: Create Database User","text":"<pre><code>sequenceDiagram\n    participant You\n    participant Atlas as MongoDB Atlas\n    participant Colleague\n\n    You-&gt;&gt;Atlas: Navigate to Database Access\n    You-&gt;&gt;Atlas: Click \"Add New Database User\"\n    You-&gt;&gt;Atlas: Enter colleague credentials\n    You-&gt;&gt;Atlas: Set permissions\n    Atlas--&gt;&gt;You: User created successfully\n    You-&gt;&gt;Colleague: Share credentials securely</code></pre> <p>Detailed Steps:</p> <ol> <li>Navigate to <code>Database Access</code> in the left sidebar</li> <li>Click <code>Add New Database User</code></li> <li>Fill in the form: <pre><code>Authentication Method: Password\nUsername: colleague_username\nPassword: [Generate secure password]\nDatabase User Privileges: \n  - Read and write to any database (for developers)\n  - Read any database (for analysts)\n  - Built-in role: Atlas admin (for team leads)\nRestrict Access to Specific Clusters: [Optional]\n</code></pre></li> <li>Click <code>Add User</code></li> </ol>"},{"location":"setup/colleague_access/#step-3-configure-network-access","title":"Step 3: Configure Network Access","text":"<ol> <li>Navigate to <code>Network Access</code></li> <li>Click <code>Add IP Address</code></li> <li>Choose appropriate option:</li> </ol> <p>For specific IP: <pre><code>Access List Entry: 192.168.1.100/32\nComment: John Doe - Developer machine\n</code></pre></p> <p>For office network: <pre><code>Access List Entry: 192.168.1.0/24\nComment: Office network range\n</code></pre></p> <p>For temporary access (not recommended for production): <pre><code>Access List Entry: 0.0.0.0/0\nComment: Allow access from anywhere (temporary)\n</code></pre></p> <ol> <li>Click <code>Confirm</code></li> </ol>"},{"location":"setup/colleague_access/#step-4-generate-connection-string","title":"Step 4: Generate Connection String","text":"<ol> <li>Navigate to <code>Clusters</code></li> <li>Click <code>Connect</code> on your cluster</li> <li>Choose <code>Connect your application</code></li> <li>Select driver and version</li> <li>Copy the connection string</li> <li>Replace <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> with colleague's credentials</li> </ol> <p>Example: <pre><code>mongodb+srv://john_doe:securePassword123@democluster.c5lpr.mongodb.net/events_db?retryWrites=true&amp;w=majority\n</code></pre></p>"},{"location":"setup/colleague_access/#api-based-setup","title":"\ud83e\udd16 API-Based Setup","text":"<p>For automated colleague management, use the MongoDB Atlas API:</p>"},{"location":"setup/colleague_access/#prerequisites","title":"Prerequisites","text":"<ol> <li>Generate API Key in Atlas:</li> <li>Navigate to <code>Access Manager</code> \u2192 <code>API Keys</code></li> <li>Create new API key with <code>Project Owner</code> permissions</li> <li> <p>Note the Public Key and Private Key</p> </li> <li> <p>Install Atlas CLI (optional):    <pre><code># macOS\nbrew install mongodb-atlas-cli\n\n# Linux\ncurl -fLo atlas-cli.deb https://fastdl.mongodb.org/tools/atlascli/deb/atlas-cli_latest_amd64.deb\nsudo dpkg -i atlas-cli.deb\n</code></pre></p> </li> </ol>"},{"location":"setup/colleague_access/#using-the-api-setup-script","title":"Using the API Setup Script","text":"<pre><code># atlas_setup.py - Enhanced version for colleagues\nfrom atlas_setup import AtlasAPIConnector\nimport json\n\ndef setup_colleague_access(colleague_info):\n    \"\"\"\n    Set up database access for a colleague using Atlas API\n\n    Args:\n        colleague_info (dict): Colleague information\n    \"\"\"\n\n    # Initialize API connector\n    connector = AtlasAPIConnector()\n\n    print(f\"\ud83d\udd27 Setting up access for {colleague_info['name']}...\")\n\n    try:\n        # 1. Create database user\n        username = colleague_info['email'].split('@')[0].replace('.', '_')\n        password = connector.generate_password()\n\n        user_response = connector.create_database_user(\n            username=username,\n            password=password,\n            roles=[{\"roleName\": \"readWrite\", \"databaseName\": \"events_db\"}]\n        )\n\n        if user_response:\n            print(f\"\u2705 Database user '{username}' created successfully!\")\n\n        # 2. Add IP to access list\n        ip_response = connector.add_ip_to_access_list(\n            ip_address=colleague_info['ip_address'],\n            comment=f\"{colleague_info['name']} - {colleague_info['role']}\"\n        )\n\n        if ip_response:\n            print(f\"\u2705 IP address {colleague_info['ip_address']} added to access list!\")\n\n        # 3. Generate connection string\n        connection_string = connector.get_connection_string(username, password)\n\n        # 4. Save colleague information\n        colleague_access = {\n            \"name\": colleague_info['name'],\n            \"email\": colleague_info['email'],\n            \"username\": username,\n            \"password\": password,\n            \"connection_string\": connection_string,\n            \"setup_date\": datetime.now().isoformat(),\n            \"access_level\": colleague_info.get('access_level', 'readWrite')\n        }\n\n        # Save to file for record keeping\n        with open(f\"access_records/{username}_access.json\", \"w\") as f:\n            json.dump(colleague_access, f, indent=2)\n\n        print(f\"\ud83d\udcdd Access information saved to access_records/{username}_access.json\")\n        print(f\"\ud83d\udd17 Connection string: {connection_string}\")\n\n        return colleague_access\n\n    except Exception as e:\n        print(f\"\u274c Setup failed: {e}\")\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    colleague_data = {\n        \"name\": \"Jane Smith\",\n        \"email\": \"jane.smith@company.com\",\n        \"ip_address\": \"203.0.113.45\",\n        \"role\": \"Data Analyst\",\n        \"access_level\": \"read\"\n    }\n\n    result = setup_colleague_access(colleague_data)\n    if result:\n        print(\"\ud83c\udf89 Colleague access setup complete!\")\n</code></pre>"},{"location":"setup/colleague_access/#batch-colleague-setup","title":"Batch Colleague Setup","text":"<p>For setting up multiple colleagues at once:</p> <pre><code># batch_setup.py\nimport csv\nimport json\nfrom datetime import datetime\n\ndef batch_setup_colleagues(csv_file_path):\n    \"\"\"\n    Set up database access for multiple colleagues from CSV file\n\n    CSV format:\n    name,email,ip_address,role,access_level\n    John Doe,john@company.com,192.168.1.100,Developer,readWrite\n    Jane Smith,jane@company.com,192.168.1.101,Analyst,read\n    \"\"\"\n\n    results = []\n\n    with open(csv_file_path, 'r') as file:\n        reader = csv.DictReader(file)\n\n        for row in reader:\n            print(f\"\\n\ud83d\udccb Processing: {row['name']}\")\n\n            result = setup_colleague_access(row)\n            if result:\n                results.append(result)\n            else:\n                print(f\"\u274c Failed to setup access for {row['name']}\")\n\n    # Generate summary report\n    summary = {\n        \"setup_date\": datetime.now().isoformat(),\n        \"total_colleagues\": len(results),\n        \"successful_setups\": len([r for r in results if r]),\n        \"colleagues\": results\n    }\n\n    with open(\"batch_setup_summary.json\", \"w\") as f:\n        json.dump(summary, f, indent=2)\n\n    print(f\"\\n\ud83d\udcca Batch setup complete! {len(results)} colleagues configured.\")\n    print(\"\ud83d\udcdd Summary saved to batch_setup_summary.json\")\n\n# Create example CSV template\ndef create_csv_template():\n    \"\"\"Create a CSV template for batch colleague setup\"\"\"\n\n    template_data = [\n        [\"name\", \"email\", \"ip_address\", \"role\", \"access_level\"],\n        [\"John Doe\", \"john.doe@company.com\", \"192.168.1.100\", \"Developer\", \"readWrite\"],\n        [\"Jane Smith\", \"jane.smith@company.com\", \"192.168.1.101\", \"Data Analyst\", \"read\"],\n        [\"Bob Johnson\", \"bob.johnson@company.com\", \"anywhere\", \"Team Lead\", \"dbAdmin\"]\n    ]\n\n    with open(\"colleagues_template.csv\", \"w\", newline='') as file:\n        writer = csv.writer(file)\n        writer.writerows(template_data)\n\n    print(\"\ud83d\udccb CSV template created: colleagues_template.csv\")\n\nif __name__ == \"__main__\":\n    # Create template first\n    create_csv_template()\n\n    # Then run batch setup\n    # batch_setup_colleagues(\"colleagues_template.csv\")\n</code></pre>"},{"location":"setup/colleague_access/#team-invitation-method","title":"\ud83d\udc65 Team Invitation Method","text":""},{"location":"setup/colleague_access/#step-1-invite-to-organization","title":"Step 1: Invite to Organization","text":"<ol> <li>Navigate to <code>Access Manager</code> \u2192 <code>Organization Users</code></li> <li>Click <code>Invite Users</code></li> <li>Enter colleague email addresses</li> <li>Select appropriate roles:</li> <li><code>Organization Member</code> - Basic access</li> <li><code>Organization Project Creator</code> - Can create projects</li> <li><code>Organization Owner</code> - Full administrative access</li> </ol>"},{"location":"setup/colleague_access/#step-2-add-to-project","title":"Step 2: Add to Project","text":"<ol> <li>Navigate to <code>Access Manager</code> \u2192 <code>Project Users</code></li> <li>Click <code>Add Users to Project</code></li> <li>Select invited users</li> <li>Assign project roles:</li> <li><code>Project Read Only</code> - View access only</li> <li><code>Project Data Access Read/Write</code> - Database operations</li> <li><code>Project Owner</code> - Full project management</li> </ol>"},{"location":"setup/colleague_access/#security-best-practices","title":"\ud83d\udd10 Security Best Practices","text":""},{"location":"setup/colleague_access/#access-level-guidelines","title":"Access Level Guidelines","text":"<pre><code>graph TB\n    subgraph \"Recommended Access Levels\"\n        A[Data Analysts&lt;br/&gt;\ud83d\udcca Read Only]\n        B[Developers&lt;br/&gt;\ud83d\udcbb Read/Write]\n        C[Team Leads&lt;br/&gt;\ud83d\udc68\u200d\ud83d\udcbc Admin]\n        D[DevOps&lt;br/&gt;\u2699\ufe0f Full Access]\n    end\n\n    subgraph \"Database Permissions\"\n        E[events_db.read]\n        F[events_db.readWrite]\n        G[dbAdmin]\n        H[Atlas Admin]\n    end\n\n    A --&gt; E\n    B --&gt; F\n    C --&gt; G\n    D --&gt; H\n\n    style A fill:#e3f2fd\n    style B fill:#e8f5e8\n    style C fill:#fff3e0\n    style D fill:#ffebee</code></pre>"},{"location":"setup/colleague_access/#ip-address-management","title":"IP Address Management","text":"<p>Development Environment: <pre><code># Allow from anywhere (temporary)\nIP: 0.0.0.0/0\nComment: \"Development - Remove before production\"\n</code></pre></p> <p>Office Network: <pre><code># Specific office range\nIP: 192.168.1.0/24\nComment: \"Company office network\"\n</code></pre></p> <p>Remote Work: <pre><code># Individual IP addresses\nIP: 203.0.113.45/32\nComment: \"John Doe - Home office\"\n</code></pre></p> <p>VPN Access: <pre><code># VPN endpoint range\nIP: 10.0.0.0/8\nComment: \"Company VPN range\"\n</code></pre></p>"},{"location":"setup/colleague_access/#password-security","title":"Password Security","text":"<p>Strong Password Guidelines: - Minimum 12 characters - Mix of uppercase, lowercase, numbers, symbols - No personal information - Unique for each service</p> <p>Password Generation: <pre><code>import secrets\nimport string\n\ndef generate_secure_password(length=16):\n    \"\"\"Generate a cryptographically secure password\"\"\"\n\n    characters = (\n        string.ascii_letters + \n        string.digits + \n        \"!@#$%^&amp;*\"\n    )\n\n    password = ''.join(\n        secrets.choice(characters) \n        for _ in range(length)\n    )\n\n    return password\n\n# Example usage\nnew_password = generate_secure_password()\nprint(f\"Generated password: {new_password}\")\n</code></pre></p>"},{"location":"setup/colleague_access/#access-monitoring","title":"\ud83d\udcca Access Monitoring","text":""},{"location":"setup/colleague_access/#tracking-colleague-access","title":"Tracking Colleague Access","text":"<p>Create a simple tracking system:</p> <pre><code># access_tracker.py\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\n\nclass AccessTracker:\n    def __init__(self, tracking_file=\"colleague_access_log.json\"):\n        self.tracking_file = Path(tracking_file)\n        self.load_access_log()\n\n    def load_access_log(self):\n        \"\"\"Load existing access log or create new one\"\"\"\n        if self.tracking_file.exists():\n            with open(self.tracking_file, 'r') as f:\n                self.access_log = json.load(f)\n        else:\n            self.access_log = {\n                \"created\": datetime.now().isoformat(),\n                \"colleagues\": {}\n            }\n\n    def add_colleague_access(self, colleague_info):\n        \"\"\"Add new colleague access record\"\"\"\n        username = colleague_info['username']\n\n        self.access_log['colleagues'][username] = {\n            \"name\": colleague_info['name'],\n            \"email\": colleague_info['email'],\n            \"setup_date\": datetime.now().isoformat(),\n            \"access_level\": colleague_info['access_level'],\n            \"ip_address\": colleague_info['ip_address'],\n            \"status\": \"active\"\n        }\n\n        self.save_access_log()\n\n    def revoke_colleague_access(self, username):\n        \"\"\"Mark colleague access as revoked\"\"\"\n        if username in self.access_log['colleagues']:\n            self.access_log['colleagues'][username]['status'] = 'revoked'\n            self.access_log['colleagues'][username]['revoked_date'] = datetime.now().isoformat()\n            self.save_access_log()\n\n    def save_access_log(self):\n        \"\"\"Save access log to file\"\"\"\n        with open(self.tracking_file, 'w') as f:\n            json.dump(self.access_log, f, indent=2)\n\n    def generate_access_report(self):\n        \"\"\"Generate a report of all colleague access\"\"\"\n        colleagues = self.access_log['colleagues']\n\n        active_count = len([c for c in colleagues.values() if c['status'] == 'active'])\n        revoked_count = len([c for c in colleagues.values() if c['status'] == 'revoked'])\n\n        print(\"\ud83d\udcca Colleague Access Report\")\n        print(\"=\" * 30)\n        print(f\"Total colleagues: {len(colleagues)}\")\n        print(f\"Active access: {active_count}\")\n        print(f\"Revoked access: {revoked_count}\")\n        print(\"\\n\ud83d\udc65 Active Colleagues:\")\n\n        for username, info in colleagues.items():\n            if info['status'] == 'active':\n                print(f\"  \u2022 {info['name']} ({username}) - {info['access_level']}\")\n\n# Example usage\ntracker = AccessTracker()\ntracker.generate_access_report()\n</code></pre>"},{"location":"setup/colleague_access/#testing-colleague-access","title":"\ud83e\uddea Testing Colleague Access","text":""},{"location":"setup/colleague_access/#verification-script","title":"Verification Script","text":"<pre><code># test_colleague_access.py\nfrom mongo_connector import MongoConnector\nimport os\n\ndef test_colleague_connection(connection_string):\n    \"\"\"\n    Test if colleague can connect with their credentials\n\n    Args:\n        connection_string (str): Full MongoDB connection string\n    \"\"\"\n\n    print(\"\ud83e\uddea Testing colleague database access...\")\n\n    try:\n        # Extract password from connection string for MongoConnector\n        # Format: mongodb+srv://username:password@cluster.../\n        parts = connection_string.split('@')[0].split(':')\n        password = parts[-1]\n\n        # Initialize connection\n        mongo = MongoConnector(password)\n\n        # Test basic operations\n        print(\"\u2705 Connection established\")\n\n        # Test read operation\n        count = mongo.count_events()\n        print(f\"\ud83d\udcca Can read events: {count} events found\")\n\n        # Test write operation (if allowed)\n        try:\n            test_event = {\n                \"id\": \"colleague_test_001\",\n                \"title\": \"Colleague Access Test\",\n                \"location\": \"Test Location\",\n                \"source\": \"access_test\"\n            }\n\n            result = mongo.insert_event(test_event)\n            if result:\n                print(\"\u2705 Can write events\")\n\n                # Clean up test event\n                mongo.delete_event({\"id\": \"colleague_test_001\"})\n                print(\"\ud83e\uddf9 Test event cleaned up\")\n\n        except Exception as write_error:\n            print(f\"\u26a0\ufe0f Write access limited: {write_error}\")\n\n        mongo.close()\n        print(\"\ud83c\udf89 Colleague access test completed successfully!\")\n        return True\n\n    except Exception as e:\n        print(f\"\u274c Access test failed: {e}\")\n        return False\n\ndef test_all_colleagues():\n    \"\"\"Test access for all configured colleagues\"\"\"\n\n    access_records_dir = Path(\"access_records\")\n\n    if not access_records_dir.exists():\n        print(\"\ud83d\udcc2 No access records found\")\n        return\n\n    for record_file in access_records_dir.glob(\"*_access.json\"):\n        with open(record_file, 'r') as f:\n            colleague_info = json.load(f)\n\n        print(f\"\\n\ud83e\uddea Testing access for {colleague_info['name']}...\")\n        test_colleague_connection(colleague_info['connection_string'])\n\nif __name__ == \"__main__\":\n    # Test specific colleague\n    connection_str = input(\"Enter colleague connection string: \")\n    test_colleague_connection(connection_str)\n\n    # Or test all colleagues\n    # test_all_colleagues()\n</code></pre>"},{"location":"setup/colleague_access/#troubleshooting","title":"\ud83c\udd98 Troubleshooting","text":""},{"location":"setup/colleague_access/#common-issues","title":"Common Issues","text":"<p>Issue: \"Authentication failed\" <pre><code>Solution:\n1. Check username/password spelling\n2. Verify user exists in Database Access\n3. Check user has correct permissions\n4. Try regenerating password\n</code></pre></p> <p>Issue: \"IP not whitelisted\" <pre><code>Solution:\n1. Check Network Access list\n2. Verify IP address format\n3. Add 0.0.0.0/0 for testing (temporary)\n4. Check for dynamic IP changes\n</code></pre></p> <p>Issue: \"Connection timeout\" <pre><code>Solution:\n1. Check internet connectivity\n2. Verify firewall settings\n3. Try different network\n4. Check MongoDB Atlas status\n</code></pre></p>"},{"location":"setup/colleague_access/#support-contacts","title":"Support Contacts","text":"<p>For additional help: - MongoDB Atlas Support: support.mongodb.com - Team Lead: team-lead@company.com - IT Support: it-support@company.com</p> <p>This comprehensive guide should help you securely set up database access for all your colleagues! \ud83c\udf89</p>"},{"location":"setup/installation/","title":"Installation Guide","text":"<p>This guide will help you set up the Event Discovery application with MongoDB integration from scratch.</p>"},{"location":"setup/installation/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<pre><code># 1. Clone the repository\ngit clone https://github.com/Reetika12795/Rewind.git\ncd inttrest\n\n# 2. Install dependencies\nuv sync\n\n# 3. Configure environment\ncp .env.example .env\n# Edit .env with your credentials\n\n# 4. Test the setup\npython test_mongo.py\n</code></pre>"},{"location":"setup/installation/#prerequisites","title":"\ud83d\udccb Prerequisites","text":""},{"location":"setup/installation/#system-requirements","title":"System Requirements","text":"<pre><code>graph TB\n    subgraph \"Required\"\n        REQ1[Python 3.8+]\n        REQ2[uv package manager]\n        REQ3[Git]\n        REQ4[MongoDB Atlas account]\n    end\n\n    subgraph \"Optional\"\n        OPT1[Node.js 18+ for MCP]\n        OPT2[Docker for containers]\n        OPT3[Google Maps API key]\n    end\n\n    style REQ1 fill:#ffebee\n    style OPT1 fill:#e8f5e8</code></pre>"},{"location":"setup/installation/#check-your-system","title":"Check Your System","text":"<pre><code># Check Python version\npython --version\n# Should output: Python 3.8.x or higher\n\n# Check if uv is installed\nuv --version\n# Should output: uv x.x.x\n\n# Install uv if not present\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre>"},{"location":"setup/installation/#installation-steps","title":"\ud83d\udd27 Installation Steps","text":""},{"location":"setup/installation/#step-1-repository-setup","title":"Step 1: Repository Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/Reetika12795/Rewind.git\n\n# Navigate to the project directory\ncd Rewind/inttrest\n\n# Check the project structure\nls -la\n</code></pre> <p>Expected structure: <pre><code>inttrest/\n\u251c\u2500\u2500 mongo_connector.py      # MongoDB interface\n\u251c\u2500\u2500 geocoder.py            # Geocoding service\n\u251c\u2500\u2500 save_events.py         # Event processing\n\u251c\u2500\u2500 test_mongo.py          # Database tests\n\u251c\u2500\u2500 pyproject.toml         # Project configuration\n\u251c\u2500\u2500 requirements.txt       # Dependencies\n\u2514\u2500\u2500 docs/                  # Documentation\n</code></pre></p>"},{"location":"setup/installation/#step-2-dependencies-installation","title":"Step 2: Dependencies Installation","text":"<pre><code># Install Python dependencies using uv\nuv sync\n\n# Alternative: Using pip (if uv fails)\npip install -r requirements.txt\n</code></pre> <p>Expected output: <pre><code>Resolved 26 packages in 2s\nInstalled 26 packages in 500ms\n + pymongo==4.6.0\n + requests==2.31.0\n + ...\n</code></pre></p>"},{"location":"setup/installation/#step-3-environment-configuration","title":"Step 3: Environment Configuration","text":"<pre><code># Create environment file from template\ncp .env.example .env\n\n# Edit the environment file\nnano .env  # or use your preferred editor\n</code></pre> <p>Required environment variables: <pre><code># MongoDB Atlas Configuration\nMONGODB_PASSWORD=your_mongodb_atlas_password\n\n# Optional: Geocoding API keys\nGOOGLE_GEOCODING_API_KEY=your_google_api_key\n\n# Optional: MCP Server URLs\nEVENTBRITE_MCP_URL=http://localhost:3001\nMEETUP_MCP_URL=http://localhost:3002\nLINKEDIN_MCP_URL=http://localhost:3003\n</code></pre></p>"},{"location":"setup/installation/#mongodb-atlas-setup","title":"\ud83d\uddc4\ufe0f MongoDB Atlas Setup","text":""},{"location":"setup/installation/#step-1-create-mongodb-atlas-account","title":"Step 1: Create MongoDB Atlas Account","text":"<ol> <li>Visit MongoDB Atlas</li> <li>Sign up for a free account</li> <li>Create a new project named \"Event Discovery\"</li> <li>Deploy a free cluster (M0 Sandbox)</li> </ol>"},{"location":"setup/installation/#step-2-configure-database-access","title":"Step 2: Configure Database Access","text":"<pre><code>sequenceDiagram\n    participant You\n    participant Atlas as MongoDB Atlas\n    participant App as Your Application\n\n    You-&gt;&gt;Atlas: Create Database User\n    Atlas--&gt;&gt;You: Username/Password\n\n    You-&gt;&gt;Atlas: Add IP to Access List\n    Atlas--&gt;&gt;You: Network Access Granted\n\n    You-&gt;&gt;Atlas: Get Connection String\n    Atlas--&gt;&gt;You: Connection URI\n\n    You-&gt;&gt;App: Configure with credentials\n    App-&gt;&gt;Atlas: Test Connection\n    Atlas--&gt;&gt;App: Connection Successful</code></pre>"},{"location":"setup/installation/#create-database-user","title":"Create Database User","text":"<ol> <li>Navigate to <code>Database Access</code> \u2192 <code>Add New Database User</code></li> <li>Authentication Method: Password</li> <li>Username: <code>event_user</code> (or your choice)</li> <li>Password: Generate secure password</li> <li>Database User Privileges: Read and write to any database</li> <li>Click <code>Add User</code></li> </ol>"},{"location":"setup/installation/#configure-network-access","title":"Configure Network Access","text":"<ol> <li>Navigate to <code>Network Access</code> \u2192 <code>Add IP Address</code></li> <li>Access List Entry: </li> <li>For development: <code>0.0.0.0/0</code> (allow from anywhere)</li> <li>For production: Your specific IP address</li> <li>Click <code>Confirm</code></li> </ol>"},{"location":"setup/installation/#get-connection-string","title":"Get Connection String","text":"<ol> <li>Navigate to <code>Clusters</code> \u2192 <code>Connect</code></li> <li>Choose <code>Connect your application</code></li> <li>Driver: Python, Version 3.6+</li> <li>Copy the connection string</li> <li>Replace <code>&lt;password&gt;</code> with your actual password</li> </ol> <p>Example connection string: <pre><code>mongodb+srv://event_user:&lt;password&gt;@cluster0.mongodb.net/events_db?retryWrites=true&amp;w=majority\n</code></pre></p>"},{"location":"setup/installation/#step-3-test-database-connection","title":"Step 3: Test Database Connection","text":"<pre><code># Activate virtual environment\nsource .venv/bin/activate  # Linux/Mac\n# or\n.venv\\Scripts\\activate     # Windows\n\n# Test the connection\npython test_mongo.py\n</code></pre> <p>Expected output: <pre><code>\u2705 Connected to MongoDB!\n\u2705 Event inserted: Test Event\n\u2705 Inserted 2 events\n\ud83d\udd0d Finding events...\n- Test Event in Paris\n- Batch Event 1 in Paris\n\ud83d\udcca Total events in database: 3\n\ud83d\udd10 MongoDB connection closed\n</code></pre></p>"},{"location":"setup/installation/#testing-your-setup","title":"\ud83e\uddea Testing Your Setup","text":""},{"location":"setup/installation/#basic-functionality-test","title":"Basic Functionality Test","text":"<pre><code># Create test file: test_setup.py\nfrom mongo_connector import MongoConnector\nfrom geocoder import geocoder\nimport os\n\ndef test_complete_setup():\n    \"\"\"Test all components are working\"\"\"\n\n    print(\"\ud83e\uddea Testing complete setup...\")\n\n    # 1. Test MongoDB connection\n    try:\n        password = os.getenv(\"MONGODB_PASSWORD\")\n        if not password:\n            password = input(\"Enter MongoDB password: \")\n\n        mongo = MongoConnector(password)\n        print(\"\u2705 MongoDB connection successful\")\n\n        # Test basic operations\n        count = mongo.count_events()\n        print(f\"\ud83d\udcca Current events in database: {count}\")\n\n        mongo.close()\n\n    except Exception as e:\n        print(f\"\u274c MongoDB test failed: {e}\")\n        return False\n\n    # 2. Test geocoding service\n    try:\n        test_address = \"15 rue de milan, paris\"\n        coords = geocoder.geocode(test_address)\n\n        if coords:\n            print(f\"\u2705 Geocoding successful: {coords}\")\n        else:\n            print(\"\u26a0\ufe0f Geocoding returned no results\")\n\n    except Exception as e:\n        print(f\"\u274c Geocoding test failed: {e}\")\n        return False\n\n    # 3. Test event processing\n    try:\n        from save_events import save_mcp_events\n\n        # Mock event data\n        mock_events = [{\n            \"id\": \"test_setup_001\",\n            \"title\": \"Setup Test Event\",\n            \"location\": \"Paris, France\",\n            \"category\": \"Technology\"\n        }]\n\n        saved_count = save_mcp_events(mock_events, \"test\", password)\n        print(f\"\u2705 Event processing successful: {saved_count} events saved\")\n\n    except Exception as e:\n        print(f\"\u274c Event processing test failed: {e}\")\n        return False\n\n    print(\"\ud83c\udf89 All tests passed! Setup is complete.\")\n    return True\n\nif __name__ == \"__main__\":\n    test_complete_setup()\n</code></pre>"},{"location":"setup/installation/#run-the-comprehensive-test","title":"Run the Comprehensive Test","text":"<pre><code>python test_setup.py\n</code></pre>"},{"location":"setup/installation/#troubleshooting","title":"\ud83d\udd0d Troubleshooting","text":""},{"location":"setup/installation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"setup/installation/#issue-modulenotfounderror-no-module-named-pymongo","title":"Issue: <code>ModuleNotFoundError: No module named 'pymongo'</code>","text":"<p>Solution: <pre><code># Ensure you're in the correct environment\nsource .venv/bin/activate\n\n# Reinstall dependencies\nuv sync\n\n# Or force reinstall\npip install --force-reinstall pymongo\n</code></pre></p>"},{"location":"setup/installation/#issue-mongodb-connection-fails","title":"Issue: MongoDB connection fails","text":"<p>Solutions:</p> <ol> <li> <p>Check credentials: <pre><code># Verify your .env file\ncat .env | grep MONGODB_PASSWORD\n</code></pre></p> </li> <li> <p>Check network access:</p> </li> <li>Ensure your IP is in the MongoDB Atlas access list</li> <li> <p>Try <code>0.0.0.0/0</code> for testing (not recommended for production)</p> </li> <li> <p>Check connection string: <pre><code># Test with manual connection string\nfrom pymongo import MongoClient\n\nuri = \"mongodb+srv://username:password@cluster.mongodb.net/\"\nclient = MongoClient(uri)\nclient.admin.command('ping')  # Should not raise exception\n</code></pre></p> </li> </ol>"},{"location":"setup/installation/#issue-geocoding-not-working","title":"Issue: Geocoding not working","text":"<p>Solutions:</p> <ol> <li> <p>Check internet connection: <pre><code>curl -I https://nominatim.openstreetmap.org\n</code></pre></p> </li> <li> <p>Check rate limiting: <pre><code># Increase delay between requests\nimport time\ntime.sleep(2)  # Wait 2 seconds instead of 1\n</code></pre></p> </li> <li> <p>Try alternative address formats: <pre><code>addresses = [\n    \"15 rue de milan, paris\",\n    \"15 Rue de Milan, Paris, France\",\n    \"rue de Milan, 75009 Paris\"\n]\n</code></pre></p> </li> </ol>"},{"location":"setup/installation/#issue-uv-command-not-found","title":"Issue: <code>uv</code> command not found","text":"<p>Solution: <pre><code># Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Restart terminal or source profile\nsource ~/.bashrc  # or ~/.zshrc\n\n# Verify installation\nuv --version\n</code></pre></p>"},{"location":"setup/installation/#issue-permission-errors-on-macoslinux","title":"Issue: Permission errors on macOS/Linux","text":"<p>Solution: <pre><code># Fix permissions\nchmod +x setup_scripts/*.sh\n\n# Use sudo if needed for system-wide installation\nsudo pip install -r requirements.txt\n</code></pre></p>"},{"location":"setup/installation/#next-steps","title":"\ud83d\ude80 Next Steps","text":""},{"location":"setup/installation/#after-successful-installation","title":"After successful installation:","text":"<ol> <li> <p>\ud83d\udcd6 Read the documentation: <pre><code># Build and serve documentation\nmkdocs serve\n# Visit: http://localhost:8000\n</code></pre></p> </li> <li> <p>\ud83e\uddd1\u200d\ud83d\udcbb Set up colleague access: <pre><code>python colleague_setup.py\n</code></pre></p> </li> <li> <p>\ud83d\udd17 Configure MCP servers (optional):    <pre><code># Follow MCP setup guide\npython setup_mcp_servers.py\n</code></pre></p> </li> <li> <p>\ud83c\udfa8 Set up frontend (optional):    <pre><code>cd frontend\nnpm install\nnpm run dev\n</code></pre></p> </li> </ol>"},{"location":"setup/installation/#development-workflow","title":"Development Workflow","text":"<pre><code>graph LR\n    A[Code Changes] --&gt; B[Test Locally]\n    B --&gt; C[Run Tests]\n    C --&gt; D[Update Docs]\n    D --&gt; E[Commit &amp; Push]\n\n    style A fill:#e3f2fd\n    style C fill:#e8f5e8\n    style E fill:#fff3e0</code></pre>"},{"location":"setup/installation/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<ul> <li>MongoDB Atlas Documentation</li> <li>uv Package Manager Guide</li> <li>OpenStreetMap Nominatim API</li> <li>MkDocs Material Theme</li> </ul>"},{"location":"setup/installation/#getting-help","title":"\ud83c\udd98 Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the logs for error details</li> <li>Review this troubleshooting section</li> <li>Search existing issues on GitHub</li> <li>Create a new issue with detailed error information</li> </ol> <p>Issue Template: <pre><code>## Environment\n- OS: [e.g., macOS 12.0]\n- Python: [e.g., 3.9.7]\n- uv: [e.g., 0.1.0]\n\n## Error Description\n[Describe what you were trying to do]\n\n## Error Output\n</code></pre> [Paste complete error message] <pre><code>## Steps to Reproduce\n1. [First step]\n2. [Second step]\n3. [etc.]\n</code></pre></p> <p>Your setup should now be complete and ready for development! \ud83c\udf89</p>"}]}